<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <script data-ad-client="ca-pub-2488174175014870" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script> <!-- google ad -->
    <meta name="google-site-verification" content="40lMg4eqLLbXoDcpN3h-cEnfmselbQ8tUzNvuC0IRIs" /><!-- google 站点认证 -->
    <meta name="baidu-site-verification" content="093lY4ziMu" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="description" content="A hexo theme">
    <meta name="keyword"  content="hexo, hexo-theme-lp">
    <link rel="shortcut icon" href="/img/ironman-draw.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <!--<link href='http://fonts.googleapis.com/css?family=Montserrat:400,700' rel='stylesheet' type='text/css'>-->
    <title>
        
          Hive 入门 - Hexo-theme-lp
        
    </title>

    <link rel="canonical" href="https://flepeng.github.io/2021/03/29/lepeng-Hadoop-Hive-入门/">

    <!-- Bootstrap Core CSS -->
    
<link rel="stylesheet" href="/css/bootstrap.min.css">


    <!-- Custom CSS --> 
    
        
<link rel="stylesheet" href="/css/dusign-light.css">

        
<link rel="stylesheet" href="/css/dusign-common-light.css">

        
<link rel="stylesheet" href="/css/font-awesome.css">

        
<link rel="stylesheet" href="/css/toc.css">

        <!-- background effects end -->
    
    
    <!-- Pygments Highlight CSS -->
    
<link rel="stylesheet" href="/css/highlight.css">


    
<link rel="stylesheet" href="/css/widget.css">


    
<link rel="stylesheet" href="/css/rocket.css">


    
<link rel="stylesheet" href="/css/signature.css">


    
<link rel="stylesheet" href="/css/fonts.googleapis.css">


    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">

    <!-- photography -->
    
<link rel="stylesheet" href="/css/photography.css">


    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- background effects start -->
    
    <!-- background effects end -->

	<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            
                background-image: linear-gradient(rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.3)), url('/img/header_img/archive-bg.jpg')
                /*post*/
            
        
    }
    
    #signature{
        background-image: url('/img/signature/dusign.png');
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#Hive" title="Hive">Hive</a>
                            
                        </div>
                        <h1>Hive 入门</h1>
                        <h2 class="subheading"></h2>
                        <span class="meta">
                            Posted by Lepeng on
                            2021-03-29
                        </span>

                        
                            <div class="blank_box"></div>
                            <span class="meta">
                                Words <span class="post-count">8.4k</span> and
                                Reading Time <span class="post-count">34</span> Minutes
                            </span>
                            <div class="blank_box"></div>
                            <!-- 不蒜子统计 start -->
                            <span class="meta">
                                Viewed <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span> Times
                            </span>
                            <!-- 不蒜子统计 end -->
                        

                    </div>
                

                </div>
            </div>
        </div>      
    </div>

    
    <div class="waveWrapper">
        <div class="wave wave_before" style="background-image: url('/img/wave-light.png')"></div>
        <div class="wave wave_after" style="background-image: url('/img/wave-light.png')"></div>
    </div>
    
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Lepeng</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/categories/">Categories</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archive/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                    
                    <li>
                        <a href="http://flepeng.com" target="_blank">chinese_blog</a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h1 id="1-Hive简介"><a href="#1-Hive简介" class="headerlink" title="1 Hive简介"></a>1 Hive简介</h1><h2 id="1-1-Hive简介"><a href="#1-1-Hive简介" class="headerlink" title="1.1 Hive简介"></a>1.1 Hive简介</h2><h3 id="1-1-1-什么是Hive"><a href="#1-1-1-什么是Hive" class="headerlink" title="1.1.1 什么是Hive"></a>1.1.1 什么是Hive</h3><p>Hive是基于Hadoop的数据仓库解决方案。由于Hadoop本身在数据存储和计算方面有很好的可扩展性和高容错性，因此使用Hive构建的数据仓库也秉承了这些特性。</p>
<p>这是来自官方的解释。</p>
<p>Hive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供类SQL查询功能。可以将sql语句转换为MapReduce任务进行运行。其优点是学习成本低，可以通过类SQL语句快速实现简单的MapReduce统计，不必开发专门的MapReduce应用，十分适合数据仓库的统计分析。Hive是一个数据仓库基础工具在Hadoop中用来处理结构化数据。它架构在Hadoop之上，总归为大数据，并使得查询和分析方便。</p>
<p>在Hive中，Hive是SQL解析引擎，它将SQL语句转译成M/R Job然后在Hadoop执行。Hive的表其实就是HDFS的目录/文件，按表名把文件夹分开。如果是分区表，则分区值是子文件夹，可以直接在M/RJob里使用这些数据。</p>
<p>简单来说，Hive就是在Hadoop上架了一层SQL接口，可以将SQL翻译成MapReduce去Hadoop上执行，这样就使得数据开发和分析人员很方便的使用SQL来完成海量数据的统计和分析，而不必使用编程语言开发MapReduce那么麻烦。</p>
<p>最初，Hive是由Facebook开发，后来由Apache软件基金会开发，并作为进一步将它作为名义下ApacheHive为一个开源项目。它用在好多不同的公司。例如，亚马逊使用它在Amazon Elastic、MapReduce。 </p>
<h3 id="1-1-2-为什么使用Hive"><a href="#1-1-2-为什么使用Hive" class="headerlink" title="1.1.2 为什么使用Hive"></a>1.1.2 为什么使用Hive</h3><ol>
<li><p>直接使用hadoop所面临的问题</p>
<p>人员学习成本太高<br>项目周期要求太短<br>MapReduce实现复杂查询逻辑开发难度太大</p>
</li>
<li><p>操作接口采用类SQL语法，提供快速开发的能力。</p>
<p>避免了去写MapReduce，减少开发人员的学习成本。<br>扩展功能很方便。</p>
</li>
</ol>
<h3 id="1-1-3-Hive的特点"><a href="#1-1-3-Hive的特点" class="headerlink" title="1.1.3 Hive的特点"></a>1.1.3 Hive的特点</h3><ol>
<li><p>可扩展</p>
<p>Hive可以自由的扩展集群的规模，一般情况下不需要重启服务。</p>
</li>
<li><p>延展性</p>
<p>Hive支持用户自定义函数，用户可以根据自己的需求来实现自己的函数。</p>
</li>
<li><p>容错</p>
<p>良好的容错性，节点出现问题SQL仍可完成执行。</p>
</li>
</ol>
<h3 id="1-1-4-Hive擅长什么"><a href="#1-1-4-Hive擅长什么" class="headerlink" title="1.1.4 Hive擅长什么"></a>1.1.4 Hive擅长什么</h3><p>Hive可以使用HQL(Hive SQL)很方便的完成对海量数据的统计汇总，即席查询和分析，除了很多内置的函数，还支持开发人员使用其他编程语言和脚本语言来自定义函数。</p>
<p>但是，由于Hadoop本身是一个批处理，高延迟的计算框架，Hive使用Hadoop作为执行引擎，自然也就有了批处理，高延迟的特点，在数据量很小的时候，Hive执行也需要消耗较长时间来完成，这时候，就显示不出它与Oracle，Mysql等传统数据库的优势。</p>
<p>此外，Hive对事物的支持不够好，原因是HDFS本身就设计为一次写入，多次读取的分布式存储系统，因此，不能使用Hive来完成诸如DELETE、UPDATE等在线事务处理的需求。</p>
<p>因此，Hive擅长的是非实时的、离线的、对响应及时性要求不高的海量数据批量计算，即席查询，统计分析。</p>
<h2 id="1-2-Hive架构"><a href="#1-2-Hive架构" class="headerlink" title="1.2 Hive架构"></a>1.2 Hive架构</h2><h3 id="1-2-1-架构图"><a href="#1-2-1-架构图" class="headerlink" title="1.2.1 架构图"></a>1.2.1 架构图</h3><p> <img src="/img/hive/Hive架构图.jpg" alt=""> </p>
<p>Jobtracker 是 hadoop1.x 中的组件，它的功能相当于：Resourcemanager+AppMaster</p>
<p>TaskTracker 相当于： Nodemanager + yarnchild</p>
<h3 id="1-2-2-基本组成"><a href="#1-2-2-基本组成" class="headerlink" title="1.2.2 基本组成"></a>1.2.2 基本组成</h3><ol>
<li><p>用户接口：包括 CLI、JDBC/ODBC、WebGUI。其中，CLI为shell命令行；JDBC/ODBC是Hive的JAVA实现，与传统数据库JDBC类似；WebGUI是通过浏览器访问Hive。</p>
</li>
<li><p>元数据存储：Hive 将元数据存储在关系数据库如 mysql , derby中。Hive 中的元数据包括表的名字，表的列和分区及其属性，表的属性（是否为外部表等），表的数据所在目录等。</p>
</li>
<li><p>解释器、编译器、优化器、执行器。解释器、编译器、优化器完成 HQL 查询语句从词法分析、语法分析、编译、优化以及查询计划的生成。生成的查询计划存储在 HDFS 中，并在随后有 MapReduce 调用执行。</p>
</li>
<li><p>Hive 的数据存储在 HDFS 中，大部分的查询由 MapReduce 完成（包含 <em> 的查询，比如 select </em> from table 不会生成 MapRedcue 任务）</p>
</li>
<li><p>Thrift是一个软件框架，用来进行可扩展且跨语言的服务的开发。它结合了功能强大的软件堆栈和代码生成引擎，以构建在 C++,Java, Go,Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, JavaScript,Node.js, Smalltalk, and OCaml这些编程语言间无缝结合的、高效的服务。</p>
</li>
</ol>
<h3 id="1-2-3-Metastore组件"><a href="#1-2-3-Metastore组件" class="headerlink" title="1.2.3 Metastore组件:"></a>1.2.3 Metastore组件:</h3><p>Hive的Metastore组件是Hive元数据集中存放地。Metastore组件包括两个部分：Metastore服务和后台数据的存储。后台数据存储的介质就是关系数据库，例如Hive默认的嵌入式磁盘数据库derby，还有mysql数据库。Metastore服务是建立在后台数据存储介质之上，并且可以和Hive服务进行交互的服务组件，默认情况下，Metastore服务和Hive服务是安装在一起的，运行在同一个进程当中。我也可以把Metastore服务从Hive服务里剥离出来，Metastore独立安装在一个集群里，Hive远程调用Metastore服务，这样我们可以把元数据这一层放到防火墙之后，客户端访问Hive服务，就可以连接到元数据这一层，从而提供了更好的管理性和安全保障。使用远程的Metastore服务，可以让Metastore服务和hive服务运行在不同的进程里，这样也保证了Hive的稳定性，提升了Hive服务的效率。</p>
<h3 id="1-2-4-Hive的执行流程"><a href="#1-2-4-Hive的执行流程" class="headerlink" title="1.2.4 Hive的执行流程"></a>1.2.4 Hive的执行流程</h3><p>如下图所示：<br> <img src="/img/hive/Hive运行图.jpg" alt=""> </p>
<h2 id="1-3-Hive与Hadoop的关系"><a href="#1-3-Hive与Hadoop的关系" class="headerlink" title="1.3 Hive与Hadoop的关系"></a>1.3 Hive与Hadoop的关系</h2><p>Hive利用HDFS存储数据，利用MapReduce查询数据</p>
<p><img src="/img/hive/1617015424-c1c2af6201e88323bec8e5712aa1aab8.png" alt=""></p>
<h2 id="1-4-Hive与传统数据库对比"><a href="#1-4-Hive与传统数据库对比" class="headerlink" title="1.4 Hive与传统数据库对比"></a>1.4 Hive与传统数据库对比</h2><p>如下所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>Hive</th>
<th>RDBMS</th>
</tr>
</thead>
<tbody>
<tr>
<td>查询语言</td>
<td>HiveQL</td>
<td>SQL</td>
</tr>
<tr>
<td>数据存储位置</td>
<td>HDFS</td>
<td>Raw  Device or 本地FS</td>
</tr>
<tr>
<td>数据格式</td>
<td>用户定义</td>
<td>系统决定</td>
</tr>
<tr>
<td>数据更新</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>索引</td>
<td>0.8 版本加入位图索引，但弱</td>
<td>有</td>
</tr>
<tr>
<td>执行</td>
<td>MapReduce</td>
<td>Executor</td>
</tr>
<tr>
<td>执行延迟</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>可扩展性</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>数据规模</td>
<td>大</td>
<td>小</td>
</tr>
</tbody>
</table>
</div>
<p>总结：hive具有sql数据库的外表，但应用场景完全不同，hive只适合用来做批量数据统计分析_</p>
<h2 id="1-5-Hive的数据存储"><a href="#1-5-Hive的数据存储" class="headerlink" title="1.5 Hive的数据存储"></a>1.5 Hive的数据存储</h2><ol>
<li><p>Hive中所有的数据都存储在 HDFS 中，没有专门的数据存储格式（可支持Text，SequenceFile，ParquetFile，RCFILE等）</p>
</li>
<li><p>只需要在创建表的时候告诉 Hive 数据中的列分隔符和行分隔符，Hive 就可以解析数据。</p>
</li>
<li><p>Hive 中包含以下数据模型：DB、Table，External Table，Partition，Bucket。</p>
<ul>
<li><p>db：在hdfs中表现为${hive.metastore.warehouse.dir}目录下一个文件夹</p>
</li>
<li><p>table：在hdfs中表现所属db目录下一个文件夹</p>
</li>
<li><p>external table：外部表, 与table类似，不过其数据存放位置可以在任意指定路径</p>
<ul>
<li><p>普通表: 删除表后, hdfs上的文件都删了</p>
</li>
<li><p>External外部表删除后, hdfs上的文件没有删除, 只是把文件删除了</p>
</li>
</ul>
</li>
<li><p>partition：在hdfs中表现为table目录下的子目录</p>
</li>
<li><p>bucket：桶, 在hdfs中表现为同一个表目录下根据hash散列之后的多个文件, 会根据不同的文件把数据放到不同的文件中</p>
</li>
</ul>
</li>
</ol>
<h2 id="1-6-HIVE的安装部署"><a href="#1-6-HIVE的安装部署" class="headerlink" title="1.6 HIVE的安装部署"></a>1.6 HIVE的安装部署</h2><h3 id="1-6-1-安装"><a href="#1-6-1-安装" class="headerlink" title="1.6.1 安装"></a>1.6.1 安装</h3><p>Hive是建立Hadoop环境安装之上的，所以需要Hadoop的集群环境搭建，Hive即需要依赖于HDFS又需要依赖YARN。安装好Hadoop后需要进行启动HDFS和YARN。<br>TODO</p>
<h3 id="1-6-2-使用方式"><a href="#1-6-2-使用方式" class="headerlink" title="1.6.2 使用方式"></a>1.6.2 使用方式</h3><h4 id="Hive交互shell"><a href="#Hive交互shell" class="headerlink" title="Hive交互shell"></a>Hive交互shell</h4><p>bin/hive</p>
<h4 id="Hive-thrift服务"><a href="#Hive-thrift服务" class="headerlink" title="Hive thrift服务"></a>Hive thrift服务</h4><p> <img src="/img/hive/1617015424-b2a3af727a48b1c2208d456dab63a042.png" alt=""></p>
<p>启动方式，（假如是在hadoop01上）：</p>
<p>启动为前台：bin/hiveserver2</p>
<p>启动为后台：nohup bin/hiveserver2 1&gt;/var/log/hiveserver.log 2&gt;/var/log/hiveserver.err &amp;</p>
<p>启动成功后，可以在别的节点上用beeline去连接</p>
<p>v 方式（1）</p>
<p>hive/bin/beeline  回车，进入beeline的命令界面</p>
<p>输入命令连接hiveserver2</p>
<p>beeline&gt; !connect jdbc:hive2//mini1:10000</p>
<p>（hadoop01是hiveserver2所启动的那台主机名，端口默认是10000）</p>
<p>v 方式（2）</p>
<p>或者启动就连接：</p>
<p><strong>bin/beeline -u jdbc:hive2://hadoop01:10000 -n hadoop</strong></p>
<p>接下来就可以做正常sql查询了</p>
<h4 id="Hive命令"><a href="#Hive命令" class="headerlink" title="Hive命令"></a>Hive命令</h4><p>[hadoop@hdp-node-02 ~]$ hive  -e  ‘sql’</p>
<h2 id="1-7-Hive的shell"><a href="#1-7-Hive的shell" class="headerlink" title="1.7  Hive的shell"></a>1.7  Hive的shell</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1、hive 命令行模式，直接输入#&#x2F;hive&#x2F;bin&#x2F;hive的执行程序，或者输入#hive --service cli</span><br><span class="line"></span><br><span class="line">2、 hive web界面的 (端口号9999) 启动方式</span><br><span class="line"></span><br><span class="line">#hive --service hwi&amp;</span><br><span class="line"></span><br><span class="line">用于通过浏览器来访问hive</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;hadoop0:9999&#x2F;hwi&#x2F;</span><br><span class="line"></span><br><span class="line">3、 hive 远程服务 (端口号10000) 启动方式</span><br><span class="line"></span><br><span class="line">#hive --service hiveserver&amp;</span><br></pre></td></tr></table></figure>
<h2 id="1-8-HIVE和HBASE区别"><a href="#1-8-HIVE和HBASE区别" class="headerlink" title="1.8  HIVE和HBASE区别"></a>1.8  HIVE和HBASE区别</h2><ol>
<li><p>两者分别是什么？  </p>
<p>Apache Hive是一个构建在Hadoop基础设施之上的数据仓库。通过Hive可以使用HQL语言查询存放在HDFS上的数据。HQL是一种类SQL语言，这种语言最终被转化为Map/Reduce. 虽然Hive提供了SQL查询功能，但是Hive不能够进行交互查询—因为它只能够在Haoop上批量的执行Hadoop。</p>
<p>Apache HBase是一种Key/Value系统，它运行在HDFS之上。和Hive不一样，Hbase的能够在它的数据库上实时运行，而不是运行MapReduce任务。Hive被分区为表格，表格又被进一步分割为列簇。列簇必须使用schema定义，列簇将某一类型列集合起来（列不要求schema定义）。例如，“message”列簇可能包含：“to”, ”from” “date”, “subject”, 和”body”. 每一个 key/value对在Hbase中被定义为一个cell，每一个key由row-key，列簇、列和时间戳。在Hbase中，行是key/value映射的集合，这个映射通过row-key来唯一标识。Hbase利用Hadoop的基础设施，可以利用通用的设备进行水平的扩展。</p>
</li>
<li><p>两者的特点：</p>
<p>Hive帮助熟悉SQL的人运行MapReduce任务。因为它是JDBC兼容的，同时，它也能够和现存的SQL工具整合在一起。运行Hive查询会花费很长时间，因为它会默认遍历表中所有的数据。虽然有这样的缺点，一次遍历的数据量可以通过Hive的分区机制来控制。分区允许在数据集上运行过滤查询，这些数据集存储在不同的文件夹内，查询的时候只遍历指定文件夹（分区）中的数据。这种机制可以用来，例如，只处理在某一个时间范围内的文件，只要这些文件名中包括了时间格式。</p>
<p>HBase通过存储key/value来工作。它支持四种主要的操作：增加或者更新行，查看一个范围内的cell，获取指定的行，删除指定的行、列或者是列的版本。版本信息用来获取历史数据（每一行的历史数据可以被删除，然后通过Hbase compactions就可以释放出空间）。虽然HBase包括表格，但是schema仅仅被表格和列簇所要求，列不需要schema。Hbase的表格包括增加/计数功能。</p>
</li>
<li><p>限制</p>
<p>Hive目前不支持更新操作。另外，由于hive在hadoop上运行批量操作，它需要花费很长的时间，通常是几分钟到几个小时才可以获取到查询的结果。Hive必须提供预先定义好的schema将文件和目录映射到列，并且Hive与ACID不兼容。</p>
<p>HBase查询是通过特定的语言来编写的，这种语言需要重新学习。类SQL的功能可以通过Apache Phonenix实现，但这是以必须提供schema为代价的。另外，Hbase也并不是兼容所有的ACID特性，虽然它支持某些特性。最后但不是最重要的—为了运行Hbase，Zookeeper是必须的，zookeeper是一个用来进行分布式协调的服务，这些服务包括配置服务，维护元信息和命名空间服务。</p>
</li>
<li><p>应用场景</p>
<p>Hive适合用来对一段时间内的数据进行分析查询，例如，用来计算趋势或者网站的日志。Hive不应该用来进行实时的查询。因为它需要很长时间才可以返回结果。</p>
<p>Hbase非常适合用来进行大数据的实时查询。Facebook用Hbase进行消息和实时的分析。它也可以用来统计Facebook的连接数。</p>
</li>
<li><p>总结</p>
<p>Hive和Hbase是两种基于Hadoop的不同技术—Hive是一种类SQL的引擎，并且运行MapReduce任务，Hbase是一种在Hadoop之上的NoSQL 的Key/vale数据库。当然，这两种工具是可以同时使用的。就像用Google来搜索，用FaceBook进行社交一样，Hive可以用来进行统计查询，HBase可以用来进行实时查询，数据也可以从Hive写到Hbase，设置再从Hbase写回Hive</p>
</li>
</ol>
<h1 id="2-Hive-基本操作"><a href="#2-Hive-基本操作" class="headerlink" title="2 Hive 基本操作"></a>2 Hive 基本操作</h1><h2 id="2-1-Hive-数据类型"><a href="#2-1-Hive-数据类型" class="headerlink" title="2.1 Hive 数据类型"></a>2.1 Hive 数据类型</h2><p>既然是被当做数据库来使用，除了数据单元，Hive当然也得有一些列的数据类型</p>
<h3 id="2-1-1-原始数据类型"><a href="#2-1-1-原始数据类型" class="headerlink" title="2.1.1 原始数据类型"></a>2.1.1 原始数据类型</h3><ol>
<li><p>整型</p>
<ul>
<li>TINYINT — 微整型，只占用1个字节，只能存储0-255的整数。</li>
<li>SMALLINT– 小整型，占用2个字节，存储范围–32768 到 32767。</li>
<li>INT– 整型，占用4个字节，存储范围-2147483648到2147483647。</li>
<li>BIGINT– 长整型，占用8个字节，存储范围-2^63到2^63-1。</li>
</ul>
</li>
<li><p>布尔型</p>
<ul>
<li>BOOLEAN — TRUE/FALSE</li>
</ul>
</li>
<li><p>浮点型</p>
<ul>
<li>FLOAT– 单精度浮点数。</li>
<li>DOUBLE– 双精度浮点数。</li>
</ul>
</li>
<li><p>字符串型</p>
<ul>
<li>STRING– 不设定长度。</li>
</ul>
</li>
</ol>
<h3 id="2-1-2-复合数据类型"><a href="#2-1-2-复合数据类型" class="headerlink" title="2.1.2 复合数据类型"></a>2.1.2 复合数据类型</h3><ol>
<li>Structs：一组由任意数据类型组成的结构。比如，定义一个字段C的类型为STRUCT {a INT; b STRING}，则可以使用a和C.b来获取其中的元素值；</li>
<li>Maps：和Java中的Map没什么区别，就是存储K-V对的；</li>
<li>Arrays：就是数组而已；</li>
</ol>
<h2 id="2-1-Hive-交互式模式"><a href="#2-1-Hive-交互式模式" class="headerlink" title="2.1 Hive 交互式模式"></a>2.1 Hive 交互式模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">quit,exit:  退出交互式shell</span><br><span class="line">reset: 重置配置为默认值</span><br><span class="line">set &lt;key&gt;&#x3D;&lt;value&gt; : 修改特定变量的值(如果变量名拼写错误，不会报错)</span><br><span class="line">set :  输出用户覆盖的hive配置变量</span><br><span class="line">set -v : 输出所有Hadoop和Hive的配置变量</span><br><span class="line">add FILE[S] *, add JAR[S] *, add ARCHIVE[S] * : 添加 一个或多个 file, jar, archives到分布式缓存</span><br><span class="line">list FILE[S], list JAR[S], list ARCHIVE[S] : 输出已经添加到分布式缓存的资源。</span><br><span class="line">list FILE[S] *, list JAR[S] *,list ARCHIVE[S] * : 检查给定的资源是否添加到分布式缓存</span><br><span class="line">delete FILE[S] *,delete JAR[S] *,delete ARCHIVE[S] * : 从分布式缓存删除指定的资源</span><br><span class="line">! &lt;command&gt; :  从Hive shell执行一个shell命令</span><br><span class="line">dfs &lt;dfs command&gt; :  从Hive shell执行一个dfs命令</span><br><span class="line">&lt;query string&gt; : 执行一个Hive 查询，然后输出结果到标准输出</span><br><span class="line">source FILE &lt;filepath&gt;:  在CLI里执行一个hive脚本文件</span><br></pre></td></tr></table></figure>
<h2 id="2-1-DDL操作"><a href="#2-1-DDL操作" class="headerlink" title="2.1 DDL操作"></a>2.1 DDL操作</h2><h3 id="2-1-1-创建表"><a href="#2-1-1-创建表" class="headerlink" title="2.1.1 创建表"></a>2.1.1 创建表</h3><h4 id="建表语法"><a href="#建表语法" class="headerlink" title="建表语法"></a>建表语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE [EXTERNAL] TABLE [IF NOT EXISTS] table_name</span><br><span class="line">   [(col_name data_type [COMMENT col_comment], ...)]</span><br><span class="line">   [COMMENT table_comment]</span><br><span class="line">   [PARTITIONED BY (col_name data_type [COMMENT col_comment], ...)] # 创建分区</span><br><span class="line">   [CLUSTERED BY (col_name, col_name, ...) # 创建分桶表</span><br><span class="line">   [SORTED BY (col_name [ASC|DESC], ...)] INTO num_buckets BUCKETS]</span><br><span class="line">   [ROW FORMAT row_format] # 指定表的分隔符</span><br><span class="line">   [STORED AS file_format] </span><br><span class="line">   [LOCATION hdfs_path]   # 指定表的存储位置</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ol>
<li><p>CREATE TABLE 创建一个指定名字的表。如果相同名字的表已经存在，则抛出异常；用户可以用 IF NOT EXISTS 选项来忽略这个异常。</p>
</li>
<li><p>EXTERNAL关键字可以让用户创建一个外部表，在建表的同时指定一个指向实际数据的路径（LOCATION），Hive 创建内部表时，会将数据移动到数据仓库指向的路径；若创建外部表，仅记录数据所在的路径，不对数据的位置做任何改变。在删除表的时候，内部表的元数据和数据会被一起删除，而外部表只删除元数据，不删除数据。</p>
</li>
<li><p>LIKE 允许用户复制现有的表结构，但是不复制数据。</p>
</li>
<li><p>ROW FORMAT DELIMITED [FIELDS TERMINATED BY char] [COLLECTION ITEMS TERMINATED BY char] [MAP KEYS TERMINATED BY char] [LINES TERMINATED BY char] | SERDE serde_name [WITH SERDEPROPERTIES (property_name=property_value, property_name=property_value, …)]</p>
<p>用户在建表的时候可以自定义 SerDe 或者使用自带的 SerDe。如果没有指定 ROW FORMAT 或者 ROW FORMAT DELIMITED，将会使用自带的 SerDe。</p>
<p>在建表的时候，用户还需要为表指定列，用户在指定表的列的同时也会指定自定义的 SerDe，Hive通过 SerDe 确定表的具体的列的数据。</p>
</li>
<li><p>STORED AS</p>
<p> SEQUENCEFILE|TEXTFILE|RCFILE</p>
<p> 如果文件数据是纯文本，可以使用 STORED AS TEXTFILE。如果数据需要压缩，使用 STORED AS SEQUENCEFILE。</p>
</li>
<li><p>CLUSTERED BY</p>
<p> 对于每一个表（table）或者分区， Hive可以进一步组织成桶，也就是说桶是更为细粒度的数据范围划分。Hive也是 针对某一列进行桶的组织。Hive采用对列值哈希，然后除以桶的个数求余的方式决定该条记录存放在哪个桶当中。</p>
<p> 把表（或者分区）组织成桶（Bucket）有两个理由：</p>
<ul>
<li><p>获得更高的查询处理效率。桶为表加上了额外的结构，Hive 在处理有些查询时能利用这个结构。具体而言，连接两个在（包含连接列的）相同列上划分了桶的表，可以使用 Map 端连接 （Map-side join）高效的实现。比如JOIN操作。对于JOIN操作两个表有一个相同的列，如果对这两个表都进行了桶操作。那么将保存相同列值的桶进行JOIN操作就可以，可以大大较少JOIN的数据量。</p>
</li>
<li><p>使取样（sampling）更高效。在处理大规模数据集时，在开发和修改查询的阶段，如果能在数据集的一小部分数据上试运行查询，会带来很多方便。</p>
</li>
</ul>
</li>
</ol>
<h4 id="具体实例"><a href="#具体实例" class="headerlink" title="具体实例"></a>具体实例</h4><p>创建内部表mytable。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; create table if not exists mytable(sid int,sname string)  </span><br><span class="line">   &gt; row format delimited fields terminated by &#39;,&#39; </span><br><span class="line">    &gt; stored as textfile;</span><br></pre></td></tr></table></figure>
<p>创建外部表pageview。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> hive&gt; create external table if not exists pageview(  </span><br><span class="line">    &gt; pageid int,</span><br><span class="line">    &gt; page_url string comment &#39;The page URL&#39;)  </span><br><span class="line">    &gt; row format delimited fields terminated by &#39;,&#39;  </span><br><span class="line">    &gt; location &#39;hdfs:&#x2F;&#x2F;192.168.158.171:9000&#x2F;user&#x2F;hivewarehouse&#x2F;&#39;;</span><br></pre></td></tr></table></figure>
<p>创建分区表invites。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; create table student_p(  </span><br><span class="line">    &gt; Sno int,  </span><br><span class="line">    &gt; Sname string,  </span><br><span class="line">    &gt; Sex string,  </span><br><span class="line">    &gt; Sage int,  </span><br><span class="line">    &gt; Sdept string)   </span><br><span class="line">    &gt; partitioned by(part string)   </span><br><span class="line">    &gt; row format delimited fields terminated by &#39;,&#39;stored as textfile;</span><br></pre></td></tr></table></figure>
<p>创建带桶的表student。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> hive&gt; create table student(id int,age int,name string)  </span><br><span class="line">    &gt; partitioned by(stat_data string)  </span><br><span class="line">    &gt; clustered by(id) sorted by(age) into 2 buckets  </span><br><span class="line">    &gt; row format delimited fields terminated by &#39;,&#39;;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-2-修改表"><a href="#2-1-2-修改表" class="headerlink" title="2.1.2 修改表"></a>2.1.2 修改表</h3><h4 id="增加-删除分区"><a href="#增加-删除分区" class="headerlink" title="增加/删除分区"></a>增加/删除分区</h4><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name ADD [IF NOT EXISTS] partition_spec [ LOCATION &#39;location1&#39; ] partition_spec [ LOCATION &#39;location2&#39; ] ...</span><br><span class="line"></span><br><span class="line">partition_spec:</span><br><span class="line"></span><br><span class="line">: PARTITION (partition_col &#x3D; partition_col_value, partition_col &#x3D; partiton_col_value, ...)</span><br><span class="line"></span><br><span class="line">ALTER TABLE table_name DROP partition_spec, partition_spec,...</span><br></pre></td></tr></table></figure>
<p>具体实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table student_p add partition(part&#x3D;&#39;a&#39;) partition(part&#x3D;&#39;b&#39;);</span><br></pre></td></tr></table></figure>
<h4 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h4><h5 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name RENAME TO new_table_name</span><br></pre></td></tr></table></figure>
<h5 id="具体实例-1"><a href="#具体实例-1" class="headerlink" title="具体实例"></a>具体实例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table student rename to student1;</span><br></pre></td></tr></table></figure>
<h4 id="增加-更新列"><a href="#增加-更新列" class="headerlink" title="增加/更新列"></a>增加/更新列</h4><h5 id="语法结构-1"><a href="#语法结构-1" class="headerlink" title="语法结构"></a>语法结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name ADD|REPLACE COLUMNS (col_name data_type [COMMENT col_comment], ...)</span><br><span class="line"># _注：ADD是代表新增一字段，字段位置在所有列后面(partition列前)，REPLACE则是表示替换表中所有字段。_</span><br><span class="line"></span><br><span class="line">ALTER TABLE table_name CHANGE [COLUMN] col_old_name col_new_name column_type [COMMENT col_comment] [FIRST|AFTER column_name]</span><br></pre></td></tr></table></figure>
<h5 id="具体实例-2"><a href="#具体实例-2" class="headerlink" title="具体实例"></a>具体实例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE student ADD (age int);</span><br></pre></td></tr></table></figure>
<h3 id="2-1-3-删除表"><a href="#2-1-3-删除表" class="headerlink" title="2.1.3 删除表"></a>2.1.3 删除表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; DROP TABLE test1;</span><br><span class="line">OK</span><br><span class="line">Time taken: 0.191 seconds</span><br></pre></td></tr></table></figure>
<h3 id="2-1-4-数据库相关"><a href="#2-1-4-数据库相关" class="headerlink" title="2.1.4 数据库相关"></a>2.1.4 数据库相关</h3><p>创建数据库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create database  [if not exists]   dbName  [location  path];</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">    create database db1;  &#x2F;&#x2F;    &#x2F;user&#x2F;hive&#x2F;warehouse&#x2F;</span><br><span class="line">    create database db1;&#x2F;&#x2F;报错 </span><br><span class="line">    create database if not exists db1;</span><br><span class="line"></span><br><span class="line">    create database  db2 location &#39;&#x2F;user&#x2F;db2.db&#39;;</span><br></pre></td></tr></table></figure>
<p>查看数据库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用某一个数据库：use databaseName;</span><br><span class="line">查看所有的数据库：show databases;</span><br><span class="line">查看某一个数据库的详细信息：desc database [extended]  dbName</span><br></pre></td></tr></table></figure>
<p>修改数据库</p>
<p>只能修改数据库的描述信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter database  dbName  set dbproperties(&#39;desc&#39;&#x3D;&#39;ceshi db&#39;);</span><br></pre></td></tr></table></figure>
<p>删除数据库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop database [if exists] dbName</span><br></pre></td></tr></table></figure>
<h3 id="2-1-4-显示命令"><a href="#2-1-4-显示命令" class="headerlink" title="2.1.4 显示命令"></a>2.1.4 显示命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">show tables;  # 查看当前库中的所有的表</span><br><span class="line">show tables like &#39;*name*&#39;; # hive模糊搜索表</span><br><span class="line">show tables in dbName;     # 指定查看某一个数据库中的所有的表</span><br><span class="line">show create table tbName;  # 查看某一个表的具体的建表语句（获取当前表设置的分隔符信息）</span><br><span class="line">show databases</span><br><span class="line">show partitions</span><br><span class="line">show functions</span><br><span class="line">show partitions table_name; # 查看分区信息</span><br><span class="line"></span><br><span class="line">desc tbName; 查看表中的具体的字段信息</span><br><span class="line">desc extended tbName ; 查看表的详情 （查看外部表）</span><br><span class="line">desc formatted tbName ; 查看表的详情 （查看内部表和外部表）</span><br></pre></td></tr></table></figure>
<h2 id="2-2-DML操作"><a href="#2-2-DML操作" class="headerlink" title="2.2 DML操作"></a>2.2 DML操作</h2><h3 id="2-2-1-加载"><a href="#2-2-1-加载" class="headerlink" title="2.2.1 加载"></a>2.2.1 加载</h3><p>语法结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOAD DATA [LOCAL] INPATH &#39;filepath&#39; [OVERWRITE] INTO TABLE tablename [PARTITION (partcol1&#x3D;val1, partcol2&#x3D;val2 ...)]</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ol>
<li><p>Load 操作只是单纯的复制/移动操作，将数据文件移动到 Hive 表对应的位置。</p>
</li>
<li><p>filepath：</p>
<ul>
<li>相对路径，例如：project/data1</li>
<li>绝对路径，例如：/user/hive/project/data1</li>
<li>包含模式的完整 URI，列如：hdfs://namenode:9000/user/hive/project/data1</li>
</ul>
</li>
<li><p>LOCAL关键字</p>
<p>如果指定了 LOCAL， load 命令会去查找本地文件系统中的 filepath。<br>如果没有指定 LOCAL 关键字，则根据inpath中的uri查找文件</p>
</li>
<li><p>OVERWRITE 关键字</p>
<p>如果使用了 OVERWRITE 关键字，则目标表（或者分区）中的内容会被删除，然后再将 filepath 指向的文件/目录中的内容添加到表/分区中。<br>如果目标表（分区）已经有一个文件，并且文件名和 filepath 中的文件名冲突，那么现有的文件会被新文件所替代。</p>
<p>具体实例</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 加载相对路径数据。</span><br><span class="line">  hive&gt; load data local inpath &#39;sc.txt&#39; overwrite into table sc;  </span><br><span class="line"></span><br><span class="line"># 加载绝对路径数据。OVERWRITE关键字使用</span><br><span class="line"> hive&gt; load data local inpath &#39;&#x2F;home&#x2F;hadoop&#x2F;hivedata&#x2F;students.txt&#39; overwrite into table student;</span><br><span class="line"></span><br><span class="line"># 加载包含模式数据。OVERWRITE关键字使用</span><br><span class="line"> hive&gt; load data inpath &#39;hdfs:&#x2F;&#x2F;mini1:9000&#x2F;hivedata&#x2F;course.txt&#39; overwrite into table course;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-2-Insert"><a href="#2-2-2-Insert" class="headerlink" title="2.2.2 Insert"></a>2.2.2 Insert</h3><p> 将查询结果插入Hive表</p>
<p>语法结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 基本模式插入</span><br><span class="line">INSERT OVERWRITE TABLE tablename1 [PARTITION (partcol1&#x3D;val1, partcol2&#x3D;val2 ...)] select_statement1 FROM from_statement</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 多插入模式 Multiple inserts:</span><br><span class="line"></span><br><span class="line">FROM from_statement</span><br><span class="line"></span><br><span class="line">INSERT OVERWRITE TABLE tablename1 [PARTITION (partcol1&#x3D;val1, partcol2&#x3D;val2 ...)] select_statement1</span><br><span class="line"></span><br><span class="line">[INSERT OVERWRITE TABLE tablename2 [PARTITION ...] select_statement2] ...</span><br><span class="line"></span><br><span class="line"># 自动分区模式Dynamic partition inserts:</span><br><span class="line"></span><br><span class="line">INSERT OVERWRITE TABLE tablename PARTITION (partcol1[&#x3D;val1], partcol2[&#x3D;val2] ...) select_statement FROM from_statement</span><br></pre></td></tr></table></figure>
<p>具体实例</p>
<p>1、导出文件到本地。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> hive&gt; insert overwrite local directory &#39;&#x2F;home&#x2F;hadoop&#x2F;hivedata&#x2F;outdata&#39;  </span><br><span class="line">    &gt; select * from student;</span><br></pre></td></tr></table></figure></p>
<p>说明：</p>
<p><em>数据写入到文件系统时进行文本序列化，且每列用^A来区分，\n为换行符。用more命令查看时不容易看出分割符，</em></p>
<p><em>可以使用: sed -e ‘s/\x01/|/g’ filename来查看。</em></p>
<p>如：sed -e ‘s/\x01/,/g’ 000000_0</p>
<p>2、导出数据到HDFS。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> hive&gt; insert overwrite directory &#39;hdfs:&#x2F;&#x2F;mini1:9000&#x2F;hivedata&#x2F;outdatasc&#39;  </span><br><span class="line">    &gt; select \* from sc;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-3-SELECT"><a href="#2-2-3-SELECT" class="headerlink" title="2.2.3 SELECT"></a>2.2.3 SELECT</h3><p>基本的Select操作</p>
<p>语法结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT [ALL | DISTINCT] select_expr, select_expr, ...</span><br><span class="line">FROM table_reference</span><br><span class="line">[WHERE where_condition]</span><br><span class="line">[GROUP BY col_list [HAVING condition]]</span><br><span class="line">[CLUSTER BY col_list</span><br><span class="line">  | [DISTRIBUTE BY col_list] [SORT BY| ORDER BY col_list]</span><br><span class="line">]</span><br><span class="line">[LIMIT number]</span><br></pre></td></tr></table></figure>
<ol>
<li><p>order by 会对输入做全局排序，因此只有一个reducer，会导致当输入规模较大时，需要较长的计算时间。</p>
</li>
<li><p>sort by不是全局排序，其在数据进入reducer前完成排序。因此，如果用sort by进行排序，并且设置mapred.reduce.tasks&gt;1，则sort by只保证每个reducer的输出有序，不保证全局有序。</p>
</li>
<li><p>distribute by根据distribute by指定的内容将数据分到同一个reducer。</p>
</li>
<li><p>Cluster by 除了具有Distribute by的功能外，还会对该字段进行排序。因此，常常认为cluster by = distribute by + sort by</p>
</li>
</ol>
<p>具体实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 1、获取年龄大的3个学生。</span><br><span class="line">hive&gt; select sno,sname,sage from student order by sage desc limit 3;</span><br><span class="line"></span><br><span class="line"># 2、查询学生信息按年龄，降序排序。</span><br><span class="line">hive&gt; select sno,sname,sage from student sort by sage desc;</span><br><span class="line">hive&gt; select sno,sname,sage from student order by sage desc;  </span><br><span class="line">hive&gt; select sno,sname,sage from student distribute by sage;  </span><br><span class="line"></span><br><span class="line"># 3、按学生名称汇总学生年龄。</span><br><span class="line">hive&gt; select sname,sum(sage) from student group by sname;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-Hive-Join"><a href="#2-3-Hive-Join" class="headerlink" title="2.3 Hive Join"></a>2.3 Hive Join</h2><p>语法结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">join_table:</span><br><span class="line"></span><br><span class="line">  table_reference JOIN table_factor [join_condition]</span><br><span class="line"></span><br><span class="line">  | table_reference &#123;LEFT|RIGHT|FULL&#125; [OUTER] JOIN table_reference join_condition</span><br><span class="line"></span><br><span class="line">  | table_reference LEFT SEMI JOIN table_reference join_condition</span><br></pre></td></tr></table></figure>
<p>Hive 支持等值连接（equality joins）、外连接（outer joins）和（left/right joins）。Hive <strong>不支持非等值的连接（后续版本已经支持）</strong>，因为非等值连接非常难转化到 map/reduce 任务。</p>
<p>另外，Hive 支持多于 2 个表的连接。</p>
<p>写 join 查询时，需要注意几个关键点：</p>
<ol>
<li><p>只支持等值join</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 正确的</span><br><span class="line">SELECT a.* FROM a JOIN b ON (a.id &#x3D; b.id)</span><br><span class="line">SELECT a.* FROM a JOIN b ON (a.id &#x3D; b.id AND a.department &#x3D; b.department)</span><br><span class="line"></span><br><span class="line"># 错误的</span><br><span class="line">  SELECT a.* FROM a JOIN b ON (a.id&gt;b.id)</span><br></pre></td></tr></table></figure>
<p>tips:后续版本已经可以支持不等值</p>
</li>
<li><p>可以 join 多于 2 个表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SELECT a.val, b.val, c.val FROM a JOIN b ON (a.key &#x3D; b.key1) JOIN c ON (c.key &#x3D; b.key2)</span><br><span class="line"></span><br><span class="line"># 如果join中多个表的 join key 是同一个，则 join 会被转化为单个 map&#x2F;reduce 任务，例如：</span><br><span class="line"></span><br><span class="line">SELECT a.val, b.val, c.val FROM a JOIN b</span><br><span class="line">ON (a.key &#x3D; b.key1) JOIN c</span><br><span class="line">ON (c.key &#x3D; b.key1)</span><br><span class="line"></span><br><span class="line"># 被转化为单个 map&#x2F;reduce 任务，因为 join 中只使用了 b.key1 作为 join key。</span><br><span class="line"></span><br><span class="line">SELECT a.val, b.val, c.val FROM a JOIN b </span><br><span class="line">ON (a.key &#x3D; b.key1)</span><br><span class="line">JOIN c ON (c.key &#x3D; b.key2)</span><br><span class="line"></span><br><span class="line"># 而这一 join 被转化为 2 个 map&#x2F;reduce 任务。因为 b.key1 用于第一次 join 条件，而 b.key2 用于第二次 join。</span><br></pre></td></tr></table></figure>
</li>
<li><p>join 时，每次 map/reduce 任务的逻辑：</p>
<p>reducer 会缓存 join 序列中除了最后一个表的所有表的记录，再通过最后一个表将结果序列化到文件系统。这一实现有助于在 reduce 端减少内存的使用量。实践中，应该把最大的那个表写在最后（否则会因为缓存浪费大量内存）。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT a.val, b.val, c.val FROM a</span><br><span class="line">JOIN b ON (a.key &#x3D; b.key1) JOIN c ON (c.key &#x3D; b.key1)</span><br></pre></td></tr></table></figure>
<p>所有表都使用同一个 join key（使用 1 次 map/reduce 任务计算）。Reduce 端会缓存 a 表和 b 表的记录，然后每次取得一个 c 表的记录就计算一次 join 结果，类似的还有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT a.val, b.val, c.val FROM a</span><br><span class="line">JOIN b ON (a.key &#x3D; b.key1) JOIN c ON (c.key &#x3D; b.key2)</span><br></pre></td></tr></table></figure>
<p>这里用了 2 次 map/reduce 任务。第一次缓存 a 表，用 b 表序列化；第二次缓存第一次 map/reduce 任务的结果，然后用 c 表序列化。</p>
</li>
<li><p>LEFT，RIGHT 和 FULL OUTER 关键字用于处理 join 中空记录的情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT a.val, b.val FROM a LEFT OUTER JOIN b ON (a.key&#x3D;b.key)</span><br></pre></td></tr></table></figure>
<p>对应所有 a 表中的记录都有一条记录输出。输出的结果应该是 a.val, b.val，当 a.key=b.key 时，而当 b.key 中找不到等值的 a.key 记录时也会输出:a.val, NULL所以 a 表中的所有记录都被保留了；</p>
<p>“a RIGHT OUTER JOIN b”会保留所有 b 表的记录。</p>
<p>Join 发生在 WHERE 子句之前。如果你想限制 join 的输出，应该在 WHERE 子句中写过滤条件——或是在 join 子句中写。这里面一个容易混淆的问题是表分区的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT a.val, b.val FROM a</span><br><span class="line">LEFT OUTER JOIN b ON (a.key&#x3D;b.key)</span><br><span class="line">WHERE a.ds&#x3D;&#39;2009-07-07&#39; AND b.ds&#x3D;&#39;2009-07-07&#39;</span><br></pre></td></tr></table></figure>
<p>会 join a 表到 b 表（OUTER JOIN），列出 a.val 和 b.val 的记录。WHERE 从句中可以使用其他列作为过滤条件。但是，如前所述，如果 b 表中找不到对应 a 表的记录，b 表的所有列都会列出 NULL，<strong>包括 ds 列</strong>。也就是说，join 会过滤 b 表中不能找到匹配 a 表 join key 的所有记录。这样的话，LEFT OUTER 就使得查询结果与 WHERE 子句无关了。解决的办法是在 OUTER JOIN 时使用以下语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  SELECT a.val, b.val FROM a LEFT OUTER JOIN b</span><br><span class="line">  ON (a.key&#x3D;b.key AND b.ds&#x3D;&#39;2009-07-07&#39; AND a.ds&#x3D;&#39;2009-07-07&#39;)</span><br></pre></td></tr></table></figure>
<p>这一查询的结果是预先在 join 阶段过滤过的，所以不会存在上述问题。这一逻辑也可以应用于 RIGHT 和 FULL 类型的 join 中。</p>
<p>Join 是不能交换位置的。无论是 LEFT 还是 RIGHT join，都是左连接的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  SELECT a.val1, a.val2, b.val, c.val</span><br><span class="line">  FROM a</span><br><span class="line">  JOIN b ON (a.key &#x3D; b.key)</span><br><span class="line">  LEFT OUTER JOIN c ON (a.key &#x3D; c.key)</span><br></pre></td></tr></table></figure>
<p>先 join a 表到 b 表，丢弃掉所有 join key 中不匹配的记录，然后用这一中间结果和 c 表做 join。这一表述有一个不太明显的问题，就是当一个 key 在 a 表和 c 表都存在，但是 b 表中不存在的时候：整个记录在第一次 join，即 a JOIN b 的时候都被丢掉了（包括a.val1，a.val2和a.key），然后我们再和 c 表 join 的时候，如果 c.key 与 a.key 或 b.key 相等，就会得到这样的结果：NULL, NULL, NULL, c.val</p>
<p>具体实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、 查询选修了课程的学生姓名</span><br><span class="line">hive&gt; select distinct Sname from student inner join sc on student.Sno&#x3D;Sc.Sno;  </span><br><span class="line">2.查询选修了3门以上的课程的学生学号  </span><br><span class="line">hive&gt; select Sno from (select Sno,count(Cno) CountCno from sc group by Sno)a where a.CountCno&gt;3;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="3-Hive-Shell参数"><a href="#3-Hive-Shell参数" class="headerlink" title="3 Hive Shell参数"></a>3 Hive Shell参数</h1><h2 id="3-1-Hive命令行"><a href="#3-1-Hive命令行" class="headerlink" title="3.1 Hive命令行"></a>3.1 Hive命令行</h2><p>语法结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive [-hiveconf x&#x3D;y]\* [&lt;-i filename&gt;]\* [&lt;-f filename&gt;|&lt;-e query-string&gt;] [-S]</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ol>
<li>-i 从文件初始化HQL。</li>
<li>-e从命令行执行指定的HQL</li>
<li>-f 执行HQL脚本</li>
<li>-v 输出执行的HQL语句到控制台</li>
<li>-p <port> connect to Hive Server on port number</li>
<li>-hiveconf x=y Use this to set hive/hadoop configuration variables.</li>
</ol>
<p>具体实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、运行一个查询。</span><br><span class="line"> hive -e &#39;select count(\*) from student&#39;</span><br><span class="line"></span><br><span class="line">2、运行一个文件。</span><br><span class="line">hive -f hql.hql</span><br><span class="line"></span><br><span class="line">3、运行参数文件。</span><br><span class="line"> hive -i initHQL.conf</span><br></pre></td></tr></table></figure>
<h2 id="3-2-Hive参数配置方式"><a href="#3-2-Hive参数配置方式" class="headerlink" title="3.2 Hive参数配置方式"></a>3.2 Hive参数配置方式</h2><p>Hive参数大全：<a href="https://cwiki.apache.org/confluence/display/Hive/Configuration+Properties" target="_blank" rel="noopener">https://cwiki.apache.org/confluence/display/Hive/Configuration+Properties</a></p>
<p>开发Hive应用时，不可避免地需要设定Hive的参数。设定Hive的参数可以调优HQL代码的执行效率，或帮助定位问题。然而实践中经常遇到的一个问题是，为什么设定的参数没有起作用？这通常是错误的设定方式导致的。</p>
<p><strong>对于一般参数，有以下三种设定方式：</strong></p>
<p>1.)配置文件<br>2.)命令行参数<br>3.)参数声明 </p>
<p><strong>配置文件</strong>：Hive的配置文件包括</p>
<p>1.)用户自定义配置文件：$HIVE_CONF_DIR/hive-site.xml<br>2.)默认配置文件：$HIVE_CONF_DIR/hive-default.xml</p>
<p>用户自定义配置会覆盖默认配置。</p>
<p>另外，Hive也会读入Hadoop的配置，因为Hive是作为Hadoop的客户端启动的，Hive的配置会覆盖Hadoop的配置。</p>
<p>配置文件的设定对本机启动的所有Hive进程都有效。</p>
<p><strong>命令行参数</strong>：启动Hive（客户端或Server方式）时，可以在命令行添加-hiveconf param=value来设定参数，例如：</p>
<p>bin/hive -hiveconf hive.root.logger=INFO,console</p>
<p>这一设定对本次启动的Session（对于Server方式启动，则是所有请求的Sessions）有效。</p>
<p><strong>参数声明</strong>：可以在HQL中使用SET关键字设定参数，例如：</p>
<p>set mapred.reduce.tasks=100;</p>
<p>这一设定的作用域也是session级的。</p>
<p>上述三种设定方式的优先级依次递增。即参数声明覆盖命令行参数，命令行参数覆盖配置文件设定。注意某些系统级的参数，例如log4j相关的设定，必须用前两种方式设定，因为那些参数的读取在Session建立以前已经完成了。</p>
<h1 id="4-Hive函数"><a href="#4-Hive函数" class="headerlink" title="4 Hive函数"></a>4 Hive函数</h1><h2 id="4-1-内置运算符"><a href="#4-1-内置运算符" class="headerlink" title="4.1 内置运算符"></a>4.1 内置运算符</h2><p><em>内容较多，见《Hive官方文档》</em> </p>
<p><em><a href="http://hive.apache.org/" target="_blank" rel="noopener">http://hive.apache.org/</a></em></p>
<h2 id="4-2-内置函数"><a href="#4-2-内置函数" class="headerlink" title="4.2 内置函数"></a><strong>4.2 内置函数</strong></h2><p><em>内容较多，见《Hive官方文档》</em> </p>
<p><em><a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+UDF" target="_blank" rel="noopener">https://cwiki.apache.org/confluence/display/Hive/LanguageManual+UDF</a></em></p>
<h2 id="4-3-Hive自定义函数和Transform"><a href="#4-3-Hive自定义函数和Transform" class="headerlink" title="4.3 Hive自定义函数和Transform"></a><strong>4.3 Hive自定义函数和</strong>Transform</h2><p>当Hive提供的内置函数无法满足你的业务处理需要时，此时就可以考虑使用用户自定义函数（UDF：user-defined function）。</p>
<h3 id="4-3-1-自定义函数类别"><a href="#4-3-1-自定义函数类别" class="headerlink" title="4.3.1 自定义函数类别"></a><strong>4.3.1 自定义函数类别</strong></h3><p>UDF 作用于单个数据行，产生一个数据行作为输出。（数学函数，字符串函数）</p>
<p>UDAF（用户定义聚集函数）：接收多个输入数据行，并产生一个输出数据行。（count，max）</p>
<h3 id="4-3-2-UDF开发实例"><a href="#4-3-2-UDF开发实例" class="headerlink" title="4.3.2 UDF开发实例"></a><strong>4.3.2 UDF开发实例</strong></h3><p>1、先开发一个java类，继承UDF，并重载evaluate方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package cn.lyx.bigdata.udf</span><br><span class="line">import org.apache.hadoop.hive.ql.exec.UDF;</span><br><span class="line">import org.apache.hadoop.io.Text;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public final class Lower extends UDF&#123;</span><br><span class="line">    public Text evaluate(final Text s)&#123;</span><br><span class="line">        if(s&#x3D;&#x3D;null)&#123;return null;&#125;</span><br><span class="line">        return new Text(s.toString().toLowerCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、打成jar包上传到服务器</p>
<p>3、将jar包添加到hive的classpath</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt;add JAR &#x2F;home&#x2F;hadoop&#x2F;udf.jar;</span><br></pre></td></tr></table></figure>
<p>4、创建临时函数与开发好的java class关联</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hive&gt;create temporary function toprovince as &#39;cn.lyx.bigdata.udf.ToProvince&#39;;</span><br></pre></td></tr></table></figure>
<p>5、即可在hql中使用自定义的函数strip </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select strip(name),age from t_test;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-3-Transform实现"><a href="#4-3-3-Transform实现" class="headerlink" title="4.3.3 Transform实现"></a><strong>4.3.3 Transform实现</strong></h3><p>Hive的 TRANSFORM 关键字<strong><em>提供了在SQL中调用自写脚本的功能</em></strong></p>
<p>适合实现Hive中没有的功能又不想写UDF的情况</p>
<p>使用示例1：下面这句sql就是借用了weekday_mapper.py对数据进行了处理.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE u_data_new (</span><br><span class="line">  movieid INT,</span><br><span class="line">  rating INT,</span><br><span class="line">  weekday INT,</span><br><span class="line">  userid INT)</span><br><span class="line">ROW FORMAT DELIMITED</span><br><span class="line">FIELDS TERMINATED BY &#39;\t&#39;;</span><br><span class="line">add FILE weekday_mapper.py;</span><br><span class="line">INSERT OVERWRITE TABLE u_data_new</span><br><span class="line">SELECT</span><br><span class="line">  TRANSFORM (movieid, rating, unixtime,userid)</span><br><span class="line">  USING &#39;python weekday_mapper.py&#39;</span><br><span class="line">  AS (movieid, rating, weekday,userid)</span><br><span class="line">FROM u_data;</span><br></pre></td></tr></table></figure>
<p>其中weekday_mapper.py内容如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;python</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">import datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for line in sys.stdin:</span><br><span class="line">  line &#x3D; line.strip()</span><br><span class="line">  movieid, rating, unixtime,userid &#x3D; line.split(&#39;\t&#39;)</span><br><span class="line">  weekday &#x3D; datetime.datetime.fromtimestamp(float(unixtime)).isoweekday()</span><br><span class="line">  print &#39;\t&#39;.join([movieid, rating, str(weekday),userid])</span><br></pre></td></tr></table></figure>
<p>使用示例2：下面的例子则是使用了shell的cat命令来处理数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM invites a INSERT OVERWRITE TABLE events SELECT TRANSFORM(a.foo, a.bar) AS (oof, rab) USING &#39;&#x2F;bin&#x2F;cat&#39; WHERE a.ds &gt; &#39;2008-08-08&#39;;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.jianshu.com/p/6383611b308d" target="_blank" rel="noopener">https://www.jianshu.com/p/6383611b308d</a></p>

                
                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2021/03/30/lepeng-Nginx-Linux-Centos7-安装-Nginx/" data-toggle="tooltip" data-placement="top" title="Linux Centos7 安装 Nginx">&larr; Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2021/03/29/lepeng-java-day08-常用API/" data-toggle="tooltip" data-placement="top" title="day08-常用API">Next Post &rarr;</a>
                    </li>
                    
                </ul>

                <!-- tip start -->
                

                
                <div class="comment_notes">
                    <p>
                        study well and make progress every day; study well and progress every day; study hard and make progress every day.
                    </p>
                </div>
                
                <!-- tip end -->

                <!-- Music start-->
                
                <!-- Music end -->

                <!-- Sharing -->
                
                <div class="social-share"  data-wechat-qrcode-helper="" align="center"></div>
                <!--  css & js -->
                <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">
                <script src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>
                
                <!-- Sharing -->

                <!-- gitment start -->
                
                <!-- gitment end -->

                <!-- 来必力City版安装代码 -->
                
                <!-- City版安装代码已完成 -->

                <!-- disqus comment start -->
                
                <!-- disqus comment end -->
            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

    
      
        <aside id="sidebar">
          <div id="toc" class="toc-article">
          <strong class="toc-title">Contents</strong>
          
            
              <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#1-Hive简介"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">1 Hive简介</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#1-1-Hive简介"><span class="toc-nav-number">1.1.</span> <span class="toc-nav-text">1.1 Hive简介</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-1-1-什么是Hive"><span class="toc-nav-number">1.1.1.</span> <span class="toc-nav-text">1.1.1 什么是Hive</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-1-2-为什么使用Hive"><span class="toc-nav-number">1.1.2.</span> <span class="toc-nav-text">1.1.2 为什么使用Hive</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-1-3-Hive的特点"><span class="toc-nav-number">1.1.3.</span> <span class="toc-nav-text">1.1.3 Hive的特点</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-1-4-Hive擅长什么"><span class="toc-nav-number">1.1.4.</span> <span class="toc-nav-text">1.1.4 Hive擅长什么</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#1-2-Hive架构"><span class="toc-nav-number">1.2.</span> <span class="toc-nav-text">1.2 Hive架构</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-2-1-架构图"><span class="toc-nav-number">1.2.1.</span> <span class="toc-nav-text">1.2.1 架构图</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-2-2-基本组成"><span class="toc-nav-number">1.2.2.</span> <span class="toc-nav-text">1.2.2 基本组成</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-2-3-Metastore组件"><span class="toc-nav-number">1.2.3.</span> <span class="toc-nav-text">1.2.3 Metastore组件:</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-2-4-Hive的执行流程"><span class="toc-nav-number">1.2.4.</span> <span class="toc-nav-text">1.2.4 Hive的执行流程</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#1-3-Hive与Hadoop的关系"><span class="toc-nav-number">1.3.</span> <span class="toc-nav-text">1.3 Hive与Hadoop的关系</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#1-4-Hive与传统数据库对比"><span class="toc-nav-number">1.4.</span> <span class="toc-nav-text">1.4 Hive与传统数据库对比</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#1-5-Hive的数据存储"><span class="toc-nav-number">1.5.</span> <span class="toc-nav-text">1.5 Hive的数据存储</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#1-6-HIVE的安装部署"><span class="toc-nav-number">1.6.</span> <span class="toc-nav-text">1.6 HIVE的安装部署</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-6-1-安装"><span class="toc-nav-number">1.6.1.</span> <span class="toc-nav-text">1.6.1 安装</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-6-2-使用方式"><span class="toc-nav-number">1.6.2.</span> <span class="toc-nav-text">1.6.2 使用方式</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Hive交互shell"><span class="toc-nav-number">1.6.2.1.</span> <span class="toc-nav-text">Hive交互shell</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Hive-thrift服务"><span class="toc-nav-number">1.6.2.2.</span> <span class="toc-nav-text">Hive thrift服务</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Hive命令"><span class="toc-nav-number">1.6.2.3.</span> <span class="toc-nav-text">Hive命令</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#1-7-Hive的shell"><span class="toc-nav-number">1.7.</span> <span class="toc-nav-text">1.7  Hive的shell</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#1-8-HIVE和HBASE区别"><span class="toc-nav-number">1.8.</span> <span class="toc-nav-text">1.8  HIVE和HBASE区别</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#2-Hive-基本操作"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">2 Hive 基本操作</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-1-Hive-数据类型"><span class="toc-nav-number">2.1.</span> <span class="toc-nav-text">2.1 Hive 数据类型</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-1-1-原始数据类型"><span class="toc-nav-number">2.1.1.</span> <span class="toc-nav-text">2.1.1 原始数据类型</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-1-2-复合数据类型"><span class="toc-nav-number">2.1.2.</span> <span class="toc-nav-text">2.1.2 复合数据类型</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-1-Hive-交互式模式"><span class="toc-nav-number">2.2.</span> <span class="toc-nav-text">2.1 Hive 交互式模式</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-1-DDL操作"><span class="toc-nav-number">2.3.</span> <span class="toc-nav-text">2.1 DDL操作</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-1-1-创建表"><span class="toc-nav-number">2.3.1.</span> <span class="toc-nav-text">2.1.1 创建表</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#建表语法"><span class="toc-nav-number">2.3.1.1.</span> <span class="toc-nav-text">建表语法</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#具体实例"><span class="toc-nav-number">2.3.1.2.</span> <span class="toc-nav-text">具体实例</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-1-2-修改表"><span class="toc-nav-number">2.3.2.</span> <span class="toc-nav-text">2.1.2 修改表</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#增加-删除分区"><span class="toc-nav-number">2.3.2.1.</span> <span class="toc-nav-text">增加&#x2F;删除分区</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#语法"><span class="toc-nav-number">2.3.2.1.1.</span> <span class="toc-nav-text">语法</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#重命名表"><span class="toc-nav-number">2.3.2.2.</span> <span class="toc-nav-text">重命名表</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#语法结构"><span class="toc-nav-number">2.3.2.2.1.</span> <span class="toc-nav-text">语法结构</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#具体实例-1"><span class="toc-nav-number">2.3.2.2.2.</span> <span class="toc-nav-text">具体实例</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#增加-更新列"><span class="toc-nav-number">2.3.2.3.</span> <span class="toc-nav-text">增加&#x2F;更新列</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#语法结构-1"><span class="toc-nav-number">2.3.2.3.1.</span> <span class="toc-nav-text">语法结构</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#具体实例-2"><span class="toc-nav-number">2.3.2.3.2.</span> <span class="toc-nav-text">具体实例</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-1-3-删除表"><span class="toc-nav-number">2.3.3.</span> <span class="toc-nav-text">2.1.3 删除表</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-1-4-数据库相关"><span class="toc-nav-number">2.3.4.</span> <span class="toc-nav-text">2.1.4 数据库相关</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-1-4-显示命令"><span class="toc-nav-number">2.3.5.</span> <span class="toc-nav-text">2.1.4 显示命令</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-2-DML操作"><span class="toc-nav-number">2.4.</span> <span class="toc-nav-text">2.2 DML操作</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-2-1-加载"><span class="toc-nav-number">2.4.1.</span> <span class="toc-nav-text">2.2.1 加载</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-2-2-Insert"><span class="toc-nav-number">2.4.2.</span> <span class="toc-nav-text">2.2.2 Insert</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-2-3-SELECT"><span class="toc-nav-number">2.4.3.</span> <span class="toc-nav-text">2.2.3 SELECT</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-3-Hive-Join"><span class="toc-nav-number">2.5.</span> <span class="toc-nav-text">2.3 Hive Join</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#3-Hive-Shell参数"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">3 Hive Shell参数</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-1-Hive命令行"><span class="toc-nav-number">3.1.</span> <span class="toc-nav-text">3.1 Hive命令行</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-2-Hive参数配置方式"><span class="toc-nav-number">3.2.</span> <span class="toc-nav-text">3.2 Hive参数配置方式</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#4-Hive函数"><span class="toc-nav-number">4.</span> <span class="toc-nav-text">4 Hive函数</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#4-1-内置运算符"><span class="toc-nav-number">4.1.</span> <span class="toc-nav-text">4.1 内置运算符</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#4-2-内置函数"><span class="toc-nav-number">4.2.</span> <span class="toc-nav-text">4.2 内置函数</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#4-3-Hive自定义函数和Transform"><span class="toc-nav-number">4.3.</span> <span class="toc-nav-text">4.3 Hive自定义函数和Transform</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-3-1-自定义函数类别"><span class="toc-nav-number">4.3.1.</span> <span class="toc-nav-text">4.3.1 自定义函数类别</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-3-2-UDF开发实例"><span class="toc-nav-number">4.3.2.</span> <span class="toc-nav-text">4.3.2 UDF开发实例</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-3-3-Transform实现"><span class="toc-nav-number">4.3.3.</span> <span class="toc-nav-text">4.3.3 Transform实现</span></a></li></ol></li></ol></li></ol>
            
          
          </div>
        </aside>
      
    

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#Hive" title="Hive">Hive</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                        <li><a href="https://blog.csdn.net/fenglepeng" target="_blank">Feng Lepeng&#39;s CSDN</a></li>
                    
                </ul>
                
            </div>
        </div>
    </div>
</article>




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: 'ℬ'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>


<style  type="text/css">
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">

                

                

                

                

                

                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy;  京ICP备18055501号-2; Feng Lepeng 2021
                    <br>
                    Powered by 
                    <a href="https://github.com/dusign/hexo-theme-snail" target="_blank" rel="noopener">
                        <i>hexo-theme-snail</i>
                    </a> | 
                    <iframe name="star" style="margin-left: 2px; margin-bottom:-5px;" frameborder="0" scrolling="0"
                        width="100px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=flepeng&repo=hexo-theme-lp&type=star">
                    </iframe>
                </p>
            </div>
        </div>
    </div>

</footer>

<!-- jQuery -->

<script src="/js/jquery.min.js"></script>


<!-- Bootstrap Core JavaScript -->

<script src="/js/bootstrap.min.js"></script>


<!-- Custom Theme JavaScript -->

<script src="/js/hux-blog.min.js"></script>


<!-- Search -->

<script src="/js/search.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://flepeng.github.io/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-XXXXXXXX-X';
    var _gaDomain = 'yoursite';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>




<!-- Baidu Tongji -->


<!-- Search -->

    <script type="text/javascript">      
        var search_path = "search.xml";
        if (search_path.length == 0) {
            search_path = "search.xml";
        }
    var path = "/" + search_path;
    searchFunc(path, 'local-search-input', 'local-search-result');
    </script>


<!-- busuanzi -->
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>

    
        <!-- background effects line -->
        

        
            <script type="text/javascript" src="/js/mouse-click.js" content='[&#34;🌱&#34;,&#34;just do it&#34;,&#34;🍀&#34;]' color='[&#34;rgb(121,93,179)&#34; ,&#34;rgb(76,180,231)&#34; ,&#34;rgb(184,90,154)&#34;]'></script>
        

        <!-- background effects end -->
    

    <!--<script size="50" alpha='0.3' zIndex="-999" src="/js/ribbonStatic.js"></script>-->
    
        <script src="/js/ribbonDynamic.js"></script>
    
</body>

</html>
