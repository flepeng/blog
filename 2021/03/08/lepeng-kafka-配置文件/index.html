<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <script data-ad-client="ca-pub-2488174175014870" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script> <!-- google ad -->
    <meta name="google-site-verification" content="40lMg4eqLLbXoDcpN3h-cEnfmselbQ8tUzNvuC0IRIs" /><!-- google 站点认证 -->
    <meta name="baidu-site-verification" content="093lY4ziMu" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="description" content="A hexo theme">
    <meta name="keyword"  content="hexo, hexo-theme-lp">
    <link rel="shortcut icon" href="/img/ironman-draw.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <!--<link href='http://fonts.googleapis.com/css?family=Montserrat:400,700' rel='stylesheet' type='text/css'>-->
    <title>
        
          kafka 配置文件 - Hexo-theme-lp
        
    </title>

    <link rel="canonical" href="https://flepeng.github.io/2021/03/08/lepeng-kafka-配置文件/">

    <!-- Bootstrap Core CSS -->
    
<link rel="stylesheet" href="/css/bootstrap.min.css">


    <!-- Custom CSS --> 
    
        
<link rel="stylesheet" href="/css/dusign-light.css">

        
<link rel="stylesheet" href="/css/dusign-common-light.css">

        
<link rel="stylesheet" href="/css/font-awesome.css">

        
<link rel="stylesheet" href="/css/toc.css">

        <!-- background effects end -->
    
    
    <!-- Pygments Highlight CSS -->
    
<link rel="stylesheet" href="/css/highlight.css">


    
<link rel="stylesheet" href="/css/widget.css">


    
<link rel="stylesheet" href="/css/rocket.css">


    
<link rel="stylesheet" href="/css/signature.css">


    
<link rel="stylesheet" href="/css/fonts.googleapis.css">


    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">

    <!-- photography -->
    
<link rel="stylesheet" href="/css/photography.css">


    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- background effects start -->
    
    <!-- background effects end -->

	<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            
                background-image: linear-gradient(rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.3)), url('/img/header_img/archive-bg.jpg')
                /*post*/
            
        
    }
    
    #signature{
        background-image: url('/img/signature/dusign.png');
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#kafka" title="kafka">kafka</a>
                            
                        </div>
                        <h1>kafka 配置文件</h1>
                        <h2 class="subheading"></h2>
                        <span class="meta">
                            Posted by Lepeng on
                            2021-03-08
                        </span>

                        
                            <div class="blank_box"></div>
                            <span class="meta">
                                Words <span class="post-count">3.7k</span> and
                                Reading Time <span class="post-count">13</span> Minutes
                            </span>
                            <div class="blank_box"></div>
                            <!-- 不蒜子统计 start -->
                            <span class="meta">
                                Viewed <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span> Times
                            </span>
                            <!-- 不蒜子统计 end -->
                        

                    </div>
                

                </div>
            </div>
        </div>      
    </div>

    
    <div class="waveWrapper">
        <div class="wave wave_before" style="background-image: url('/img/wave-light.png')"></div>
        <div class="wave wave_after" style="background-image: url('/img/wave-light.png')"></div>
    </div>
    
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Lepeng</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archive/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/categories/">Categories</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                    
                    <li>
                        <a href="http://flepeng.com" target="_blank">chinese_blog</a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h2 id="在kafka-config-目录下面有3个配置文件"><a href="#在kafka-config-目录下面有3个配置文件" class="headerlink" title="在kafka/config/目录下面有3个配置文件"></a>在kafka/config/目录下面有3个配置文件</h2><ul>
<li>producer.properties:生产端的配置文件</li>
<li>consumer.properties:消费端的配置文件</li>
<li>server.properties:服务端的配置文件</li>
</ul>
<h2 id="server-properties-服务端的配置文件"><a href="#server-properties-服务端的配置文件" class="headerlink" title="server.properties:服务端的配置文件"></a>server.properties:服务端的配置文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">############################# Server Basics #############################</span></span><br><span class="line"><span class="comment">#broker的全局唯一编号，不能重复</span></span><br><span class="line">broker.id=0</span><br><span class="line"> </span><br><span class="line"><span class="comment">############################# Socket Server Settings #############################</span></span><br><span class="line"><span class="comment">#用来监听链接的端口，producer或consumer将在此端口建立连接</span></span><br><span class="line">port=9092</span><br><span class="line"> </span><br><span class="line"><span class="comment">#处理网络请求的线程数量，也就是接收消息的线程数。</span></span><br><span class="line"><span class="comment">#接收线程会将接收到的消息放到内存中，然后再从内存中写入磁盘。</span></span><br><span class="line">num.network.threads=3</span><br><span class="line"> </span><br><span class="line"><span class="comment">#消息从内存中写入磁盘是时候使用的线程数量。</span></span><br><span class="line"><span class="comment">#用来处理磁盘IO的线程数量</span></span><br><span class="line">num.io.threads=8</span><br><span class="line"> </span><br><span class="line"><span class="comment">#发送套接字的缓冲区大小</span></span><br><span class="line">socket.send.buffer.bytes=102400</span><br><span class="line"> </span><br><span class="line"><span class="comment">#接受套接字的缓冲区大小</span></span><br><span class="line">socket.receive.buffer.bytes=102400</span><br><span class="line"> </span><br><span class="line"><span class="comment">#请求套接字的缓冲区大小</span></span><br><span class="line">socket.request.max.bytes=104857600</span><br><span class="line"> </span><br><span class="line"><span class="comment">############################# Log Basics #############################</span></span><br><span class="line"><span class="comment">#kafka运行日志存放的路径</span></span><br><span class="line">log.dirs=/<span class="built_in">export</span>/servers/logs/kafka</span><br><span class="line"> </span><br><span class="line"><span class="comment">#每个topic默认partitions的数量，数量较大表示消费者可以有更大的并行度。</span></span><br><span class="line">num.partitions=2</span><br><span class="line"> </span><br><span class="line"><span class="comment">#我们知道segment文件默认会被保留7天的时间，超时的话就会被清理，那么清理这件事情就需要有一些线程来做。</span></span><br><span class="line"><span class="comment">#这里就是用来设置恢复和清理data下数据的线程数量</span></span><br><span class="line">num.recovery.threads.per.data.dir=1</span><br><span class="line"> </span><br><span class="line"><span class="comment">############################# Log Retention Policy #############################</span></span><br><span class="line"><span class="comment">#segment文件保留的最长时间，默认保留7天（168小时），</span></span><br><span class="line"><span class="comment">#超时将被删除，也就是说7天之前的数据将被清理掉。</span></span><br><span class="line">log.retention.hours=168</span><br><span class="line"> </span><br><span class="line"><span class="comment">#滚动生成新的segment文件的最大时间</span></span><br><span class="line">log.roll.hours=168</span><br><span class="line"> </span><br><span class="line"><span class="comment">#日志文件中每个segment的大小，默认为1G</span></span><br><span class="line">log.segment.bytes=1073741824</span><br><span class="line"> </span><br><span class="line"><span class="comment">#上面的参数设置了每一个segment文件的大小是1G，那么就需要有一个东西去定期检查segment文件有没有达到1G，</span></span><br><span class="line"><span class="comment">#多长时间去检查一次，就需要设置一个周期性检查文件大小的时间（单位是毫秒）。</span></span><br><span class="line">log.retention.check.interval.ms=300000</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Kafka Broker 的日志清理功能在配置 log.cleaner.enable=true 后会开启一些清理线程，执行定时清理任务。</span></span><br><span class="line"><span class="comment"># 在kafka 0.9.0之后 log.cleaner.enable 默认是true。支持的清理策略（log.cleanup.policy）有2种：delete和compact，默认是delete</span></span><br><span class="line"><span class="comment">#日志清理是否打开</span></span><br><span class="line">log.cleaner.enable=<span class="literal">true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#日志清理策略选择有：delete和compact主要针对过期数据的处理，或是日志文件达到限制的额度，会被 topic创建时的指定参数覆盖</span></span><br><span class="line">log.cleanup.policy=delete</span><br><span class="line"> </span><br><span class="line"><span class="comment">############################# Zookeeper #############################</span></span><br><span class="line"><span class="comment">#broker需要使用zookeeper保存meta数据</span></span><br><span class="line">zookeeper.connect=zk01:2181,zk02:2181,zk03:2181</span><br><span class="line"> </span><br><span class="line"><span class="comment">#zookeeper链接超时时间</span></span><br><span class="line">zookeeper.connection.timeout.ms=6000</span><br><span class="line"> </span><br><span class="line"><span class="comment">#上面我们说过接收线程会将接收到的消息放到内存中，然后再从内存</span></span><br><span class="line"><span class="comment">#写到磁盘上，那么什么时候将消息从内存中写入磁盘，就有一个</span></span><br><span class="line"><span class="comment">#时间限制（时间阈值）和一个数量限制（数量阈值），这里设置的是</span></span><br><span class="line"><span class="comment">#数量阈值，下一个参数设置的则是时间阈值。</span></span><br><span class="line"><span class="comment">#partion buffer中，消息的条数达到阈值，将触发flush到磁盘。</span></span><br><span class="line">log.flush.interval.messages=10000</span><br><span class="line"> </span><br><span class="line"><span class="comment">#消息buffer的时间，达到阈值，将触发将消息从内存flush到磁盘，</span></span><br><span class="line"><span class="comment">#单位是毫秒。</span></span><br><span class="line">log.flush.interval.ms=3000</span><br><span class="line"> </span><br><span class="line"><span class="comment">#删除topic需要server.properties中设置delete.topic.enable=true否则只是标记删除</span></span><br><span class="line">delete.topic.enable=<span class="literal">true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#此处的host.name为本机IP(重要),如果不改,则客户端会抛出:</span></span><br><span class="line"><span class="comment">#Producer connection to localhost:9092 unsuccessful 错误!</span></span><br><span class="line">host.name=kafka01</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 广播地址，主要用于我们外网连接kafka集群，一般用不到这个配置</span></span><br><span class="line">advertised.host.name=192.168.239.128</span><br></pre></td></tr></table></figure>
<h3 id="数据删除"><a href="#数据删除" class="headerlink" title="数据删除"></a>数据删除</h3><p>kafka将topic分成不同的partitions，每个partition的日志分成不同的segments，最后以segment为单位将陈旧的日志从文件系统删除。</p>
<p>假设kafka的在<strong>server.properity</strong>文件中设置的日志目录为tmp/kafka-logs，对于名为test_perf的topic。假设两个partitions,那么我们可以在tmp/kafka-logs目录下看到目录VST_TOPIC-0，VST_TOPIC-1。也就是说kafka使用目录表示topic 分区。</p>
<p>VST_TOPIC-0目录下下，可以看到后缀名为.log和.index的文件，如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@kafka kafka-logs]# ls test_perf-0&#x2F;</span><br><span class="line">00000000000003417135.index.deleted 00000000000003518540.index 00000000000003619945.index</span><br><span class="line">00000000000003417135.log.deleted 00000000000003518540.log 00000000000003619945.log</span><br></pre></td></tr></table></figure>
<p>如果所有待删除的陈旧日志都清理了，那么是看不到后缀名为.deleted的文件的。</p>
<h2 id="0x01-基于时间的删除策略"><a href="#0x01-基于时间的删除策略" class="headerlink" title="0x01 基于时间的删除策略"></a>0x01 基于时间的删除策略</h2><p>在<strong>server.properity</strong>文件中设置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">log.retention.hours&#x3D;168 &#x2F;&#x2F;7d</span><br><span class="line">log.retention.check.interval.ms&#x3D;300000 &#x2F;&#x2F;5min</span><br><span class="line">log.segment.bytes&#x3D;1073741824 &#x2F;&#x2F;1G</span><br><span class="line">log.cleaner.delete.retention.ms&#x3D;86400000 &#x2F;&#x2F; 1d</span><br><span class="line">log.cleaner.backoff.ms&#x3D;15000 &#x2F;&#x2F;15s</span><br></pre></td></tr></table></figure>
<p>每个segment的大小为1GB,每5分钟检查一次是否有segment已经查过了7d,如果有将其标记为deleted。标记为deleted的segment默认会保留1天，清理线程会每隔15秒检查一次，是否有标记为deleted的segment的保留时间超过一天了，如果有将其从文件系统删除。</p>
<p>大家注意，kafka清理时是不管该segment中的消息是否被消费过，它清理的依据为是否超过了指定的保留时间，仅此而已。</p>
<h2 id="0x02-基于文件大小的删除策略"><a href="#0x02-基于文件大小的删除策略" class="headerlink" title="0x02 基于文件大小的删除策略"></a>0x02 基于文件大小的删除策略</h2><p>在<strong>server.properity</strong>文件中设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.retention.bytes # 默认没有指定。</span><br></pre></td></tr></table></figure><br>你可以同时指定log.retention.bytes和log.retention.hours来混合指定保留规则。一旦日志的大小超过了log.retention.bytes就清除老的segment，一旦某个segment的保留时间超过了规定的值同样将其清除。</p>
<p>log.retention.bytes和log.retention.hours任意一个达到要求，都会执行删除，会被topic创建时的指定参数覆盖。</p>
<p>在kafka 0.9.0之后 log.cleaner.enable 默认是true。支持的清理策略（log.cleanup.policy）有2种：delete和compact，默认是delete。</p>
<h2 id="producer-properties-生产端的配置文件"><a href="#producer-properties-生产端的配置文件" class="headerlink" title="producer.properties:生产端的配置文件"></a>producer.properties:生产端的配置文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#指定kafka节点列表，用于获取metadata，不必全部指定</span></span><br><span class="line"><span class="comment">#需要kafka的服务器地址，来获取每一个topic的分片数等元数据信息。</span></span><br><span class="line">metadata.broker.list=kafka01:9092,kafka02:9092,kafka03:9092</span><br><span class="line"> </span><br><span class="line"><span class="comment">#生产者生产的消息被发送到哪个block，需要一个分组策略。</span></span><br><span class="line"><span class="comment">#指定分区处理类。默认kafka.producer.DefaultPartitioner，表通过key哈希到对应分区</span></span><br><span class="line"><span class="comment">#partitioner.class=kafka.producer.DefaultPartitioner</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#生产者生产的消息可以通过一定的压缩策略（或者说压缩算法）来压缩。消息被压缩后发送到broker集群，</span></span><br><span class="line"><span class="comment">#而broker集群是不会进行解压缩的，broker集群只会把消息发送到消费者集群，然后由消费者来解压缩。</span></span><br><span class="line"><span class="comment">#是否压缩，默认0表示不压缩，1表示用gzip压缩，2表示用snappy压缩。</span></span><br><span class="line"><span class="comment">#压缩后消息中会有头来指明消息压缩类型，故在消费者端消息解压是透明的无需指定。</span></span><br><span class="line"><span class="comment">#文本数据会以1比10或者更高的压缩比进行压缩。</span></span><br><span class="line">compression.codec=none</span><br><span class="line"> </span><br><span class="line"><span class="comment">#指定序列化处理类，消息在网络上传输就需要序列化，它有String、数组等许多种实现。</span></span><br><span class="line">serializer.class=kafka.serializer.DefaultEncoder</span><br><span class="line"> </span><br><span class="line"><span class="comment">#如果要压缩消息，这里指定哪些topic要压缩消息，默认empty，表示不压缩。</span></span><br><span class="line"><span class="comment">#如果上面启用了压缩，那么这里就需要设置</span></span><br><span class="line"><span class="comment">#compressed.topics= </span></span><br><span class="line"><span class="comment">#这是消息的确认机制，默认值是0。在面试中常被问到。</span></span><br><span class="line"><span class="comment">#producer有个ack参数，有三个值，分别代表：</span></span><br><span class="line"><span class="comment">#（1）不在乎是否写入成功；</span></span><br><span class="line"><span class="comment">#（2）写入leader成功；</span></span><br><span class="line"><span class="comment">#（3）写入leader和所有副本都成功；</span></span><br><span class="line"><span class="comment">#要求非常可靠的话可以牺牲性能设置成最后一种。</span></span><br><span class="line"><span class="comment">#为了保证消息不丢失，至少要设置为1，也就</span></span><br><span class="line"><span class="comment">#是说至少保证leader将消息保存成功。</span></span><br><span class="line"><span class="comment">#设置发送数据是否需要服务端的反馈,有三个值0,1,-1，分别代表3种状态：</span></span><br><span class="line"><span class="comment">#0: producer不会等待broker发送ack。生产者只要把消息发送给broker之后，就认为发送成功了，这是第1种情况；</span></span><br><span class="line"><span class="comment">#1: 当leader接收到消息之后发送ack。生产者把消息发送到broker之后，并且消息被写入到本地文件，才认为发送成功，这是第二种情况；#-1: 当所有的follower都同步消息成功后发送ack。不仅是主的分区将消息保存成功了，</span></span><br><span class="line"><span class="comment">#而且其所有的分区的副本数也都同步好了，才会被认为发动成功，这是第3种情况。</span></span><br><span class="line">request.required.acks=0</span><br><span class="line"> </span><br><span class="line"><span class="comment">#broker必须在该时间范围之内给出反馈，否则失败。</span></span><br><span class="line"><span class="comment">#在向producer发送ack之前,broker允许等待的最大时间 ，如果超时,</span></span><br><span class="line"><span class="comment">#broker将会向producer发送一个error ACK.意味着上一次消息因为某种原因</span></span><br><span class="line"><span class="comment">#未能成功(比如follower未能同步成功)</span></span><br><span class="line">request.timeout.ms=10000</span><br><span class="line"> </span><br><span class="line"><span class="comment">#生产者将消息发送到broker，有两种方式，一种是同步，表示生产者发送一条，broker就接收一条；</span></span><br><span class="line"><span class="comment">#还有一种是异步，表示生产者积累到一批的消息，装到一个池子里面缓存起来，再发送给broker，</span></span><br><span class="line"><span class="comment">#这个池子不会无限缓存消息，在下面，它分别有一个时间限制（时间阈值）和一个数量限制（数量阈值）的参数供我们来设置。</span></span><br><span class="line"><span class="comment">#一般我们会选择异步。</span></span><br><span class="line"><span class="comment">#同步还是异步发送消息，默认“sync”表同步，"async"表异步。异步可以提高发送吞吐量,</span></span><br><span class="line"><span class="comment">#也意味着消息将会在本地buffer中,并适时批量发送，但是也可能导致丢失未发送过去的消息</span></span><br><span class="line">producer.type=sync</span><br><span class="line"> </span><br><span class="line"><span class="comment">#在async模式下,当message被缓存的时间超过此值后,将会批量发送给broker,</span></span><br><span class="line"><span class="comment">#默认为5000ms</span></span><br><span class="line"><span class="comment">#此值和batch.num.messages协同工作.</span></span><br><span class="line">queue.buffering.max.ms = 5000</span><br><span class="line"> </span><br><span class="line"><span class="comment">#异步情况下，缓存中允许存放消息数量的大小。</span></span><br><span class="line"><span class="comment">#在async模式下,producer端允许buffer的最大消息量</span></span><br><span class="line"><span class="comment">#无论如何,producer都无法尽快的将消息发送给broker,从而导致消息在producer端大量沉积</span></span><br><span class="line"><span class="comment">#此时,如果消息的条数达到阀值,将会导致producer端阻塞或者消息被抛弃，默认为10000条消息。</span></span><br><span class="line">queue.buffering.max.messages=20000</span><br><span class="line"> </span><br><span class="line"><span class="comment">#如果是异步，指定每次批量发送数据量，默认为200</span></span><br><span class="line">batch.num.messages=500</span><br><span class="line"> </span><br><span class="line"><span class="comment">#在生产端的缓冲池中，消息发送出去之后，在没有收到确认之前，该缓冲池中的消息是不能被删除的，</span></span><br><span class="line"><span class="comment">#但是生产者一直在生产消息，这个时候缓冲池可能会被撑爆，所以这就需要有一个处理的策略。</span></span><br><span class="line"><span class="comment">#有两种处理方式，一种是让生产者先别生产那么快，阻塞一下，等会再生产；另一种是将缓冲池中的消息清空。</span></span><br><span class="line"><span class="comment">#当消息在producer端沉积的条数达到"queue.buffering.max.meesages"后阻塞一定时间后,</span></span><br><span class="line"><span class="comment">#队列仍然没有enqueue(producer仍然没有发送出任何消息)</span></span><br><span class="line"><span class="comment">#此时producer可以继续阻塞或者将消息抛弃,此timeout值用于控制"阻塞"的时间</span></span><br><span class="line"><span class="comment">#-1: 不限制阻塞超时时间，让produce一直阻塞,这个时候消息就不会被抛弃</span></span><br><span class="line"><span class="comment">#0: 立即清空队列,消息被抛弃</span></span><br><span class="line">queue.enqueue.timeout.ms=-1</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">#当producer接收到error ACK,或者没有接收到ACK时,允许消息重发的次数</span></span><br><span class="line"><span class="comment">#因为broker并没有完整的机制来避免消息重复,所以当网络异常时(比如ACK丢失)</span></span><br><span class="line"><span class="comment">#有可能导致broker接收到重复的消息,默认值为3.</span></span><br><span class="line">message.send.max.retries=3</span><br><span class="line"> </span><br><span class="line"><span class="comment">#producer刷新topic metada的时间间隔,producer需要知道partition leader</span></span><br><span class="line"><span class="comment">#的位置,以及当前topic的情况</span></span><br><span class="line"><span class="comment">#因此producer需要一个机制来获取最新的metadata,当producer遇到特定错误时,</span></span><br><span class="line"><span class="comment">#将会立即刷新</span></span><br><span class="line"><span class="comment">#(比如topic失效,partition丢失,leader失效等),此外也可以通过此参数来配置</span></span><br><span class="line"><span class="comment">#额外的刷新机制，默认值600000</span></span><br><span class="line">topic.metadata.refresh.interval.ms=60000</span><br></pre></td></tr></table></figure>
<h2 id="consumer-properties-消费端的配置文件"><a href="#consumer-properties-消费端的配置文件" class="headerlink" title="consumer.properties:消费端的配置文件"></a>consumer.properties:消费端的配置文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#消费者集群通过连接Zookeeper来找到broker。</span></span><br><span class="line"><span class="comment">#zookeeper连接服务器地址</span></span><br><span class="line">zookeeper.connect=zk01:2181,zk02:2181,zk03:2181</span><br><span class="line"> </span><br><span class="line"><span class="comment">#zookeeper的session过期时间，默认5000ms，用于检测消费者是否挂掉</span></span><br><span class="line">zookeeper.session.timeout.ms=5000</span><br><span class="line"> </span><br><span class="line"><span class="comment">#当消费者挂掉，其他消费者要等该指定时间才能检查到并且触发重新负载均衡</span></span><br><span class="line">zookeeper.connection.timeout.ms=10000</span><br><span class="line"> </span><br><span class="line"><span class="comment">#这是一个时间阈值。</span></span><br><span class="line"><span class="comment">#指定多久消费者更新offset到zookeeper中。</span></span><br><span class="line"><span class="comment">#注意offset更新时基于time而不是每次获得的消息。</span></span><br><span class="line"><span class="comment">#一旦在更新zookeeper发生异常并重启，将可能拿到已拿到过的消息</span></span><br><span class="line">zookeeper.sync.time.ms=2000</span><br><span class="line"> </span><br><span class="line"><span class="comment">#指定消费</span></span><br><span class="line">group.id=xxxxx</span><br><span class="line"> </span><br><span class="line"><span class="comment">#这是一个数量阈值，经测试是500条。</span></span><br><span class="line"><span class="comment">#当consumer消费一定量的消息之后,将会自动向zookeeper提交offset信息#注意offset信息并不是每消费一次消息就向zk提交</span></span><br><span class="line"><span class="comment">#一次,而是现在本地保存(内存),并定期提交,默认为true</span></span><br><span class="line">auto.commit.enable=<span class="literal">true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 自动更新时间。默认60 * 1000</span></span><br><span class="line">auto.commit.interval.ms=1000</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 当前consumer的标识,可以设定,也可以有系统生成,</span></span><br><span class="line"><span class="comment">#主要用来跟踪消息消费情况,便于观察</span></span><br><span class="line">conusmer.id=xxx</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 消费者客户端编号，用于区分不同客户端，默认客户端程序自动产生</span></span><br><span class="line">client.id=xxxx</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 最大取多少块缓存到消费者(默认10)</span></span><br><span class="line">queued.max.message.chunks=50</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 当有新的consumer加入到group时,将会reblance,此后将会</span></span><br><span class="line"><span class="comment">#有partitions的消费端迁移到新  的consumer上,如果一个</span></span><br><span class="line"><span class="comment">#consumer获得了某个partition的消费权限,那么它将会向zk</span></span><br><span class="line"><span class="comment">#注册 "Partition Owner registry"节点信息,但是有可能</span></span><br><span class="line"><span class="comment">#此时旧的consumer尚没有释放此节点, 此值用于控制,</span></span><br><span class="line"><span class="comment">#注册节点的重试次数.</span></span><br><span class="line">rebalance.max.retries=5</span><br><span class="line"> </span><br><span class="line"><span class="comment">#每拉取一批消息的最大字节数</span></span><br><span class="line"><span class="comment">#获取消息的最大尺寸,broker不会像consumer输出大于</span></span><br><span class="line"><span class="comment">#此值的消息chunk 每次feth将得到多条消息,此值为总大小,</span></span><br><span class="line"><span class="comment">#提升此值,将会消耗更多的consumer端内存</span></span><br><span class="line">fetch.min.bytes=6553600</span><br><span class="line"> </span><br><span class="line"><span class="comment">#当消息的尺寸不足时,server阻塞的时间,如果超时,</span></span><br><span class="line"><span class="comment">#消息将立即发送给consumer</span></span><br><span class="line"><span class="comment">#数据一批一批到达，如果每一批是10条消息，如果某一批还</span></span><br><span class="line"><span class="comment">#不到10条，但是超时了，也会立即发送给consumer。</span></span><br><span class="line">fetch.wait.max.ms=5000</span><br><span class="line">socket.receive.buffer.bytes=655360</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 如果zookeeper没有offset值或offset值超出范围。</span></span><br><span class="line"><span class="comment">#那么就给个初始的offset。有smallest、largest、</span></span><br><span class="line"><span class="comment">#anything可选，分别表示给当前最小的offset、</span></span><br><span class="line"><span class="comment">#当前最大的offset、抛异常。默认largest</span></span><br><span class="line">auto.offset.reset=smallest</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 指定序列化处理类</span></span><br><span class="line">derializer.class=kafka.serializer.DefaultDecoder</span><br></pre></td></tr></table></figure>

                
                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2021/03/08/lepeng-python-flask-SQLAlchemy-使用-session-commit-处理异常回滚/" data-toggle="tooltip" data-placement="top" title="flask-SQLAlchemy 使用 session.commit() 处理异常回滚">&larr; Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2021/03/08/lepeng-前后端交互-一些关于接口设计的思考/" data-toggle="tooltip" data-placement="top" title="前后端交互-一些关于接口设计的思考">Next Post &rarr;</a>
                    </li>
                    
                </ul>

                <!-- tip start -->
                

                
                <div class="comment_notes">
                    <p>
                        study well and make progress every day; study well and progress every day; study hard and make progress every day.
                    </p>
                </div>
                
                <!-- tip end -->

                <!-- Music start-->
                
                <!-- Music end -->

                <!-- Sharing -->
                
                <div class="social-share"  data-wechat-qrcode-helper="" align="center"></div>
                <!--  css & js -->
                <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">
                <script src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>
                
                <!-- Sharing -->

                <!-- gitment start -->
                
                <!-- gitment end -->

                <!-- 来必力City版安装代码 -->
                
                <!-- City版安装代码已完成 -->

                <!-- disqus comment start -->
                
                <!-- disqus comment end -->
            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

    
      
        <aside id="sidebar">
          <div id="toc" class="toc-article">
          <strong class="toc-title">Contents</strong>
          
            
              <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#在kafka-config-目录下面有3个配置文件"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">在kafka&#x2F;config&#x2F;目录下面有3个配置文件</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#server-properties-服务端的配置文件"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">server.properties:服务端的配置文件</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#数据删除"><span class="toc-nav-number">2.1.</span> <span class="toc-nav-text">数据删除</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#0x01-基于时间的删除策略"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">0x01 基于时间的删除策略</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#0x02-基于文件大小的删除策略"><span class="toc-nav-number">4.</span> <span class="toc-nav-text">0x02 基于文件大小的删除策略</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#producer-properties-生产端的配置文件"><span class="toc-nav-number">5.</span> <span class="toc-nav-text">producer.properties:生产端的配置文件</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#consumer-properties-消费端的配置文件"><span class="toc-nav-number">6.</span> <span class="toc-nav-text">consumer.properties:消费端的配置文件</span></a></li></ol>
            
          
          </div>
        </aside>
      
    

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#kafka" title="kafka">kafka</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                        <li><a href="https://blog.csdn.net/fenglepeng" target="_blank">Feng Lepeng&#39;s CSDN</a></li>
                    
                </ul>
                
            </div>
        </div>
    </div>
</article>




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: 'ℬ'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>


<style  type="text/css">
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">

                

                

                

                

                

                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Feng Lepeng 2021 
                    <br>
                    Powered by 
                    <a href="https://github.com/dusign/hexo-theme-snail" target="_blank" rel="noopener">
                        <i>hexo-theme-snail</i>
                    </a> | 
                    <iframe name="star" style="margin-left: 2px; margin-bottom:-5px;" frameborder="0" scrolling="0"
                        width="100px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=flepeng&repo=hexo-theme-lp&type=star">
                    </iframe>
                </p>
            </div>
        </div>
    </div>

</footer>

<!-- jQuery -->

<script src="/js/jquery.min.js"></script>


<!-- Bootstrap Core JavaScript -->

<script src="/js/bootstrap.min.js"></script>


<!-- Custom Theme JavaScript -->

<script src="/js/hux-blog.min.js"></script>


<!-- Search -->

<script src="/js/search.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://flepeng.github.io/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-XXXXXXXX-X';
    var _gaDomain = 'yoursite';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>




<!-- Baidu Tongji -->


<!-- Search -->

    <script type="text/javascript">      
        var search_path = "search.xml";
        if (search_path.length == 0) {
            search_path = "search.xml";
        }
    var path = "/" + search_path;
    searchFunc(path, 'local-search-input', 'local-search-result');
    </script>


<!-- busuanzi -->
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>

    
        <!-- background effects line -->
        

        
            <script type="text/javascript" src="/js/mouse-click.js" content='[&quot;🌱&quot;,&quot;just do it&quot;,&quot;🍀&quot;]' color='[&quot;rgb(121,93,179)&quot; ,&quot;rgb(76,180,231)&quot; ,&quot;rgb(184,90,154)&quot;]'></script>
        

        <!-- background effects end -->
    

    <!--<script size="50" alpha='0.3' zIndex="-999" src="/js/ribbonStatic.js"></script>-->
    
        <script src="/js/ribbonDynamic.js"></script>
    
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<!--<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>-->
</body>

</html>
