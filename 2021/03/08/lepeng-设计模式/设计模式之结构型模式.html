<hr>
<p>title: 设计模式之结构型模式<br>subtitle:<br>author: Lepeng<br>catalog: true<br>comments: true<br>header-img: img/header_img/archive-bg.jpg<br>tags:</p>
<ul>
<li>设计模式<br>categories:</li>
<li>设计模式<br>date: 2021-03-08<br>link:</li>
<li><a href="https://www.zhihu.com/question/308850392" target="_blank" rel="noopener">https://www.zhihu.com/question/308850392</a></li>
<li><a href="https://blog.csdn.net/mw_nice/article/details/82840034" target="_blank" rel="noopener">https://blog.csdn.net/mw_nice/article/details/82840034</a></li>
</ul>
<hr>
<p><strong>结构型模式是用来设计程序的结构的</strong>。结构型模式就像搭积木，将不同的类结合在一起形成契合的结构。包括以下几种：</p>
<ul>
<li>适配器模式</li>
<li>桥接模式</li>
<li>组合模式</li>
<li>装饰模式</li>
<li>外观模式</li>
<li>享元模式</li>
<li>代理模式</li>
</ul>
<h2 id="一、适配器模式"><a href="#一、适配器模式" class="headerlink" title="一、适配器模式"></a>一、适配器模式</h2><p>说到适配器，我们最熟悉的莫过于电源适配器了，也就是手机的充电头。它就是适配器模式的一个应用。</p>
<p>试想一下，你有一条连接电脑和手机的 USB 数据线，连接电脑的一端从电脑接口处接收 5V 的电压，连接手机的一端向手机输出 5V 的电压，并且他们工作良好。</p>
<p>中国的家用电压都是 220V，所以 USB 数据线不能直接拿来给手机充电，这时候我们有两种方案：</p>
<ul>
<li>单独制作手机充电器，接收 220V 家用电压，输出 5V 电压。</li>
<li>添加一个适配器，将 220V 家庭电压转化为类似电脑接口的 5V 电压，再连接数据线给手机充电。</li>
</ul>
<p>如果你使用过早期的手机，就会知道以前的手机厂商采用的就是第一种方案：早期的手机充电器都是单独制作的，充电头和充电线是连在一起的。现在的手机都采用了电源适配器加数据线的方案。这是生活中应用适配器模式的一个进步。</p>
<blockquote>
<p>适配器模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</p>
</blockquote>
<p>适配的意思是适应、匹配。通俗地讲，适配器模式适用于 <strong>有相关性但不兼容的结构</strong>，源接口通过一个中间件转换后才可以适用于目标接口，这个转换过程就是适配，这个中间件就称之为适配器。</p>
<p>家用电源和 USB 数据线有相关性：家用电源输出电压，USB 数据线输入电压。但两个接口无法兼容，因为一个输出 220V，一个输入 5V，通过适配器将输出 220V 转换成输出 5V 之后才可以一起工作。</p>
<p>让我们用程序来模拟一下这个过程。</p>
<p>首先，家庭电源提供 220V 的电压：</p>
<p><strong>Java 实现</strong></p>
<pre><code class="lang-java">class HomeBattery {
    int supply() {
        // 家用电源提供一个 220V 的输出电压
        return 220;
    }
}
</code></pre>
<p>USB 数据线只接收 5V 的充电电压：</p>
<pre><code class="lang-java">class USBLine {
    void charge(int volt) {
        // 如果电压不是 5V，抛出异常
        if (volt != 5) throw new IllegalArgumentException(&quot;只能接收 5V 电压&quot;);
        // 如果电压是 5V，正常充电
        System.out.println(&quot;正常充电&quot;);
    }
}
</code></pre>
<p>先来看看适配之前，用户如果直接用家庭电源给手机充电：</p>
<pre><code class="lang-java">public class User {
    @Test
    public void chargeForPhone() {
        HomeBattery homeBattery = new HomeBattery();
        int homeVolt = homeBattery.supply();
        System.out.println(&quot;家庭电源提供的电压是 &quot; + homeVolt + &quot;V&quot;);

        USBLine usbLine = new USBLine();
        usbLine.charge(homeVolt);
    }
}
</code></pre>
<p>运行程序，输出如下：</p>
<pre><code class="lang-text">家庭电源提供的电压是 220V
java.lang.IllegalArgumentException: 只能接收 5V 电压
</code></pre>
<p>这时，我们加入电源适配器：</p>
<pre><code class="lang-java">class Adapter {
    int convert(int homeVolt) {
        // 适配过程：使用电阻、电容等器件将其降低为输出 5V
        int chargeVolt = homeVolt - 215;
        return chargeVolt;
    }
}
</code></pre>
<p>然后，用户再使用适配器将家庭电源提供的电压转换为充电电压：</p>
<pre><code class="lang-java">public class User {
    @Test
    public void chargeForPhone() {
        HomeBattery homeBattery = new HomeBattery();
        int homeVolt = homeBattery.supply();
        System.out.println(&quot;家庭电源提供的电压是 &quot; + homeVolt + &quot;V&quot;);

        Adapter adapter = new Adapter();
        int chargeVolt = adapter.convert(homeVolt);
        System.out.println(&quot;使用适配器将家庭电压转换成了 &quot; + chargeVolt + &quot;V&quot;);

        USBLine usbLine = new USBLine();
        usbLine.charge(chargeVolt);
    }
}
</code></pre>
<p>运行程序，输出如下：</p>
<pre><code class="lang-text">家庭电源提供的电压是 220V
使用适配器将家庭电压转换成了 5V
正常充电
</code></pre>
<p>这就是适配器模式。在我们日常的开发中经常会使用到各种各样的 Adapter，都属于适配器模式的应用。</p>
<p>但适配器模式并不推荐多用。因为未雨绸缪好过亡羊补牢，如果事先能预防接口不同的问题，不匹配问题就不会发生，只有遇到源接口无法改变时，才应该考虑使用适配器。比如现代的电源插口中很多已经增加了专门的充电接口，让我们不需要再使用适配器转换接口，这又是社会的一个进步。</p>
<h2 id="二、桥接模式"><a href="#二、桥接模式" class="headerlink" title="二、桥接模式"></a>二、桥接模式</h2><p>考虑这样一个需求：绘制矩形、圆形、三角形这三种图案。按照面向对象的理念，我们至少需要三个具体类，对应三种不同的图形。</p>
<p>抽象接口 IShape：</p>
<pre><code class="lang-java">public interface IShape {
    void draw();
}
</code></pre>
<p>三个具体形状类：</p>
<pre><code class="lang-java">class Rectangle implements IShape {
    @Override
    public void draw() {
        System.out.println(&quot;绘制矩形&quot;);
    }
}
</code></pre>
<pre><code class="lang-java">class Round implements IShape {
    @Override
    public void draw() {
        System.out.println(&quot;绘制圆形&quot;);
    }
}
</code></pre>
<pre><code class="lang-java">class Triangle implements IShape {
    @Override
    public void draw() {
        System.out.println(&quot;绘制三角形&quot;);
    }
}
</code></pre>
<p>接下来我们有了新的需求，每种形状都需要有四种不同的颜色：红、蓝、黄、绿。</p>
<p>这时我们很容易想到两种设计方案：</p>
<ul>
<li>为了复用形状类，将每种形状定义为父类，每种不同颜色的图形继承自其形状父类。此时一共有 12 个类。</li>
<li>为了复用颜色类，将每种颜色定义为父类，每种不同颜色的图形继承自其颜色父类。此时一共有 12 个类。</li>
</ul>
<p>乍一看没什么问题，我们使用了面向对象的继承特性，复用了父类的代码并扩展了新的功能。</p>
<p>但仔细想一想，如果以后要增加一种颜色，比如黑色，那么我们就需要增加三个类；如果再要增加一种形状，我们又需要增加五个类，对应 5 种颜色。</p>
<p>更不用说遇到增加 20 个形状，20 种颜色的需求，不同的排列组合将会使工作量变得无比的庞大。看来我们不得不重新思考设计方案。</p>
<p>形状和颜色，都是图形的两个属性。他们两者的关系是平等的，所以不属于继承关系。更好的的实现方式是：<strong>将形状和颜色分离，根据需要对形状和颜色进行组合</strong>，这就是桥接模式的思想。</p>
<blockquote>
<p>桥接模式：将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体模式或接口模式。</p>
</blockquote>
<p>官方定义非常精准、简练，但却有点不易理解。通俗地说，如果一个对象有两种或者多种分类方式，并且两种分类方式都容易变化，比如本例中的形状和颜色。这时使用继承很容易造成子类越来越多，所以更好的做法是把这种分类方式分离出来，让他们独立变化，使用时将不同的分类进行组合即可。</p>
<p>说到这里，不得不提一个设计原则：合成 / 聚合复用原则。虽然它没有被划分到六大设计原则中，但它在面向对象的设计中也非常的重要。</p>
<blockquote>
<p>合成 / 聚合复用原则：优先使用合成 / 聚合，而不是类继承。</p>
</blockquote>
<p>继承虽然是面向对象的三大特性之一，但继承会导致子类与父类有非常紧密的依赖关系，它会限制子类的灵活性和子类的复用性。而使用合成 / 聚合，也就是使用接口实现的方式，就不存在依赖问题，一个类可以实现多个接口，可以很方便地拓展功能。</p>
<p>让我们一起来看一下本例使用桥接模式的程序实现：</p>
<p>新建接口类 IColor，仅包含一个获取颜色的方法：</p>
<pre><code class="lang-java">public interface IColor {
    String getColor();
}
</code></pre>
<p>每种颜色都实现此接口：</p>
<pre><code class="lang-java">public class Red implements IColor {
    @Override
    public String getColor() {
        return &quot;红&quot;;
    }
}
</code></pre>
<pre><code class="lang-java">public class Blue implements IColor {
    @Override
    public String getColor() {
        return &quot;蓝&quot;;
    }
}
</code></pre>
<pre><code class="lang-java">public class Yellow implements IColor {
    @Override
    public String getColor() {
        return &quot;黄&quot;;
    }
}
</code></pre>
<pre><code class="lang-java">public class Green implements IColor {
    @Override
    public String getColor() {
        return &quot;绿&quot;;
    }
}
</code></pre>
<p>在每个形状类中，桥接 IColor 接口：</p>
<pre><code class="lang-java">class Rectangle implements IShape {

    private IColor color;

    void setColor(IColor color) {
        this.color = color;
    }

    @Override
    public void draw() {
        System.out.println(&quot;绘制&quot; + color.getColor() + &quot;矩形&quot;);
    }
}
</code></pre>
<pre><code class="lang-java">class Round implements IShape {

    private IColor color;

    void setColor(IColor color) {
        this.color = color;
    }

    @Override
    public void draw() {
        System.out.println(&quot;绘制&quot; + color.getColor() + &quot;圆形&quot;);
    }
}
</code></pre>
<pre><code class="lang-java">class Triangle implements IShape {

    private IColor color;

    void setColor(IColor color) {
        this.color = color;
    }

    @Override
    public void draw() {
        System.out.println(&quot;绘制&quot; + color.getColor() + &quot;三角形&quot;);
    }
}
</code></pre>
<p>测试函数：</p>
<pre><code class="lang-java">@Test
public void drawTest() {
    Rectangle rectangle = new Rectangle();
    rectangle.setColor(new Red());
    rectangle.draw();

    Round round = new Round();
    round.setColor(new Blue());
    round.draw();

    Triangle triangle = new Triangle();
    triangle.setColor(new Yellow());
    triangle.draw();
}
</code></pre>
<p>运行程序，输出如下：</p>
<pre><code class="lang-text">绘制红矩形
绘制蓝圆形
绘制黄三角形
</code></pre>
<p>这时我们再来回顾一下官方定义：将抽象部分与它的实现部分分离，使它们都可以独立地变化。抽象部分指的是父类，对应本例中的形状类，实现部分指的是不同子类的区别之处。将子类的区别方式 —— 也就是本例中的颜色 —— 分离成接口，通过组合的方式桥接颜色和形状，这就是桥接模式，它主要用于 <strong>两个或多个同等级的接口</strong>。</p>
<h2 id="三、组合模式"><a href="#三、组合模式" class="headerlink" title="三、组合模式"></a>三、组合模式</h2><p>上文说到，桥接模式用于将同等级的接口互相组合，那么组合模式和桥接模式有什么共同点吗？</p>
<p>事实上组合模式和桥接模式的组合完全不一样。组合模式用于 <strong>整体与部分的结构</strong>，当整体与部分有相似的结构，在操作时可以被一致对待时，就可以使用组合模式。例如：</p>
<ul>
<li>文件夹和子文件夹的关系：文件夹中可以存放文件，也可以新建文件夹，子文件夹也一样。</li>
<li>总公司子公司的关系：总公司可以设立部门，也可以设立分公司，子公司也一样。</li>
<li>树枝和分树枝的关系：树枝可以长出叶子，也可以长出树枝，分树枝也一样。</li>
</ul>
<p>在这些关系中，虽然整体包含了部分，但无论整体或部分，都具有一致的行为。</p>
<blockquote>
<p>组合模式：又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。</p>
</blockquote>
<p>考虑这样一个实际应用：设计一个公司的人员分布结构，结构如下图所示。</p>
<p><img src="https://pica.zhimg.com/v2-996bb76203be586161b57280d252c64e_r.jpg?source=1940ef5c" alt=""></p>
<p>我们注意到人员结构中有两种结构，一是管理者，如老板，PM，CFO，CTO，二是职员。其中有的管理者不仅仅要管理职员，还会管理其他的管理者。这就是一个典型的整体与部分的结构。</p>
<h3 id="3-1-不使用组合模式的设计方案"><a href="#3-1-不使用组合模式的设计方案" class="headerlink" title="3.1.不使用组合模式的设计方案"></a>3.1.不使用组合模式的设计方案</h3><p>要描述这样的结构，我们很容易想到以下设计方案：</p>
<p>新建管理者类：</p>
<pre><code class="lang-java">public class Manager {
    // 职位
    private String position;
    // 工作内容
    private String job;
    // 管理的管理者
    private List&lt;Manager&gt; managers = new ArrayList&lt;&gt;();
    // 管理的职员
    private List&lt;Employee&gt; employees = new ArrayList&lt;&gt;();

    public Manager(String position, String job) {
        this.position = position;
        this.job = job;
    }

    public void addManager(Manager manager) {
        managers.add(manager);
    }

    public void removeManager(Manager manager) {
        managers.remove(manager);
    }

    public void addEmployee(Employee employee) {
        employees.add(employee);
    }

    public void removeEmployee(Employee employee) {
        employees.remove(employee);
    }

    // 做自己的本职工作
    public void work() {
        System.out.println(&quot;我是&quot; + position + &quot;，我正在&quot; + job);
    }

    // 检查下属
    public void check() {
        work();
        for (Employee employee : employees) {
            employee.work();
        }
        for (Manager manager : managers) {
            manager.check();
        }
    }
}
</code></pre>
<p>新建职员类：</p>
<pre><code class="lang-java">public class Employee {
    // 职位
    private String position;
    // 工作内容
    private String job;

    public Employee(String position, String job) {
        this.position = position;
        this.job = job;
    }

    // 做自己的本职工作
    public void work() {
        System.out.println(&quot;我是&quot; + position + &quot;，我正在&quot; + job);
    }
}
</code></pre>
<p>客户端建立人员结构关系：</p>
<pre><code class="lang-java">public class Client {

    @Test
    public void test() {
        Manager boss = new Manager(&quot;老板&quot;, &quot;唱怒放的生命&quot;);
        Employee HR = new Employee(&quot;人力资源&quot;, &quot;聊微信&quot;);
        Manager PM = new Manager(&quot;产品经理&quot;, &quot;不知道干啥&quot;);
        Manager CFO = new Manager(&quot;财务主管&quot;, &quot;看剧&quot;);
        Manager CTO = new Manager(&quot;技术主管&quot;, &quot;划水&quot;);
        Employee UI = new Employee(&quot;设计师&quot;, &quot;画画&quot;);
        Employee operator = new Employee(&quot;运营人员&quot;, &quot;兼职客服&quot;);
        Employee webProgrammer = new Employee(&quot;程序员&quot;, &quot;学习设计模式&quot;);
        Employee backgroundProgrammer = new Employee(&quot;后台程序员&quot;, &quot;CRUD&quot;);
        Employee accountant = new Employee(&quot;会计&quot;, &quot;背九九乘法表&quot;);
        Employee clerk = new Employee(&quot;文员&quot;, &quot;给老板递麦克风&quot;);
        boss.addEmployee(HR);
        boss.addManager(PM);
        boss.addManager(CFO);
        PM.addEmployee(UI);
        PM.addManager(CTO);
        PM.addEmployee(operator);
        CTO.addEmployee(webProgrammer);
        CTO.addEmployee(backgroundProgrammer);
        CFO.addEmployee(accountant);
        CFO.addEmployee(clerk);

        boss.check();
    }
}
</code></pre>
<p>运行测试方法，输出如下（为方便查看，笔者添加了缩进）：</p>
<pre><code class="lang-text">我是老板，我正在唱怒放的生命
    我是人力资源，我正在聊微信
    我是产品经理，我正在不知道干啥
        我是设计师，我正在画画
        我是运营人员，我正在兼职客服
        我是技术主管，我正在划水
            我是程序员，我正在学习设计模式
            我是后台程序员，我正在CRUD
    我是财务主管，我正在看剧
        我是会计，我正在背九九乘法表
        我是文员，我正在给老板递麦克风
</code></pre>
<p>这样我们就设计出了公司的结构，但是这样的设计有两个弊端：</p>
<ul>
<li>name 字段，job 字段，work 方法重复了。</li>
<li>管理者对其管理的管理者和职员需要区别对待。</li>
</ul>
<p>关于第一个弊端，虽然这里为了讲解，只有两个字段和一个方法重复，实际工作中这样的整体部分结构会有相当多的重复。比如此例中还可能有工号、年龄等字段，领取工资、上下班打卡、开各种无聊的会等方法。</p>
<p>大量的重复显然是很丑陋的代码，分析一下可以发现， Manager 类只比 Employee 类多一个管理人员的列表字段，多几个增加 / 移除人员的方法，其他的字段和方法全都是一样的。</p>
<p>有读者应该会想到：我们可以将重复的字段和方法提取到一个工具类中，让 Employee 和 Manager 都去调用此工具类，就可以消除重复了。</p>
<p>这样固然可行，但属于 Employee 和 Manager 类自己的东西却要通过其他类调用，并不利于程序的高内聚。</p>
<p>关于第二个弊端，此方案无法解决，此方案中 Employee 和 Manager 类完全是两个不同的对象，两者的相似性被忽略了。</p>
<p>所以我们有更好的设计方案，那就是组合模式！</p>
<h3 id="3-2-使用组合模式的设计方案"><a href="#3-2-使用组合模式的设计方案" class="headerlink" title="3.2.使用组合模式的设计方案"></a>3.2.使用组合模式的设计方案</h3><p>组合模式最主要的功能就是让用户可以一致对待整体和部分结构，将两者都作为一个相同的组件，所以我们先新建一个抽象的组件类：</p>
<pre><code class="lang-java">public abstract class Component {
    // 职位
    private String position;
    // 工作内容
    private String job;

    public Component(String position, String job) {
        this.position = position;
        this.job = job;
    }

    // 做自己的本职工作
    public void work() {
        System.out.println(&quot;我是&quot; + position + &quot;，我正在&quot; + job);
    }

    abstract void addComponent(Component component);

    abstract void removeComponent(Component component);

    abstract void check();
}
</code></pre>
<p>管理者继承自此抽象类：</p>
<pre><code class="lang-java">public class Manager extends Component {
    // 管理的组件
    private List&lt;Component&gt; components = new ArrayList&lt;&gt;();

    public Manager(String position, String job) {
        super(position, job);
    }

    @Override
    public void addComponent(Component component) {
        components.add(component);
    }

    @Override
    void removeComponent(Component component) {
        components.remove(component);
    }

    // 检查下属
    @Override
    public void check() {
        work();
        for (Component component : components) {
            component.check();
        }
    }
}
</code></pre>
<p>职员同样继承自此抽象类：</p>
<pre><code class="lang-java">public class Employee extends Component {

    public Employee(String position, String job) {
        super(position, job);
    }

    @Override
    void addComponent(Component component) {
        System.out.println(&quot;职员没有管理权限&quot;);
    }

    @Override
    void removeComponent(Component component) {
        System.out.println(&quot;职员没有管理权限&quot;);
    }

    @Override
    void check() {
        work();
    }
}
</code></pre>
<p>修改客户端如下：</p>
<pre><code class="lang-java">public class Client {

    @Test
    public void test(){
        Component boss = new Manager(&quot;老板&quot;, &quot;唱怒放的生命&quot;);
        Component HR = new Employee(&quot;人力资源&quot;, &quot;聊微信&quot;);
        Component PM = new Manager(&quot;产品经理&quot;, &quot;不知道干啥&quot;);
        Component CFO = new Manager(&quot;财务主管&quot;, &quot;看剧&quot;);
        Component CTO = new Manager(&quot;技术主管&quot;, &quot;划水&quot;);
        Component UI = new Employee(&quot;设计师&quot;, &quot;画画&quot;);
        Component operator = new Employee(&quot;运营人员&quot;, &quot;兼职客服&quot;);
        Component webProgrammer = new Employee(&quot;程序员&quot;, &quot;学习设计模式&quot;);
        Component backgroundProgrammer = new Employee(&quot;后台程序员&quot;, &quot;CRUD&quot;);
        Component accountant = new Employee(&quot;会计&quot;, &quot;背九九乘法表&quot;);
        Component clerk = new Employee(&quot;文员&quot;, &quot;给老板递麦克风&quot;);
        boss.addComponent(HR);
        boss.addComponent(PM);
        boss.addComponent(CFO);
        PM.addComponent(UI);
        PM.addComponent(CTO);
        PM.addComponent(operator);
        CTO.addComponent(webProgrammer);
        CTO.addComponent(backgroundProgrammer);
        CFO.addComponent(accountant);
        CFO.addComponent(clerk);

        boss.check();
    }
}
</code></pre>
<p>运行测试方法，输出结果与之前的结果一模一样。</p>
<p>可以看到，使用组合模式后，我们解决了之前的两个弊端。一是将共有的字段与方法移到了父类中，消除了重复，并且在客户端中，可以一致对待 Manager 和 Employee 类：</p>
<ul>
<li>Manager 类和 Employee 类统一声明为 Component 对象</li>
<li>统一调用 Component 对象的 addComponent 方法添加子对象即可。</li>
</ul>
<h3 id="3-3-组合模式中的安全方式与透明方式"><a href="#3-3-组合模式中的安全方式与透明方式" class="headerlink" title="3.3.组合模式中的安全方式与透明方式"></a>3.3.组合模式中的安全方式与透明方式</h3><p>读者可能已经注意到了，Employee 类虽然继承了父类的 addComponent 和 removeComponent 方法，但是仅仅提供了一个空实现，因为 Employee 类是不支持添加和移除组件的。这样是否违背了接口隔离原则呢？</p>
<blockquote>
<p>接口隔离原则：客户端不应依赖它不需要的接口。如果一个接口在实现时，部分方法由于冗余被客户端空实现，则应该将接口拆分，让实现类只需依赖自己需要的接口方法。</p>
</blockquote>
<p>答案是肯定的，这样确实违背了接口隔离原则。这种方式在组合模式中被称作透明方式.</p>
<blockquote>
<p>透明方式：在 Component 中声明所有管理子对象的方法，包括 add 、remove 等，这样继承自 Component 的子类都具备了 add、remove 方法。对于外界来说叶节点和枝节点是透明的，它们具备完全一致的接口。</p>
</blockquote>
<p>这种方式有它的优点：让 Manager 类和 Employee 类具备完全一致的行为接口，调用者可以一致对待它们。</p>
<p>但它的缺点也显而易见：Employee 类并不支持管理子对象，不仅违背了接口隔离原则，而且客户端可以用 Employee 类调用 addComponent 和 removeComponent 方法，导致程序出错，所以这种方式是不安全的。</p>
<p>那么我们可不可以将 addComponent 和 removeComponent 方法移到 Manager 子类中去单独实现，让 Employee 不再实现这两个方法呢？我们来尝试一下。</p>
<p>将抽象类修改为：</p>
<pre><code class="lang-java">public abstract class Component {
    // 职位
    private String position;
    // 工作内容
    private String job;

    public Component(String position, String job) {
        this.position = position;
        this.job = job;
    }

    // 做自己的本职工作
    public void work() {
        System.out.println(&quot;我是&quot; + position + &quot;，我正在&quot; + job);
    }

    abstract void check();
}
</code></pre>
<p>可以看到，我们在父类中去掉了 addComponent 和 removeComponent 这两个抽象方法。</p>
<p>Manager 类修改为：</p>
<pre><code class="lang-java">public class Manager extends Component {
    // 管理的组件
    private List&lt;Component&gt; components = new ArrayList&lt;&gt;();

    public Manager(String position, String job) {
        super(position, job);
    }

    public void addComponent(Component component) {
        components.add(component);
    }

    void removeComponent(Component component) {
        components.remove(component);
    }

    // 检查下属
    @Override
    public void check() {
        work();
        for (Component component : components) {
            component.check();
        }
    }
}
</code></pre>
<p>Manager 类单独实现了 addComponent 和 removeComponent 这两个方法，去掉了 @Override 注解。</p>
<p>Employee 类修改为：</p>
<pre><code class="lang-java">public class Employee extends Component {

    public Employee(String position, String job) {
        super(position, job);
    }

    @Override
    void check() {
        work();
    }
}
</code></pre>
<p>客户端建立人员结构关系：</p>
<pre><code class="lang-java">public class Client {

    @Test
    public void test(){
        Manager boss = new Manager(&quot;老板&quot;, &quot;唱怒放的生命&quot;);
        Employee HR = new Employee(&quot;人力资源&quot;, &quot;聊微信&quot;);
        Manager PM = new Manager(&quot;产品经理&quot;, &quot;不知道干啥&quot;);
        Manager CFO = new Manager(&quot;财务主管&quot;, &quot;看剧&quot;);
        Manager CTO = new Manager(&quot;技术主管&quot;, &quot;划水&quot;);
        Employee UI = new Employee(&quot;设计师&quot;, &quot;画画&quot;);
        Employee operator = new Employee(&quot;运营人员&quot;, &quot;兼职客服&quot;);
        Employee webProgrammer = new Employee(&quot;程序员&quot;, &quot;学习设计模式&quot;);
        Employee backgroundProgrammer = new Employee(&quot;后台程序员&quot;, &quot;CRUD&quot;);
        Employee accountant = new Employee(&quot;会计&quot;, &quot;背九九乘法表&quot;);
        Employee clerk = new Employee(&quot;文员&quot;, &quot;给老板递麦克风&quot;);
        boss.addComponent(HR);
        boss.addComponent(PM);
        boss.addComponent(CFO);
        PM.addComponent(UI);
        PM.addComponent(CTO);
        PM.addComponent(operator);
        CTO.addComponent(webProgrammer);
        CTO.addComponent(backgroundProgrammer);
        CFO.addComponent(accountant);
        CFO.addComponent(clerk);

        boss.check();
    }
}
</code></pre>
<p>运行程序，输出结果与之前一模一样。</p>
<p>这种方式在组合模式中称之为安全方式。</p>
<blockquote>
<p>安全方式：在 Component 中不声明 add 和 remove 等管理子对象的方法，这样叶节点就无需实现它，只需在枝节点中实现管理子对象的方法即可。</p>
</blockquote>
<p>安全方式遵循了接口隔离原则，但由于不够透明，Manager 和 Employee 类不具有相同的接口，在客户端中，我们无法将 Manager 和 Employee 统一声明为 Component 类了，必须要区别对待，带来了使用上的不方便。</p>
<p>安全方式和透明方式各有好处，在使用组合模式时，需要根据实际情况决定。但大多数使用组合模式的场景都是采用的透明方式，虽然它有点不安全，但是客户端无需做任何判断来区分是叶子结点还是枝节点，用起来是真香。</p>
<h2 id="四、装饰模式"><a href="#四、装饰模式" class="headerlink" title="四、装饰模式"></a>四、装饰模式</h2><p>提到装饰，我们先来想一下生活中有哪些装饰：</p>
<ul>
<li><strong>女生的首饰</strong>：戒指、耳环、项链等装饰品</li>
<li><strong>家居装饰品</strong>：粘钩、镜子、壁画、盆栽等</li>
</ul>
<p>我们为什么需要这些装饰品呢？很容易想到是为了美，戒指、耳环、项链、壁画、盆栽等都是为了提高颜值或增加美观度。但粘钩、镜子不一样，它们是为了方便我们挂东西、洗漱。所以我们可以总结出装饰品共有两种功能：</p>
<ul>
<li><strong>增强原有的特性</strong>：我们本身就是有一定颜值的，添加装饰品提高了我们的颜值。同样，房屋本身就有一定的美观度，家居装饰提高了房屋的美观度。</li>
<li><strong>添加新的特性</strong>：在墙上挂上粘钩，让墙壁有了挂东西的功能。在洗漱台装上镜子，让洗漱台有了照镜子的功能。</li>
</ul>
<p>并且，我们发现装饰品并不会改变物品本身，只是起到一个锦上添花的作用。装饰模式也一样，它的主要作用就是：</p>
<ul>
<li><strong>增强一个类原有的功能</strong></li>
<li><strong>为一个类添加新的功能</strong></li>
</ul>
<p>并且 <strong>装饰模式也不会改变原有的类</strong>。</p>
<blockquote>
<p><strong>装饰模式</strong>：动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。其别名也可以称为包装器，与适配器模式的别名相同，但它们适用于不同的场合。根据翻译的不同，装饰模式也有人称之为“油漆工模式”。</p>
</blockquote>
<h3 id="1-用于增强功能的装饰模式"><a href="#1-用于增强功能的装饰模式" class="headerlink" title="1. 用于增强功能的装饰模式"></a>1. 用于增强功能的装饰模式</h3><p>我们用程序来模拟一下戴上装饰品提高我们颜值的过程：</p>
<p>新建颜值接口：</p>
<pre><code class="lang-java">public interface IBeauty {
    int getBeautyValue();
}
</code></pre>
<p>新建 Me 类，实现颜值接口：</p>
<pre><code class="lang-java">public class Me implements IBeauty {
​
    @Override
    public int getBeautyValue() {
        return 100;
    }
}
</code></pre>
<p>戒指装饰类，将 Me 包装起来：</p>
<pre><code class="lang-java">public class RingDecorator implements IBeauty {
    private final IBeauty me;
​
    public RingDecorator(IBeauty me) {
        this.me = me;
    }
​
    @Override
    public int getBeautyValue() {
        return me.getBeautyValue() + 20;
    }
}
</code></pre>
<p>客户端测试：</p>
<pre><code class="lang-java">public class Client {
    @Test
    public void show() {
        IBeauty me = new Me();
        System.out.println(&quot;我原本的颜值：&quot; + me.getBeautyValue());
​
        IBeauty meWithRing = new RingDecorator(me);
        System.out.println(&quot;戴上了戒指后，我的颜值：&quot; + meWithRing.getBeautyValue());
    }
}
</code></pre>
<p>运行程序，输出如下：</p>
<pre><code class="lang-text">我原本的颜值：100
戴上了戒指后，我的颜值：120
</code></pre>
<p>这就是最简单的增强功能的装饰模式。以后我们可以添加更多的装饰类，比如：</p>
<p>耳环装饰类：</p>
<pre><code class="lang-java">public class EarringDecorator implements IBeauty {
    private final IBeauty me;
​
    public EarringDecorator(IBeauty me) {
        this.me = me;
    }
​
    @Override
    public int getBeautyValue() {
        return me.getBeautyValue() + 50;
    }
}
</code></pre>
<p>项链装饰类：</p>
<pre><code class="lang-java">public class NecklaceDecorator implements IBeauty {
    private final IBeauty me;
​
    public NecklaceDecorator(IBeauty me) {
        this.me = me;
    }
​
    @Override
    public int getBeautyValue() {
        return me.getBeautyValue() + 80;
    }
}
</code></pre>
<p>客户端测试：</p>
<pre><code class="lang-java">public class Client {
    @Test
    public void show() {
        IBeauty me = new Me();
        System.out.println(&quot;我原本的颜值：&quot; + me.getBeautyValue());
​
        // 随意挑选装饰
        IBeauty meWithNecklace = new NecklaceDecorator(me);
        System.out.println(&quot;戴上了项链后，我的颜值：&quot; + meWithNecklace.getBeautyValue());
​
        // 多次装饰
        IBeauty meWithManyDecorators = new NecklaceDecorator(new RingDecorator(new EarringDecorator(me)));
        System.out.println(&quot;戴上耳环、戒指、项链后，我的颜值：&quot; + meWithManyDecorators.getBeautyValue());
​
        // 任意搭配装饰
        IBeauty meWithNecklaceAndRing = new NecklaceDecorator(new RingDecorator(me));
        System.out.println(&quot;戴上戒指、项链后，我的颜值：&quot; + meWithNecklaceAndRing.getBeautyValue());
    }
}
</code></pre>
<p>运行程序，输出如下：</p>
<pre><code class="lang-text">我原本的颜值：100
戴上了项链后，我的颜值：180
戴上耳环、戒指、项链后，我的颜值：250
戴上戒指、项链后，我的颜值：200
</code></pre>
<p>可以看到，装饰器也实现了 IBeauty 接口，并且没有添加新的方法，也就是说这里的装饰器<strong>仅用于增强功能，并不会改变 Me 原有的功能</strong>，这种装饰模式称之为 <strong>透明装饰模式</strong>，由于没有改变接口，也没有新增方法，所以<strong>透明装饰模式可以无限装饰</strong>。</p>
<p>装饰模式是 <strong>继承</strong> 的一种替代方案。本例如果不使用装饰模式，而是改用继承实现的话，戴着戒指的 Me 需要派生一个子类、戴着项链的 Me 需要派生一个子类、戴着耳环的 Me 需要派生一个子类、戴着戒指 + 项链的需要派生一个子类……各种各样的排列组合会造成类爆炸。而采用了装饰模式就只需要为每个装饰品生成一个装饰类即可，所以说就 <strong>增加对象功能</strong> 来说，<strong>装饰模式比生成子类实现更为灵活</strong>。</p>
<h3 id="2-用于添加功能的装饰模式"><a href="#2-用于添加功能的装饰模式" class="headerlink" title="2. 用于添加功能的装饰模式"></a>2. 用于添加功能的装饰模式</h3><p>我们用程序来模拟一下房屋装饰粘钩后，新增了挂东西功能的过程：</p>
<p>新建房屋接口：</p>
<pre><code class="lang-java">public interface IHouse {
    void live();
}
</code></pre>
<p>房屋类：</p>
<pre><code class="lang-java">public class House implements IHouse{
​
    @Override
    public void live() {
        System.out.println(&quot;房屋原有的功能：居住功能&quot;);
    }
}
</code></pre>
<p>新建粘钩装饰器接口，继承自房屋接口：</p>
<pre><code class="lang-java">public interface IStickyHookHouse extends IHouse{
    void hangThings();
}
</code></pre>
<p>粘钩装饰类：</p>
<pre><code class="lang-java">public class StickyHookDecorator implements IStickyHookHouse {
    private final IHouse house;
​
    public StickyHookDecorator(IHouse house) {
        this.house = house;
    }
​
    @Override
    public void live() {
        house.live();
    }
​
    @Override
    public void hangThings() {
        System.out.println(&quot;有了粘钩后，新增了挂东西功能&quot;);
    }
}
</code></pre>
<p>客户端测试：</p>
<pre><code class="lang-java">public class Client {
    @Test
    public void show() {
        IHouse house = new House();
        house.live();
​
        IStickyHookHouse stickyHookHouse = new StickyHookDecorator(house);
        stickyHookHouse.live();
        stickyHookHouse.hangThings();
    }
}
</code></pre>
<p>运行程序，显示如下：</p>
<pre><code class="lang-text">房屋原有的功能：居住功能
房屋原有的功能：居住功能
有了粘钩后，新增了挂东西功能
</code></pre>
<p>这就是用于 <strong>新增功能</strong> 的装饰模式。我们在接口中新增了方法：hangThings，然后在装饰器中将 House 类包装起来，之前 House 中的方法仍然调用 house 去执行，也就是说我们并没有修改原有的功能，只是扩展了新的功能，这种模式在装饰模式中称之为 <strong>半透明装饰模式</strong>。</p>
<p>为什么叫半透明呢？由于新的接口 IStickyHookHouse 拥有之前 IHouse 不具有的方法，所以我们如果要使用装饰器中添加的功能，就不得不区别对待 <strong>装饰前的对象和装饰后的对象</strong>。也就是说客户端要使用新方法，必须知道具体的装饰类 StickyHookDecorator，所以这个装饰类对客户端来说是可见的、不透明的。而被装饰者不一定要是 House，它可以是实现了 IHouse 接口的任意对象，所以被装饰者对客户端是不可见的、透明的。由于一半透明，一半不透明，所以称之为半透明装饰模式。</p>
<p>我们可以添加更多的装饰器：</p>
<p>新建镜子装饰器的接口，继承自房屋接口：</p>
<pre><code class="lang-java">public interface IMirrorHouse extends IHouse {
    void lookMirror();
}
</code></pre>
<p>镜子装饰类：</p>
<pre><code class="lang-java">public class MirrorDecorator implements IMirrorHouse{
    private final IHouse house;
​
    public MirrorDecorator(IHouse house) {
        this.house = house;
    }
​
    @Override
    public void live() {
        house.live();
    }
​
    @Override
    public void lookMirror() {
        System.out.println(&quot;有了镜子后，新增了照镜子功能&quot;);
    }
}
</code></pre>
<p>客户端测试：</p>
<pre><code class="lang-java">public class Client {
    @Test
    public void show() {
        IHouse house = new House();
        house.live();
​
        IMirrorHouse mirrorHouse = new MirrorDecorator(house);
        mirrorHouse.live();
        mirrorHouse.lookMirror();
    }
}
</code></pre>
<p>运行程序，输出如下：</p>
<pre><code class="lang-text">房屋原有的功能：居住功能
房屋原有的功能：居住功能
​有了镜子后，新增了照镜子功能
</code></pre>
<p>现在我们仿照 <strong>透明装饰模式</strong> 的写法，同时添加粘钩和镜子装饰试一试：</p>
<pre><code class="lang-java">public class Client {
    @Test
    public void show() {
        IHouse house = new House();
        house.live();
​
        IStickyHookHouse stickyHookHouse = new StickyHookDecorator(house);
        IMirrorHouse houseWithStickyHookMirror = new MirrorDecorator(stickyHookHouse);
        houseWithStickyHookMirror.live();
        houseWithStickyHookMirror.hangThings(); // 这里会报错，找不到 hangThings 方法
        houseWithStickyHookMirror.lookMirror();
    }
}
</code></pre>
<p>我们会发现，第二次装饰时，无法获得上一次装饰添加的方法。原因很明显，当我们用 IMirrorHouse 装饰器后，接口变为了 IMirrorHouse，这个接口中并没有 hangThings 方法。</p>
<p>那么我们能否让 IMirrorHouse 继承自 IStickyHookHouse，以实现新增两个功能呢？</p>
<p>可以，但那样做的话两个装饰类之间有了依赖关系，那就不是装饰模式了。装饰类不应该存在依赖关系，而应该在原本的类上进行装饰。这就意味着，<strong>半透明装饰模式中</strong>，<strong>我们无法多次装饰</strong>。</p>
<p>有的同学会问了，既增强了功能，又添加了新功能的装饰模式叫什么呢？</p>
<p>—— 举一反三，肯定是叫全不透明装饰模式！</p>
<p>—— 并不是！只要添加了新功能的装饰模式都称之为 <strong>半透明装饰模式</strong>，他们都具有不可以多次装饰的特点。仔细理解上文半透明名称的由来就知道了，“透明”指的是我们无需知道被装饰者具体的类，既增强了功能，又添加了新功能的装饰模式仍然具有半透明特性。</p>
<p>看了这两个简单的例子，是不是发现装饰模式很简单呢？恭喜你学会了 1 + 1 = 2，现在你已经掌握了算数的基本思想，接下来我们来做一道微积分题练习一下。</p>
<h3 id="I-O-中的装饰模式"><a href="#I-O-中的装饰模式" class="headerlink" title="I/O 中的装饰模式"></a>I/O 中的装饰模式</h3><p>I/O 指的是 Input/Output，即输入、输出。我们以 Input 为例。先在 <code>src</code> 文件夹下新建一个文件 readme.text，随便写点文字：</p>
<pre><code class="lang-text">禁止套娃
禁止禁止套娃
​禁止禁止禁止套娃
</code></pre>
<p>然后用 Java 的 InputStream 读取，代码一般长这样：</p>
<pre><code class="lang-java">public void io() throws IOException {
    InputStream in = new BufferedInputStream(new FileInputStream(&quot;src/readme.txt&quot;));
    byte[] buffer = new byte[1024];
    while (in.read(buffer) != -1) {
        System.out.println(new String(buffer));
    }
    in.close();
}
</code></pre>
<p>这样写有一个问题，如果读取过程中出现了 IO 异常，InputStream 就不能正确关闭，所以我们要用<code>try...finally</code>来保证 InputStream 正确关闭：</p>
<pre><code class="lang-java">public void io() throws IOException {
    InputStream in = null;
    try {
        in = new BufferedInputStream(new FileInputStream(&quot;src/readme.txt&quot;));
        byte[] buffer = new byte[1024];
        while (in.read(buffer) != -1) {
            System.out.println(new String(buffer));
        }
    } finally {
        if (in != null) {
            in.close();
        }
    }
}
</code></pre>
<p>这种写法实在是太丑了，而 IO 操作又必须这么写，显然 Java 也意识到了这个问题，所以 Java 7 中引入了<code>try(resource)</code>语法糖，IO 的代码就可以简化如下：</p>
<pre><code class="lang-java">public void io() throws IOException {
    try (InputStream in = new BufferedInputStream(new FileInputStream(&quot;src/readme.txt&quot;))) {
        byte[] buffer = new byte[1024];
        while (in.read(buffer) != -1) {
            System.out.println(new String(buffer));
        }
    }
}
</code></pre>
<p>这种写法和上一种逻辑是一样的，运行程序，显示如下：</p>
<pre><code class="lang-text">禁止套娃
禁止禁止套娃
禁止禁止禁止套娃
</code></pre>
<p>观察获取 InputStream 这句代码：</p>
<pre><code class="lang-text">InputStream in = new BufferedInputStream(new FileInputStream(&quot;src/readme.txt&quot;));
</code></pre>
<p>是不是和我们之前多次装饰的代码非常相似：</p>
<pre><code class="lang-text">// 多次装饰
IBeauty meWithManyDecorators = new NecklaceDecorator(new RingDecorator(new EarringDecorator(me)));
</code></pre>
<p>事实上，查看 I/O 的源码可知，Java I/O 的设计框架便是使用的 <strong>装饰者模式</strong>，InputStream 的继承关系如下：</p>
<p><img src="https://pica.zhimg.com/80/v2-b02e80f8c9e31c309cfa41ba191a0919_720w.jpg?source=1940ef5c" alt=""></p>
<p>其中，InputStream 是一个抽象类，对应上文例子中的 IHouse，其中最重要的方法是 read 方法，这是一个抽象方法：</p>
<pre><code class="lang-java">public abstract class InputStream implements Closeable {

    public abstract int read() throws IOException;

    // ...
}
</code></pre>
<p>这个方法会读取输入流的下一个字节，并返回字节表示的 int 值（0~255），返回 -1 表示已读到末尾。由于它是抽象方法，所以具体的逻辑交由子类实现。</p>
<p>上图中，左边的三个类 FileInputStream、ByteArrayInputStream、ServletInputStream 是 InputStream 的三个子类，对应上文例子中实现了 IHouse 接口的 House。</p>
<p>右下角的三个类 BufferedInputStream、DataInputStream、CheckedInputStream 是三个具体的装饰者类，他们都为 InputStream 增强了原有功能或添加了新功能。</p>
<p>FilterInputStream 是所有装饰类的父类，它没有实现具体的功能，仅用来包装了一下 InputStream：</p>
<pre><code class="lang-java">public class FilterInputStream extends InputStream {
    protected volatile InputStream in;

    protected FilterInputStream(InputStream in) {
        this.in = in;
    }
​
    public int read() throws IOException {
        return in.read();
    }

    //...
}
</code></pre>
<p>我们以 BufferedInputStream 为例。原有的 InputStream 读取文件时，是一个字节一个字节读取的，这种方式的执行效率并不高，所以我们可以设立一个缓冲区，先将内容读取到缓冲区中，缓冲区读满后，将内容从缓冲区中取出来，这样就变成了一段一段读取，用内存换取效率。BufferedInputStream 就是用来做这个的。它继承自 FilterInputStream：</p>
<pre><code class="lang-java">public class BufferedInputStream extends FilterInputStream {
    private static final int DEFAULT_BUFFER_SIZE = 8192;
    protected volatile byte buf[];
​
    public BufferedInputStream(InputStream in) {
        this(in, DEFAULT_BUFFER_SIZE);
    }
​
    public BufferedInputStream(InputStream in, int size) {
        super(in);
        if (size &lt;= 0) {
            throw new IllegalArgumentException(&quot;Buffer size &lt;= 0&quot;);
        }
        buf = new byte[size];
    }

    //...
}
</code></pre>
<p>我们先来看它的构造方法，在构造方法中，新建了一个 byte[] 作为缓冲区，从源码中我们看到，Java 默认设置的缓冲区大小为 8192 byte，也就是 8 KB。</p>
<p>然后我们来查看 read 方法：</p>
<pre><code class="lang-java">public class BufferedInputStream extends FilterInputStream {
    //...
​
    public synchronized int read() throws IOException {
        if (pos &gt;= count) {
            fill();
            if (pos &gt;= count)
                return -1;
        }
        return getBufIfOpen()[pos++] &amp; 0xff;
    }
​
    private void fill() throws IOException {
        // 往缓冲区内填充读取内容的过程
        //...
    }
}
</code></pre>
<p>在 read 方法中，调用了 fill 方法，fill 方法的作用就是往缓冲区中填充读取的内容。这样就实现了增强原有的功能。</p>
<p>在源码中我们发现，BufferedInputStream 没有添加 InputStream 中没有的方法，所以 BufferedInputStream 使用的是 <strong>透明的装饰模式</strong>。</p>
<p>DataInputStream 用于更加方便地读取 int、double 等内容，观察 DataInputStream 的源码可以发现，DataInputStream 中新增了 readInt、readLong 等方法，所以 DataInputStream 使用的是 <strong>半透明装饰模式</strong>。</p>
<p>理解了 InputStream 后，再看一下 OutputStream 的继承关系，相信大家一眼就能看出各个类的作用了：</p>
<p><img src="https://pic2.zhimg.com/80/v2-35efe24140308ba0394d7758fd7546c4_720w.jpg?source=1940ef5c" alt=""></p>
<p>这就是装饰模式，注意不要和适配器模式混淆了。两者在使用时都是包装一个类，但两者的区别其实也很明显：</p>
<ul>
<li>纯粹的适配器模式 <strong>仅用于改变接口</strong>，不改变其功能，部分情况下我们需要改变一点功能以适配新接口。但使用适配器模式时，接口一定会有一个 <strong>回炉重造</strong> 的过程。</li>
<li>装饰模式 <strong>不改变原有的接口</strong>，仅用于增强原有功能或添加新功能，强调的是 <strong>锦上添花</strong>。</li>
</ul>
<p>掌握了装饰者模式之后，理解 Java I/O 的框架设计就非常容易了。但对于不理解装饰模式的人来说，各种各样相似的 InputStream 非常容易让开发者感到困惑。这一点正是装饰模式的缺点：<strong>容易造成程序中有大量相似的类</strong>。虽然这更像是开发者的缺点，我们应该做的是提高自己的技术，掌握了这个设计模式之后它就是我们的一把利器。现在我们再看到 I/O 不同的 InputStream 装饰类，只需要关注它增强了什么功能或添加了什么功能即可。</p>
<h2 id="五、外观模式"><a href="#五、外观模式" class="headerlink" title="五、外观模式"></a>五、外观模式</h2><p>外观模式非常简单，体现的就是 Java 中封装的思想。将多个子系统封装起来，提供一个更简洁的接口供外部调用。</p>
<p><img src="https://pic2.zhimg.com/80/v2-c75e41044733a59739f416b2100e21b7_720w.jpg?source=1940ef5c" alt=""></p>
<blockquote>
<p><strong>外观模式</strong>：外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式。</p>
</blockquote>
<p>举个例子，比如我们每天打开电脑时，都需要做三件事：</p>
<ul>
<li>打开浏览器</li>
<li>打开 IDE</li>
<li>打开微信</li>
</ul>
<p>每天下班时，关机前需要做三件事：</p>
<ul>
<li>关闭浏览器</li>
<li>关闭 IDE</li>
<li>关闭微信</li>
</ul>
<p>用程序模拟如下：</p>
<p>新建浏览器类：</p>
<pre><code class="lang-java">public class Browser {
    public static void open() {
        System.out.println(&quot;打开浏览器&quot;);
    }
​
    public static void close() {
        System.out.println(&quot;关闭浏览器&quot;);
    }
​}
</code></pre>
<p>新建 IDE 类：</p>
<pre><code class="lang-java">public class IDE {
    public static void open() {
        System.out.println(&quot;打开 IDE&quot;);
    }
​
    public static void close() {
        System.out.println(&quot;关闭 IDE&quot;);
    }
}
</code></pre>
<p>新建微信类：</p>
<pre><code class="lang-java">public class Wechat {
    public static void open() {
        System.out.println(&quot;打开微信&quot;);
    }
​
    public static void close() {
        System.out.println(&quot;关闭微信&quot;);
    }
}
</code></pre>
<p>客户端调用：</p>
<pre><code class="lang-java">public class Client {
    @Test
    public void test() {
        System.out.println(&quot;上班:&quot;);
        Browser.open();
        IDE.open();
        Wechat.open();
​
        System.out.println(&quot;下班:&quot;);
        Browser.close();
        IDE.close();
        Wechat.close();
    }
}
</code></pre>
<p>运行程序，输出如下：</p>
<pre><code class="lang-text">上班:
打开浏览器
打开 IDE
打开微信
下班:
关闭浏览器
关闭 IDE
关闭微信
</code></pre>
<p>由于我们每天都要做这几件事，所以我们可以使用<strong>外观模式</strong>，将这几个子系统封装起来，提供更简洁的接口：</p>
<pre><code class="lang-java">public class Facade {
    public void open() {
        Browser.open();
        IDE.open();
        Wechat.open();
    }
​
    public void close() {
        Browser.close();
        IDE.close();
        Wechat.close();
    }
}
</code></pre>
<p>客户端就可以简化代码，只和这个外观类打交道：</p>
<pre><code class="lang-java">public class Client {
    @Test
    public void test() {
        Facade facade = new Facade();
        System.out.println(&quot;上班:&quot;);
        facade.open();
​
        System.out.println(&quot;下班:&quot;);
        facade.close();
    }
}
</code></pre>
<p>运行程序，输出与之前一样。</p>
<p>外观模式就是这么简单，它使得两种不同的类不用直接交互，而是通过一个中间件——也就是外观类——间接交互。外观类中只需要暴露简洁的接口，隐藏内部的细节，所以说白了就是封装的思想。</p>
<p>外观模式非常常用，（当然了！写代码哪有不封装的！）尤其是在第三方库的设计中，我们应该提供尽量简洁的接口供别人调用。另外，在 MVC 架构中，C 层（Controller）就可以看作是外观类，Model 和 View 层通过 Controller 交互，减少了耦合。</p>
<h2 id="六、享元模式"><a href="#六、享元模式" class="headerlink" title="六、享元模式"></a>六、享元模式</h2><p>享元模式体现的是 <strong>程序可复用</strong> 的特点，为了节约宝贵的内存，程序应该尽可能地复用，就像《极限编程》作者 Kent 在书里说到的那样：Don’t repeat yourself. 简单来说 <strong>享元模式就是共享对象</strong>，提高复用性，官方的定义倒是显得文绉绉的：</p>
<blockquote>
<p><strong>享元模式</strong>：运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式。</p>
</blockquote>
<p>​有个细节值得注意：有些对象本身不一样，但通过一点点变化后就可以复用，我们编程时可能稍不注意就会忘记复用这些对象。比如说伟大的《超级玛丽》，谁能想到草和云更改一下颜色就可以实现复用呢？</p>
<p>还有里面的三种乌龟，换一个颜色、加一个装饰就变成了不同的怪：</p>
<p><img src="https://pic2.zhimg.com/80/v2-751d3caaf8f304bd67097a4d5a7888ce_720w.jpg?source=1940ef5c" alt=""></p>
<p>在《超级玛丽》中，这样的细节还有很多，正是这些精湛的复用使得这一款红遍全球的游戏仅有 40KB 大小。正是印证了那句名言：神在细节之中。</p>
<h2 id="七、代理模式"><a href="#七、代理模式" class="headerlink" title="七、代理模式"></a>七、代理模式</h2><p>现在我们有一个 <code>人</code> 类，他整天就只负责吃饭、睡觉：</p>
<p><code>人</code>类的接口</p>
<pre><code class="lang-java">public interface IPerson {
    void eat();
    void sleep();
}
</code></pre>
<p><code>人</code>类：</p>
<pre><code class="lang-java">public class Person implements IPerson{
​
    @Override
    public void eat() {
        System.out.println(&quot;我在吃饭&quot;);
    }
​
    @Override
    public void sleep() {
        System.out.println(&quot;我在睡觉&quot;);
    }
}
</code></pre>
<p>客户端测试：</p>
<pre><code class="lang-java">public class Client {
    @Test
    public void test() {
        Person person = new Person();
        person.eat();
        person.sleep();
    }
}
</code></pre>
<p>运行程序，输出如下：</p>
<pre><code class="lang-text">我在吃饭
我在睡觉
</code></pre>
<p>我们可以把这个类包装到另一个类中，实现完全一样的行为：</p>
<pre><code class="lang-java">public class PersonProxy implements IPerson {
​
    private final Person person;
​
    public PersonProxy(Person person) {
        this.person = person;
    }
​
    @Override
    public void eat() {
        person.eat();
    }
​
    @Override
    public void sleep() {
        person.sleep();
    }
}
</code></pre>
<p>将客户端修改为调用这个新的类：</p>
<pre><code class="lang-java">public class Client {
    @Test
    public void test() {
        Person person = new Person();
        PersonProxy proxy = new PersonProxy(person);
        proxy.eat();
        proxy.sleep();
    }
​}
</code></pre>
<p>运行程序，输出如下：</p>
<pre><code class="lang-text">我在吃饭
我在睡觉
</code></pre>
<p>这就是代理模式。</p>
<p>笔者尽量用最简洁的代码讲解此模式，只要理解了上述这个简单的例子，你就知道代理模式是怎么一回事了。我们在客户端和 Person 类之间新增了一个中间件 PersonProxy，这个类就叫做代理类，他实现了和 Person 类一模一样的行为。</p>
<blockquote>
<p><strong>代理模式</strong>：给某一个对象提供一个代理，并由代理对象控制对原对象的引用。</p>
</blockquote>
<p>现在这个代理类还看不出任何意义，我们来模拟一下工作中的需求。在实际工作中，我们可能会遇到这样的需求：在网络请求前后，分别打印将要发送的数据和接收到数据作为日志信息。此时我们就可以新建一个网络请求的代理类，让它代为处理网络请求，并在代理类中打印这些日志信息。</p>
<p>新建网络请求接口：</p>
<pre><code class="lang-java">public interface IHttp {
    void request(String sendData);
​
    void onSuccess(String receivedData);
}
</code></pre>
<p>新建 Http 请求工具类：</p>
<pre><code class="lang-java">public class HttpUtil implements IHttp {
    @Override
    public void request(String sendData) {
        System.out.println(&quot;网络请求中...&quot;);
    }
​
    @Override
    public void onSuccess(String receivedData) {
        System.out.println(&quot;网络请求完成。&quot;);
    }
}
</code></pre>
<p>新建 Http 代理类：</p>
<pre><code class="lang-java">public class HttpProxy implements IHttp {
    private final HttpUtil httpUtil;
​
    public HttpProxy(HttpUtil httpUtil) {
        this.httpUtil = httpUtil;
    }
​
    @Override
    public void request(String sendData) {
        httpUtil.request(sendData);
    }
​
    @Override
    public void onSuccess(String receivedData) {
        httpUtil.onSuccess(receivedData);
    }
}
</code></pre>
<p>到这里，和我们上述吃饭睡觉的代码是一模一样的，现在我们在 HttpProxy 中新增打印日志信息：</p>
<pre><code class="lang-java">public class HttpProxy implements IHttp {
    private final HttpUtil httpUtil;
​
    public HttpProxy(HttpUtil httpUtil) {
        this.httpUtil = httpUtil;
    }
​
    @Override
    public void request(String sendData) {
        System.out.println(&quot;发送数据:&quot; + sendData);
        httpUtil.request(sendData);
    }
​
    @Override
    public void onSuccess(String receivedData) {
        System.out.println(&quot;收到数据:&quot; + receivedData);
        httpUtil.onSuccess(receivedData);
    }
}
</code></pre>
<p>客户端验证：</p>
<pre><code class="lang-java">public class Client {
    @Test
    public void test() {
        HttpUtil httpUtil = new HttpUtil();
        HttpProxy proxy = new HttpProxy(httpUtil);
        proxy.request(&quot;request data&quot;);
        proxy.onSuccess(&quot;received result&quot;);
    }
}
</code></pre>
<p>运行程序，输出如下：</p>
<pre><code class="lang-text">发送数据:request data
网络请求中...
收到数据:received result
网络请求完成。
</code></pre>
<p>这就是代理模式的一个应用，除了 <strong>打印日志</strong>，它还可以用来做<strong>权限管理</strong>。读者看到这里可能已经发现了，这个代理类看起来和装饰模式的 FilterInputStream 一模一样，但两者的目的不同，装饰模式是为了 <strong>增强功能或添加功能</strong>，代理模式主要是为了<strong>加以控制</strong>。</p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>上例中的代理被称之为静态代理，动态代理与静态代理的原理一模一样，只是换了一种写法。使用动态代理，需要把一个类传入，然后根据它正在调用的方法名判断是否需要加以控制。用伪代码表示如下：</p>
<pre><code class="lang-java">public class HttpProxy {
    private final HttpUtil httpUtil;
​
    public HttpProxy(HttpUtil httpUtil) {
        this.httpUtil = httpUtil;
    }
​
    // 假设调用 httpUtil 的任意方法时，都要通过这个方法间接调用, methodName 表示方法名，args 表示方法中传入的参数
    public visit(String methodName, Object[] args) {
        if (methodName.equals(&quot;request&quot;)) {
            // 如果方法名是 request，打印日志，并调用 request 方法，args 的第一个值就是传入的参数
            System.out.println(&quot;发送数据:&quot; + args[0]);
            httpUtil.request(args[0].toString());
        } else if (methodName.equals(&quot;onSuccess&quot;)) {
            // 如果方法名是 onSuccess，打印日志，并调用 onSuccess 方法，args 的第一个值就是传入的参数
            System.out.println(&quot;收到数据:&quot; + args[0]);
            httpUtil.onSuccess(args[0].toString());
        }
    }
}
</code></pre>
<p>伪代码看起来还是很简单的，实现起来唯一的难点就是<strong>怎么让 httpUtil 调用任意方法时</strong>，<strong>都通过一个方法间接调用</strong>。这里需要用到反射技术，不了解反射技术也没有关系，不妨把它记做固定的写法。实际的动态代理类代码如下：</p>
<pre><code class="lang-java">public class HttpProxy implements InvocationHandler {
    private HttpUtil httpUtil;
​
    public IHttp getInstance(HttpUtil httpUtil) {
        this.httpUtil = httpUtil;
        return (IHttp) Proxy.newProxyInstance(httpUtil.getClass().getClassLoader(), httpUtil.getClass().getInterfaces(), this);
    }
​
    // 调用 httpUtil 的任意方法时，都要通过这个方法调用
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        Object result = null;
        if (method.getName().equals(&quot;request&quot;)) {
            // 如果方法名是 request，打印日志，并调用 request 方法
            System.out.println(&quot;发送数据:&quot; + args[0]);
            result = method.invoke(httpUtil, args);
        } else if (method.getName().equals(&quot;onSuccess&quot;)) {
            // 如果方法名是 onSuccess，打印日志，并调用 onSuccess 方法
            System.out.println(&quot;收到数据:&quot; + args[0]);
            result = method.invoke(httpUtil, args);
        }
        return result;
    }
}
</code></pre>
<p>先看 getInstance 方法，Proxy.newProxyInstance 方法是 Java 系统提供的方法，专门用于动态代理。其中传入的第一个参数是被代理的类的 ClassLoader，第二个参数是被代理类的 Interfaces，这两个参数都是 Object 中的，每个类都有，这里就是固定写法。我们只要知道系统需要这两个参数才能让我们实现我们的目的：<strong>调用被代理类的任意方法时</strong>，<strong>都通过一个方法间接调用</strong>。现在我们给系统提供了这两个参数，系统就会在第三个参数中帮我们实现这个目的。</p>
<p>第三个参数是 InvocationHandler 接口，这个接口中只有一个方法：</p>
<pre><code class="lang-text">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;
</code></pre>
<p>那么不用猜就知道，现在我们调用被代理类 httpUtil 的任意方法时，都会通过这个 invoke 方法调用了。invoke 方法中，第一个参数我们暂时用不上，第二个参数 method 就是调用的方法，使用 method.getName() 可以获取到方法名，第三个参数是调用 method 方法需要传入的参数。本例中无论 request 还是 onSuccess 都只有一个 String 类型的参数，对应到这里就是 args[0]。返回的 Object 是 method 方法的返回值，本例中都是无返回值的。</p>
<p>我们在 invoke 方法中判断了当前调用方法的方法名，如果现在调用的方法是 request，那么打印请求参数，并使用这一行代码继续执行当前方法：</p>
<pre><code class="lang-text">result = method.invoke(httpUtil, args);
</code></pre>
<p>这就是 <strong>反射调用函数</strong> 的写法，如果不了解可以记做固定写法，想要了解的同学可以看之前的这篇文章：<strong><a href="https://zhuanlan.zhihu.com/p/86293659" target="_blank" rel="noopener">详解面试中常考的 Java 反射机制</a></strong>。虽然这个函数没有返回值，但我们还是将 result 返回，这是标准做法。</p>
<p>如果现在调用的方法是 onSuccess，那么打印接收到的数据，并反射继续执行当前方法。</p>
<p>修改客户端验证一下：</p>
<pre><code class="lang-java">public class Client {
    @Test
    public void test() {
        HttpUtil httpUtil = new HttpUtil();
        IHttp proxy = new HttpProxy().getInstance(httpUtil);
        proxy.request(&quot;request data&quot;);
        proxy.onSuccess(&quot;received result&quot;);
    }
}
</code></pre>
<p>运行程序，输出与之前一样：</p>
<pre><code class="lang-text">发送数据:request data
网络请求中...
收到数据:received result
网络请求完成。
</code></pre>
<p>动态代理本质上与静态代理没有区别，它的好处是<strong>节省代码量</strong>。比如被代理类有 20 个方法，而我们只需要控制其中的两个方法，就可以用动态代理通过方法名对被代理类进行动态的控制，而如果用静态方法，我们就需要将另外的 18 个方法也写出来，非常繁琐。这就是动态代理的优势所在。</p>
<p><strong>下面三篇文章为行为型模式的全部内容：</strong></p>
<p>码字不易，觉得本文不错的给力扣君点个赞呀～</p>
