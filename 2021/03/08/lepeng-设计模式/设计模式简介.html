<hr>
<p>title: 设计模式简介<br>subtitle:<br>author: Lepeng<br>catalog: true<br>comments: true<br>header-img: img/header_img/archive-bg.jpg<br>tags:</p>
<ul>
<li>设计模式<br>categories:</li>
<li>设计模式<br>date: 2021-03-08<br>link:</li>
<li><a href="https://www.zhihu.com/question/308850392" target="_blank" rel="noopener">https://www.zhihu.com/question/308850392</a></li>
<li><a href="https://blog.csdn.net/mw_nice/article/details/82840034" target="_blank" rel="noopener">https://blog.csdn.net/mw_nice/article/details/82840034</a></li>
</ul>
<hr>
<h2 id="体会设计模式"><a href="#体会设计模式" class="headerlink" title="体会设计模式"></a>体会设计模式</h2><p>设计模式是中级程序员向高级程序员过渡的关键，跨不过这道坎，无论有多少经验，你都不会真正体会到编程之美。</p>
<p>那么什么是设计模式？简单的说就是<strong>套路，招数，</strong>和搏击中的套路和招数是一个意思。</p>
<p>我们学习一门语言（例如java），基本语法类似于搏击中的基本功（类似直拳、勾拳、侧踢），而设计模式则类似于组合技。</p>
<p>搏击中的组合技适合不同的场景，例如倒地的时候，如果对手的关节处于合适的位置，专业的格斗家会选择一个“十字绞”来完成一次绝杀。</p>
<p>这个“十字绞”在搏击中被称为套路，如果用科学的语言说，这就是一个模式，可被称为“搏击模式”。</p>
<p>而所谓的“搏击模式”就是无数的搏击家，在搏击实践中，总结出的，应对特殊场景下“最佳”搏击实践。</p>
<p>类似的，中国象棋中也有很多模式，例如“马后炮”、“连环马”等。</p>
<p>而《孙子兵法》、《三十六计》就讲解“战争模式”的书。</p>
<p>而设计模式，直白的说就是编程中的模式，它是过去的优秀程序员总结出的，面对特定编程问题的特殊“招式”，最佳实践。</p>
<p>设计模式在程序员的面试中会被考到，通常是介绍其原理并说出优缺点。或者对比几个比较相似的模式的异同点。在笔试中可能会出现画出某个设计模式的 UML 图这样的题。虽说面试中占的比重不大，但并不代表它不重要。</p>
<p>恰恰相反，设计模式于程序员而言相当重要，它是我们写出优秀程序的保障。设计模式与程序员的架构能力与阅读源码的能力息息相关，非常值得我们深入学习。</p>
<p>面向对象的特点是<strong>可维护</strong>、<strong>可复用</strong>、<strong>可扩展</strong>、<strong>灵活性好</strong>，它真正强大的地方在于：随着业务变得越来越复杂，面向对象依然能够使得程序结构良好，而面向过程却会导致程序越来越臃肿。</p>
<p>让面向对象保持结构良好的秘诀就是 <strong>设计模式。</strong></p>
<h2 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h2><p>设计模式的世界丰富多彩，比如生产一个个「产品」的工厂模式，衔接两个不相关接口的适配器模式，用不同的方式做同一件事的策略模式，构建步骤稳定、根据构建过程的不同配置构建出不同对象的建造者模式等。</p>
<p>面向对象结合设计模式，才能真正体会到程序变得可维护、可复用、可扩展、灵活性好。设计模式对于程序员而言并不陌生，每个程序员在编程时都会或多或少地接触到设计模式。无论是在大型程序的架构中，亦或是在源码的学习中，设计模式都扮演着非常重要的角色。</p>
<p><strong>设计模式基于六大原则</strong>：</p>
<ul>
<li><strong>开闭原则（Open Closed Principle）</strong>：一个软件实体如类、模块和函数应该对修改封闭，对扩展开放。</li>
<li><strong>单一职责原则（Single Responsibility Principle）</strong>：一个类只做一件事，一个类应该只有一个引起它修改的原因。</li>
<li><strong>里氏替换原则（Liskov Substitution Principle ）</strong>：子类应该可以完全替换父类。也就是说在使用继承时，只扩展新功能，而不要破坏父类原有的功能。</li>
<li><strong>依赖倒置原则（Dependence Inversion Principle）</strong>：细节应该依赖于抽象，抽象不应依赖于细节。把抽象层放在程序设计的高层，并保持稳定，程序的细节变化由低层的实现层来完成。</li>
<li><strong>迪米特法则（Law of Demeter）</strong>：又名「最少知道原则」，一个类不应知道自己操作的类的细节，换言之，只和朋友谈话，不和朋友的朋友谈话。</li>
<li><strong>接口隔离原则（Interface Segregation Principle）</strong>：不要建立臃肿庞大的接口。即接口尽量细化，同时接口中的方法尽量少。</li>
</ul>
<p>所有的设计模式都是为了程序能更好的满足这六大原则。</p>
<h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><p>设计模式一共有 23 种，总体来说设计模式分为三大类：</p>
<ul>
<li><p>创建型模式：对象实例化的模式，用于对象的创建对业务或应用逻辑是强依赖，或者创建的创景比较复杂的场景。</p>
<ul>
<li>工厂方法模式、</li>
<li>抽象工厂模式、</li>
<li>单例模式、</li>
<li>建造者模式、</li>
<li>原型模式（不常用）。</li>
</ul>
</li>
<li><p>把类或对象结合在一起形成一个更大的结构。一般是解决不同的类之间有不同关系的情况。</p>
<ul>
<li>适配器模式、</li>
<li>装饰器模式、</li>
<li>代理模式、</li>
<li>桥接模式、</li>
<li>外观模式（不常用）、</li>
<li>组合模式（不常用）、</li>
<li>享元模式（不常用）。</li>
<li>装饰模式是为了 <strong>增强功能或添加功能</strong>，代理模式主要是为了<strong>加以控制</strong>。</li>
</ul>
</li>
<li><p>类和对象如何交互，及划分责任和算法。</p>
<ul>
<li>策略模式、</li>
<li>模板方法模式、</li>
<li>观察者模式、</li>
<li>迭代子模式、</li>
<li>责任链模式、</li>
<li>状态模式、</li>
<li>命令模式（不常用）、</li>
<li>备忘录模式（不常用）、</li>
<li>访问者模式（不常用）、</li>
<li>中介者模式（不常用）、</li>
<li>解释器模式（不常用）。</li>
</ul>
</li>
<li><p>其实还有两类：并发型模式和线程池模式。</p>
</li>
</ul>
