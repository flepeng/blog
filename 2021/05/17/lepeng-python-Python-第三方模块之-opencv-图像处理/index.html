<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <script data-ad-client="ca-pub-2488174175014870" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script> <!-- google ad -->
    <meta name="google-site-verification" content="40lMg4eqLLbXoDcpN3h-cEnfmselbQ8tUzNvuC0IRIs" /><!-- google 站点认证 -->
    <meta name="baidu-site-verification" content="093lY4ziMu" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="description" content="A hexo theme">
    <meta name="keyword"  content="hexo, hexo-theme-lp">
    <link rel="shortcut icon" href="/img/ironman-draw.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <!--<link href='http://fonts.googleapis.com/css?family=Montserrat:400,700' rel='stylesheet' type='text/css'>-->
    <title>
        
          Python 第三方模块之 opencv - 图像处理 - Hexo-theme-lp
        
    </title>

    <link rel="canonical" href="https://flepeng.github.io/2021/05/17/lepeng-python-Python-第三方模块之-opencv-图像处理/">

    <!-- Bootstrap Core CSS -->
    
<link rel="stylesheet" href="/css/bootstrap.min.css">


    <!-- Custom CSS --> 
    
        
<link rel="stylesheet" href="/css/dusign-light.css">

        
<link rel="stylesheet" href="/css/dusign-common-light.css">

        
<link rel="stylesheet" href="/css/font-awesome.css">

        
<link rel="stylesheet" href="/css/toc.css">

        <!-- background effects end -->
    
    
    <!-- Pygments Highlight CSS -->
    
<link rel="stylesheet" href="/css/highlight.css">


    
<link rel="stylesheet" href="/css/widget.css">


    
<link rel="stylesheet" href="/css/rocket.css">


    
<link rel="stylesheet" href="/css/signature.css">


    
<link rel="stylesheet" href="/css/fonts.googleapis.css">


    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">

    <!-- photography -->
    
<link rel="stylesheet" href="/css/photography.css">


    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- background effects start -->
    
    <!-- background effects end -->

	<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            
                background-image: linear-gradient(rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.3)), url('/img/header_img/archive-bg.jpg')
                /*post*/
            
        
    }
    
    #signature{
        background-image: url('/img/signature/dusign.png');
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#Python" title="Python">Python</a>
                            
                              <a class="tag" href="/tags/#Python 第三方模块" title="Python 第三方模块">Python 第三方模块</a>
                            
                        </div>
                        <h1>Python 第三方模块之 opencv - 图像处理</h1>
                        <h2 class="subheading"></h2>
                        <span class="meta">
                            Posted by Lepeng on
                            2021-05-17
                        </span>

                        
                            <div class="blank_box"></div>
                            <span class="meta">
                                Words <span class="post-count">14.5k</span> and
                                Reading Time <span class="post-count">60</span> Minutes
                            </span>
                            <div class="blank_box"></div>
                            <!-- 不蒜子统计 start -->
                            <span class="meta">
                                Viewed <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span> Times
                            </span>
                            <!-- 不蒜子统计 end -->
                        

                    </div>
                

                </div>
            </div>
        </div>      
    </div>

    
    <div class="waveWrapper">
        <div class="wave wave_before" style="background-image: url('/img/wave-light.png')"></div>
        <div class="wave wave_after" style="background-image: url('/img/wave-light.png')"></div>
    </div>
    
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Lepeng</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archive/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/categories/">Categories</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                    
                    <li>
                        <a href="http://flepeng.com" target="_blank">chinese_blog</a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h1 id="Python-OpenCV"><a href="#Python-OpenCV" class="headerlink" title="Python-OpenCV"></a>Python-OpenCV</h1><ul>
<li>Github： <a href="https://github.com/fendouai/OpenCVTutorials" target="_blank" rel="noopener">https://github.com/fendouai/OpenCVTutorials</a></li>
<li>OpenCV中文手册： <a href="http://woshicver.com/" target="_blank" rel="noopener">http://woshicver.com/</a></li>
</ul>
<p>本篇将介绍和深度学习数据处理阶段最相关的基础使用，并完成4个有趣实用的小例子：</p>
<ul>
<li>延时摄影小程序</li>
<li>视频中截屏采样的小程序</li>
<li>图片数据增加（data augmentation）的小工具</li>
<li>物体检测框标注小工具</li>
</ul>
<p>其中后两个例子的代码可以在下面地址直接下载：</p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/frombeijingwithlove/dlcv_for_beginners">frombeijingwithlove/dlcv_for_beginners​github.com</a></p>
<h2 id="1-1-OpenCV简介"><a href="#1-1-OpenCV简介" class="headerlink" title="1.1 OpenCV简介"></a>1.1 OpenCV简介</h2><p>OpenCV是计算机视觉领域应用最广泛的开源工具包，基于C/C++，支持Linux/Windows/MacOS/Android/iOS，并提供了Python，Matlab和Java等语言的接口，因为其丰富的接口，优秀的性能和商业友好的使用许可，不管是学术界还是业界中都非常受欢迎。OpenCV最早源于Intel公司1998年的一个研究项目，当时在Intel从事计算机视觉的工程师盖瑞·布拉德斯基(Gary Bradski)访问一些大学和研究组时发现学生之间实现计算机视觉算法用的都是各自实验室里的内部代码或者库，这样新来实验室的学生就能基于前人写的基本函数快速上手进行研究。于是OpenCV旨在提供一个用于计算机视觉的科研和商业应用的高性能通用库。  </p>
<p>第一个alpha版本的OpenCV于2000年的CVPR上发布，在接下来的5年里，又陆续发布了5个beta版本，2006年发布了第一个正式版。2009年随着盖瑞加入了Willow Garage，OpenCV从Willow Garage得到了积极的支持，并发布了1.1版。2010年OpenCV发布了2.0版本，添加了非常完备的C++接口，从2.0开始的版本非常用户非常庞大，至今仍在维护和更新。2015年OpenCV 3正式发布，除了架构的调整，还加入了更多算法，更多性能的优化和更加简洁的API，另外也加强了对GPU的支持，现在已经在许多研究机构和商业公司中应用开来。  </p>
<h3 id="1-1-1-OpenCV的结构"><a href="#1-1-1-OpenCV的结构" class="headerlink" title="1.1.1 OpenCV的结构"></a>1.1.1 OpenCV的结构</h3><p>和Python一样，当前的OpenCV也有两个大版本，OpenCV2和OpenCV3。相比OpenCV2，OpenCV3提供了更强的功能和更多方便的特性。不过考虑到和深度学习框架的兼容性，以及上手安装的难度，这部分先以2为主进行介绍。</p>
<p>根据功能和需求的不同，OpenCV中的函数接口大体可以分为如下部分：</p>
<ul>
<li><p>core：核心模块，主要包含了OpenCV中最基本的结构（矩阵，点线和形状等），以及相关的基础运算/操作。</p>
</li>
<li><p>imgproc：图像处理模块，包含和图像相关的基础功能（滤波，梯度，改变大小等），以及一些衍生的高级功能（图像分割，直方图，形态分析和边缘/直线提取等）。</p>
</li>
<li><p>highgui：提供了用户界面和文件读取的基本函数，比如图像显示窗口的生成和控制，图像/视频文件的IO等。</p>
</li>
</ul>
<p>如果不考虑视频应用，以上三个就是最核心和常用的模块了。针对视频和一些特别的视觉应用，OpenCV也提供了强劲的支持：</p>
<ul>
<li><p>video：用于视频分析的常用功能，比如光流法（Optical Flow）和目标跟踪等。</p>
</li>
<li><p>calib3d：三维重建，立体视觉和相机标定等的相关功能。</p>
</li>
<li><p>features2d：二维特征相关的功能，主要是一些不受专利保护的，商业友好的特征点检测和匹配等功能，比如ORB特征。</p>
</li>
<li><p>object：目标检测模块，包含级联分类和Latent SVM</p>
</li>
<li><p>ml：机器学习算法模块，包含一些视觉中最常用的传统机器学习算法。</p>
</li>
<li><p>flann：最近邻算法库，Fast Library for Approximate Nearest Neighbors，用于在多维空间进行聚类和检索，经常和关键点匹配搭配使用。</p>
</li>
<li><p>gpu：包含了一些gpu加速的接口，底层的加速是CUDA实现。</p>
</li>
<li><p>photo：计算摄像学（Computational Photography）相关的接口，当然这只是个名字，其实只有图像修复和降噪而已。</p>
</li>
<li><p>stitching：图像拼接模块，有了它可以自己生成全景照片。</p>
</li>
<li><p>nonfree：受到专利保护的一些算法，其实就是SIFT和SURF。</p>
</li>
<li><p>contrib：一些实验性质的算法，考虑在未来版本中加入的。</p>
</li>
<li><p>legacy：字面是遗产，意思就是废弃的一些接口，保留是考虑到向下兼容。</p>
</li>
<li><p>ocl：利用OpenCL并行加速的一些接口。</p>
</li>
<li><p>superres：超分辨率模块，其实就是BTV-L1（Biliteral Total Variation – L1 regularization）算法</p>
</li>
<li><p>viz：基础的3D渲染模块，其实底层就是著名的3D工具包VTK（Visualization Toolkit）。</p>
</li>
</ul>
<p>从使用的角度来看，和OpenCV2相比，OpenCV3的主要变化是更多的功能和更细化的模块划分。</p>
<h3 id="1-1-2-安装和使用OpenCV"><a href="#1-1-2-安装和使用OpenCV" class="headerlink" title="1.1.2 安装和使用OpenCV"></a>1.1.2 安装和使用OpenCV</h3><p>作为最流行的视觉包，在Linux中安装OpenCV是非常方便的，大多数Linux的发行版都支持包管理器的安装，比如在Ubuntu 16.04 LTS中，只需要在终端中输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; sudo apt install libopencv-dev python-opencv</span><br></pre></td></tr></table></figure>
<p>当然也可以通过官网下载源码编译安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 第一步先安装各种依赖</span><br><span class="line">&gt;&gt; sudo apt install build-essential</span><br><span class="line">&gt;&gt; sudo apt install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev</span><br><span class="line">&gt;&gt; sudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev</span><br><span class="line"></span><br><span class="line"># 然后找一个clone压缩包的文件夹，把源码拿下来：</span><br><span class="line">&gt;&gt; git clone https:&#x2F;&#x2F;link.zhihu.com&#x2F;?target&#x3D;https%3A&#x2F;&#x2F;github.com&#x2F;opencv&#x2F;opencv.git</span><br><span class="line"></span><br><span class="line"># 然后进入OpenCV文件夹：</span><br><span class="line">&gt;&gt; mkdir release</span><br><span class="line">&gt;&gt; cd release</span><br><span class="line">&gt;&gt; cmake -D  CMAKE_BUILD_TYPE&#x3D;RELEASE -D CMAKE_INSTALL_PREFIX&#x3D;&#x2F;usr&#x2F;local ..</span><br><span class="line"></span><br><span class="line"># 准备完毕，直接make并安装：</span><br><span class="line">&gt;&gt; make</span><br><span class="line">&gt;&gt; sudo make install</span><br></pre></td></tr></table></figure>
<p>pip 安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install opencv-python</span><br></pre></td></tr></table></figure>
<p>conda 安装，需要 python&lt;3.7</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install opencv3</span><br></pre></td></tr></table></figure>
<p>Windows下的安装也很简单，直接去OpenCV官网下载：</p>
<p><a href="https://link.zhihu.com/?target=http%3A//opencv.org/downloads.html">DOWNLOADS | OpenCV</a></p>
<p>执行exe安装后，会在&lt;安装目录&gt;/build/python/2.7下发现一个叫cv2.pyd的文件，把这个文件拷贝到<Python目录>\Lib\site-packages下，就可以了。</p>
<p>Windows下如果只想在Python中体验OpenCV还有个更简单的方法是加州大学尔湾分校（University of California, Irvine）的Christoph Gohlke制作的Windows下的Python科学计算包网页，下载对应版本的wheel文件，然后通过pip安装：</p>
<p><a href="https://link.zhihu.com/?target=http%3A//www.lfd.uci.edu/~gohlke/pythonlibs/%23opencv">http://www.lfd.uci.edu/~gohlke/pythonlibs/#opencv</a></p>
<p>Python中导入OpenCV非常简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import cv2</span><br></pre></td></tr></table></figure>
<p>就导入成功了。  </p>
<h2 id="1-2-Python-OpenCV基础"><a href="#1-2-Python-OpenCV基础" class="headerlink" title="1.2 Python-OpenCV基础"></a>1.2 Python-OpenCV基础</h2><h3 id="1-2-1-图像的表示"><a href="#1-2-1-图像的表示" class="headerlink" title="1.2.1 图像的表示"></a>1.2.1 图像的表示</h3><p>单通道的灰度图像在计算机中的表示是一个8位无符号整形的矩阵。</p>
<p>在OpenCV的C++代码中，表示图像有个专门的结构叫做cv::Mat，不过在Python-OpenCV中，因为已经有了numpy这种强大的基础工具，所以这个矩阵就用numpy的array表示。</p>
<p>如果是多通道情况，最常见的就是红绿蓝（RGB）三通道，则第一个维度是高度，第二个维度是宽度，第三个维度是通道，比如下图是一幅3×3图像在计算机中表示的例子：</p>
<p><img src="/img/opencv/1621223716-bf059619489b0c1a65e628fae34e0de2.png" alt=""></p>
<p>上图右上角的矩阵里每个元素都是一个3维数组，分别代表这个像素上的三个通道的值。最常见的RGB通道中，第一个元素就是红色（<strong>R</strong>ed）的值，第二个元素是绿色（<strong>G</strong>reen）的值，第三个元素是蓝色（<strong>B</strong>lue）。</p>
<p>RGB是最常见的情况，然而在OpenCV中，默认的图像的表示确实反过来的，也就是BGR。可以看到，前两行的颜色顺序都交换了，最后一行是三个通道等值的灰度图，所以没有影响。</p>
<p>至于OpenCV为什么不是人民群众喜闻乐见的RGB，这是历史遗留问题，在OpenCV刚开始研发的年代，BGR是相机设备厂商的主流表示方法，虽然后来RGB成了主流和默认，但是这个底层的顺序却保留下来了，事实上Windows下的最常见格式之一bmp，底层字节的存储顺序还是BGR。</p>
<p>OpenCV的这个特殊之处还是需要注意的，比如在Python中，图像都是用numpy的array表示，但是同样的array在OpenCV中的显示效果和matplotlib中的显示效果就会不一样。下面的简单代码就可以生成两种表示方式下，矩阵的对应的图像，生成图像后，放大看就能体会到区别：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 图6-1中的矩阵</span></span><br><span class="line">img = np.array([</span><br><span class="line">    [[<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>]],</span><br><span class="line">    [[<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>], [<span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>], [<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>]],</span><br><span class="line">    [[<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>], [<span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]],</span><br><span class="line">], dtype=np.uint8)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用matplotlib存储</span></span><br><span class="line">plt.imsave(<span class="string">'img_pyplot.jpg'</span>, img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用OpenCV存储</span></span><br><span class="line">cv2.imwrite(<span class="string">'img_cv2.jpg'</span>, img)</span><br></pre></td></tr></table></figure>
<p>不管是RGB还是BGR，都是高度×宽度×通道数，H×W×C的表达方式，而在深度学习中，因为要对不同通道应用卷积，所以用的是另一种方式：C×H×W，就是把每个通道都单独表达成一个二维矩阵，如上图左上角所示。</p>
<h3 id="1-2-2-基本图像处理"><a href="#1-2-2-基本图像处理" class="headerlink" title="1.2.2 基本图像处理"></a>1.2.2 基本图像处理</h3><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">"D:\\cat.jpg"</span>)  <span class="comment"># OpenCV目前支持读取bmp、jpg、png、tiff等常用格式。更详细的请参考OpenCV的参考文档。</span></span><br><span class="line">emptyImage2 = img.copy()  <span class="comment"># 复制图片</span></span><br><span class="line">emptyImage3=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)  <span class="comment"># 如果不怕麻烦，还可以用cvtColor获得原图像的副本。</span></span><br><span class="line"></span><br><span class="line">cv2.namedWindow(<span class="string">"Image"</span>)  <span class="comment"># 创建一个窗口</span></span><br><span class="line">cv2.imshow(<span class="string">"Image"</span>, img)  <span class="comment"># 在窗口中显示图像</span></span><br><span class="line">cv2.waitKey (<span class="number">0</span>)           <span class="comment"># 如果不添这一句，在IDLE中执行窗口直接无响应。在命令行中执行的话，则是一闪而过</span></span><br><span class="line">cv2.destroyAllWindows()   <span class="comment"># 释放窗口</span></span><br></pre></td></tr></table></figure>
<h4 id="存取图像"><a href="#存取图像" class="headerlink" title="存取图像"></a>存取图像</h4><p>读图像用cv2.imread()，可以按照不同模式读取，一般最常用到的是读取单通道灰度图，或者直接默认读取多通道。</p>
<p>存图像用cv2.imwrite()，注意存的时候是没有单通道这一说的，根据保存文件名的后缀和当前的array维度，OpenCV自动判断存的通道，另外压缩格式还可以指定存储质量，来看代码例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取一张400x600分辨率的图像</span></span><br><span class="line">color_img = cv2.imread(<span class="string">'test_400x600.jpg'</span>)</span><br><span class="line">print(color_img.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接读取单通道</span></span><br><span class="line">gray_img = cv2.imread(<span class="string">'test_400x600.jpg'</span>, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">print(gray_img.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把单通道图片保存后，再读取，仍然是3通道，相当于把单通道值复制到3个通道保存</span></span><br><span class="line">cv2.imwrite(<span class="string">'test_grayscale.jpg'</span>, gray_img)</span><br><span class="line">reload_grayscale = cv2.imread(<span class="string">'test_grayscale.jpg'</span>)</span><br><span class="line">print(reload_grayscale.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># cv2.IMWRITE_JPEG_QUALITY指定jpg质量，范围0到100，默认95，越高画质越好，文件越大</span></span><br><span class="line">cv2.imwrite(<span class="string">'test_imwrite.jpg'</span>, color_img, (cv2.IMWRITE_JPEG_QUALITY, <span class="number">80</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># cv2.IMWRITE_PNG_COMPRESSION指定png质量，范围0到9，默认3，越高文件越小，画质越差</span></span><br><span class="line">cv2.imwrite(<span class="string">'test_imwrite.png'</span>, color_img, (cv2.IMWRITE_PNG_COMPRESSION, <span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<h4 id="缩放，裁剪和补边"><a href="#缩放，裁剪和补边" class="headerlink" title="缩放，裁剪和补边"></a>缩放，裁剪和补边</h4><p>缩放通过cv2.resize()实现，裁剪则是利用array自身的下标截取实现，此外OpenCV还可以给图像补边，这样能对一幅图像的形状和感兴趣区域实现各种操作。下面的例子中读取一幅400×600分辨率的图片，并执行一些基础的操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取一张四川大录古藏寨的照片</span></span><br><span class="line">img = cv2.imread(<span class="string">'tiger_tibet_village.jpg'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 缩放成200x200的方形图像</span></span><br><span class="line">img_200x200 = cv2.resize(img, (<span class="number">200</span>, <span class="number">200</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不直接指定缩放后大小，通过fx和fy指定缩放比例，0.5则长宽都为原来一半</span></span><br><span class="line"><span class="comment"># 等效于img_200x300 = cv2.resize(img, (300, 200))，注意指定大小的格式是(宽度,高度)</span></span><br><span class="line"><span class="comment"># 插值方法默认是cv2.INTER_LINEAR，这里指定为最近邻插值</span></span><br><span class="line">img_200x300 = cv2.resize(img, (<span class="number">0</span>, <span class="number">0</span>), fx=<span class="number">0.5</span>, fy=<span class="number">0.5</span>, </span><br><span class="line">                              interpolation=cv2.INTER_NEAREST)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在上张图片的基础上，上下各贴50像素的黑边，生成300x300的图像</span></span><br><span class="line">img_300x300 = cv2.copyMakeBorder(img, <span class="number">50</span>, <span class="number">50</span>, <span class="number">0</span>, <span class="number">0</span>, </span><br><span class="line">                                       cv2.BORDER_CONSTANT, </span><br><span class="line">                                       value=(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对照片进行剪裁</span></span><br><span class="line">patch_tree = img[<span class="number">20</span>:<span class="number">150</span>, <span class="number">-180</span>:<span class="number">-50</span>]</span><br><span class="line"></span><br><span class="line">cv2.imwrite(<span class="string">'cropped_tree.jpg'</span>, patch_tree)</span><br><span class="line">cv2.imwrite(<span class="string">'resized_200x200.jpg'</span>, img_200x200)</span><br><span class="line">cv2.imwrite(<span class="string">'resized_200x300.jpg'</span>, img_200x300)</span><br><span class="line">cv2.imwrite(<span class="string">'bordered_300x300.jpg'</span>, img_300x300)</span><br></pre></td></tr></table></figure>
<h4 id="色调，明暗，直方图和Gamma曲线"><a href="#色调，明暗，直方图和Gamma曲线" class="headerlink" title="色调，明暗，直方图和Gamma曲线"></a>色调，明暗，直方图和Gamma曲线</h4><p>除了区域，图像本身的属性操作也非常多，比如可以通过HSV空间对色调和明暗进行调节。</p>
<p>HSV空间是由美国的图形学专家A. R. Smith提出的一种颜色空间，HSV分别是色调（<strong>H</strong>ue），饱和度（<strong>S</strong>aturation）和明度（<strong>V</strong>alue）。在HSV空间中进行调节就避免了直接在RGB空间中调节时还需要考虑三个通道的相关性。</p>
<p>OpenCV中H的取值是[0, 180)，其他两个通道的取值都是[0, 256)，下面例子接着上面例子代码，通过HSV空间对图像进行调整：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'tiger_tibet_village.jpg'</span>)</span><br><span class="line"><span class="comment"># 通过cv2.cvtColor把图像从BGR转换到HSV</span></span><br><span class="line">img_hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)</span><br><span class="line"></span><br><span class="line"><span class="comment"># H空间中，绿色比黄色的值高一点，所以给每个像素+15，黄色的树叶就会变绿</span></span><br><span class="line">turn_green_hsv = img_hsv.copy()</span><br><span class="line">turn_green_hsv[:, :, <span class="number">0</span>] = (turn_green_hsv[:, :, <span class="number">0</span>]+<span class="number">15</span>) % <span class="number">180</span></span><br><span class="line">turn_green_img = cv2.cvtColor(turn_green_hsv, cv2.COLOR_HSV2BGR)</span><br><span class="line">cv2.imwrite(<span class="string">'turn_green.jpg'</span>, turn_green_img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 减小饱和度会让图像损失鲜艳，变得更灰</span></span><br><span class="line">colorless_hsv = img_hsv.copy()</span><br><span class="line">colorless_hsv[:, :, <span class="number">1</span>] = <span class="number">0.5</span> * colorless_hsv[:, :, <span class="number">1</span>]</span><br><span class="line">colorless_img = cv2.cvtColor(colorless_hsv, cv2.COLOR_HSV2BGR)</span><br><span class="line">cv2.imwrite(<span class="string">'colorless.jpg'</span>, colorless_img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 减小明度为原来一半</span></span><br><span class="line">darker_hsv = img_hsv.copy()</span><br><span class="line">darker_hsv[:, :, <span class="number">2</span>] = <span class="number">0.5</span> * darker_hsv[:, :, <span class="number">2</span>]</span><br><span class="line">darker_img = cv2.cvtColor(darker_hsv, cv2.COLOR_HSV2BGR)</span><br><span class="line">cv2.imwrite(<span class="string">'darker.jpg'</span>, darker_img)</span><br></pre></td></tr></table></figure>
<p>无论是HSV还是RGB，我们都较难一眼就对像素中值的分布有细致的了解，这时候就需要直方图。如果直方图中的成分过于靠近0或者255，可能就出现了暗部细节不足或者亮部细节丢失的情况。比如图1-2中，背景里的暗部细节是非常弱的。这个时候，一个常用方法是考虑用Gamma变换来提升暗部细节。Gamma变换是矫正相机直接成像和人眼感受图像差别的一种常用手段，简单来说就是通过非线性变换让图像从对曝光强度的线性响应变得更接近人眼感受到的响应。具体的定义和实现，还是接着上面代码中读取的图片，执行计算直方图和Gamma变换的代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'tiger_tibet_village.jpg'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分通道计算每个通道的直方图</span></span><br><span class="line">hist_b = cv2.calcHist([img], [<span class="number">0</span>], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">hist_g = cv2.calcHist([img], [<span class="number">1</span>], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">hist_r = cv2.calcHist([img], [<span class="number">2</span>], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义Gamma矫正的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gamma_trans</span><span class="params">(img, gamma)</span>:</span></span><br><span class="line">    <span class="comment"># 具体做法是先归一化到1，然后gamma作为指数值求出新的像素值再还原</span></span><br><span class="line">    gamma_table = [np.power(x/<span class="number">255.0</span>, gamma)*<span class="number">255.0</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">256</span>)]</span><br><span class="line">    gamma_table = np.round(np.array(gamma_table)).astype(np.uint8)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 实现这个映射用的是OpenCV的查表函数</span></span><br><span class="line">    <span class="keyword">return</span> cv2.LUT(img, gamma_table)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行Gamma矫正，小于1的值让暗部细节大量提升，同时亮部细节少量提升</span></span><br><span class="line">img_corrected = gamma_trans(img, <span class="number">0.5</span>)</span><br><span class="line">cv2.imwrite(<span class="string">'gamma_corrected.jpg'</span>, img_corrected)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分通道计算Gamma矫正后的直方图</span></span><br><span class="line">hist_b_corrected = cv2.calcHist([img_corrected], [<span class="number">0</span>], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">hist_g_corrected = cv2.calcHist([img_corrected], [<span class="number">1</span>], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">hist_r_corrected = cv2.calcHist([img_corrected], [<span class="number">2</span>], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将直方图进行可视化</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"></span><br><span class="line">fig = plt.figure()</span><br><span class="line"></span><br><span class="line">pix_hists = [</span><br><span class="line">    [hist_b, hist_g, hist_r],</span><br><span class="line">    [hist_b_corrected, hist_g_corrected, hist_r_corrected]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">pix_vals = range(<span class="number">256</span>)</span><br><span class="line"><span class="keyword">for</span> sub_plt, pix_hist <span class="keyword">in</span> zip([<span class="number">121</span>, <span class="number">122</span>], pix_hists):</span><br><span class="line">    ax = fig.add_subplot(sub_plt, projection=<span class="string">'3d'</span>)</span><br><span class="line">    <span class="keyword">for</span> c, z, channel_hist <span class="keyword">in</span> zip([<span class="string">'b'</span>, <span class="string">'g'</span>, <span class="string">'r'</span>], [<span class="number">20</span>, <span class="number">10</span>, <span class="number">0</span>], pix_hist):</span><br><span class="line">        cs = [c] * <span class="number">256</span></span><br><span class="line">        ax.bar(pix_vals, channel_hist, zs=z, zdir=<span class="string">'y'</span>, color=cs, alpha=<span class="number">0.618</span>, edgecolor=<span class="string">'none'</span>, lw=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    ax.set_xlabel(<span class="string">'Pixel Values'</span>)</span><br><span class="line">    ax.set_xlim([<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">    ax.set_ylabel(<span class="string">'Channels'</span>)</span><br><span class="line">    ax.set_zlabel(<span class="string">'Counts'</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>上面三段代码的结果统一放在下图中：</p>
<p><img src="/img/opencv/1621223716-f16f167938c4ee5a002457239132276b.png" alt="图1-2"></p>
<p>可以看到，Gamma变换后的暗部细节比起原图清楚了很多，并且从直方图来看，像素值也从集中在0附近变得散开了一些。</p>
<h3 id="1-2-3-图像的仿射变换"><a href="#1-2-3-图像的仿射变换" class="headerlink" title="1.2.3 图像的仿射变换"></a>1.2.3 图像的仿射变换</h3><p>图像的仿射变换涉及到图像的形状位置角度的变化，是深度学习预处理中常到的功能，在此简单回顾一下。</p>
<p>仿射变换具体到图像中的应用，主要是对图像的<strong>缩放</strong>，<strong>旋转</strong>，<strong>剪切</strong>，<strong>翻转</strong>和<strong>平移</strong>的组合。在OpenCV中，仿射变换的矩阵是一个2×3的矩阵，其中左边的2×2子矩阵是线性变换矩阵，右边的2×1的两项是平移项：</p>
<p><img src="/img/opencv/1621223716-253dedcbcf9e36b34b466b3bbe1c384f.svg" alt="[公式]"></p>
<p><img src="/img/opencv/1621223716-83deb1504ee3a7ae785f5060d54d6e64.svg" alt="[公式]"></p>
<p>对于图像上的任一位置(x,y)，仿射变换执行的是如下的操作：</p>
<p><img src="/img/opencv/1621223716-7f0af9f246255cd5815d4ce1afe15a51.svg" alt="[公式]"></p>
<p>需要注意的是，对于图像而言，宽度方向是x，高度方向是y，坐标的顺序和图像像素对应下标一致。所以原点的位置不是左下角而是右上角，y的方向也不是向上，而是向下。</p>
<p>在OpenCV中实现仿射变换是通过仿射变换矩阵和cv2.warpAffine()这个函数，还是通过代码来理解一下，例子中图片的分辨率为600×400：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取一张斯里兰卡拍摄的大象照片</span></span><br><span class="line">img = cv2.imread(<span class="string">'lanka_safari.jpg'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 沿着横纵轴放大1.6倍，然后平移(-150,-240)，最后沿原图大小截取，等效于裁剪并放大</span></span><br><span class="line">M_crop_elephant = np.array([</span><br><span class="line">    [<span class="number">1.6</span>, <span class="number">0</span>, <span class="number">-150</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">1.6</span>, <span class="number">-240</span>]</span><br><span class="line">], dtype=np.float32)</span><br><span class="line"></span><br><span class="line">img_elephant = cv2.warpAffine(img, M_crop_elephant, (<span class="number">400</span>, <span class="number">600</span>))</span><br><span class="line">cv2.imwrite(<span class="string">'lanka_elephant.jpg'</span>, img_elephant)</span><br><span class="line"></span><br><span class="line"><span class="comment"># x轴的剪切变换，角度15°</span></span><br><span class="line">theta = <span class="number">15</span> * np.pi / <span class="number">180</span></span><br><span class="line">M_shear = np.array([</span><br><span class="line">    [<span class="number">1</span>, np.tan(theta), <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">], dtype=np.float32)</span><br><span class="line"></span><br><span class="line">img_sheared = cv2.warpAffine(img, M_shear, (<span class="number">400</span>, <span class="number">600</span>))</span><br><span class="line">cv2.imwrite(<span class="string">'lanka_safari_sheared.jpg'</span>, img_sheared)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顺时针旋转，角度15°</span></span><br><span class="line">M_rotate = np.array([</span><br><span class="line">    [np.cos(theta), -np.sin(theta), <span class="number">0</span>],</span><br><span class="line">    [np.sin(theta), np.cos(theta), <span class="number">0</span>]</span><br><span class="line">], dtype=np.float32)</span><br><span class="line"></span><br><span class="line">img_rotated = cv2.warpAffine(img, M_rotate, (<span class="number">400</span>, <span class="number">600</span>))</span><br><span class="line">cv2.imwrite(<span class="string">'lanka_safari_rotated.jpg'</span>, img_rotated)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 某种变换，具体旋转+缩放+旋转组合可以通过SVD分解理解</span></span><br><span class="line">M = np.array([</span><br><span class="line">    [<span class="number">1</span>, <span class="number">1.5</span>, <span class="number">-400</span>],</span><br><span class="line">    [<span class="number">0.5</span>, <span class="number">2</span>, <span class="number">-100</span>]</span><br><span class="line">], dtype=np.float32)</span><br><span class="line"></span><br><span class="line">img_transformed = cv2.warpAffine(img, M, (<span class="number">400</span>, <span class="number">600</span>))</span><br><span class="line">cv2.imwrite(<span class="string">'lanka_safari_transformed.jpg'</span>, img_transformed)</span><br></pre></td></tr></table></figure>
<p>代码实现的操作示意在下图中：</p>
<p><img src="/img/opencv/1621223716-ea141375713c01665be441b371001620.png" alt=""></p>
<h3 id="1-2-4-基本绘图"><a href="#1-2-4-基本绘图" class="headerlink" title="1.2.4 基本绘图"></a>1.2.4 基本绘图</h3><p>OpenCV提供了各种绘图的函数，可以在画面上绘制线段，圆，矩形和多边形等，还可以在图像上指定位置打印文字，比如下面例子：  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一块宽600，高400的画布，初始化为白色</span></span><br><span class="line">canvas = np.zeros((<span class="number">400</span>, <span class="number">600</span>, <span class="number">3</span>), dtype=np.uint8) + <span class="number">255</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 画一条纵向的正中央的黑色分界线</span></span><br><span class="line">cv2.line(canvas, (<span class="number">300</span>, <span class="number">0</span>), (<span class="number">300</span>, <span class="number">399</span>), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画一条右半部份画面以150为界的横向分界线</span></span><br><span class="line">cv2.line(canvas, (<span class="number">300</span>, <span class="number">149</span>), (<span class="number">599</span>, <span class="number">149</span>), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 左半部分的右下角画个红色的圆</span></span><br><span class="line">cv2.circle(canvas, (<span class="number">200</span>, <span class="number">300</span>), <span class="number">75</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 左半部分的左下角画个蓝色的矩形</span></span><br><span class="line">cv2.rectangle(canvas, (<span class="number">20</span>, <span class="number">240</span>), (<span class="number">100</span>, <span class="number">360</span>), (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), thickness=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义两个三角形，并执行内部绿色填充</span></span><br><span class="line">triangles = np.array([</span><br><span class="line">    [(<span class="number">200</span>, <span class="number">240</span>), (<span class="number">145</span>, <span class="number">333</span>), (<span class="number">255</span>, <span class="number">333</span>)],</span><br><span class="line">    [(<span class="number">60</span>, <span class="number">180</span>), (<span class="number">20</span>, <span class="number">237</span>), (<span class="number">100</span>, <span class="number">237</span>)]])</span><br><span class="line">cv2.fillPoly(canvas, triangles, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画一个黄色五角星</span></span><br><span class="line"><span class="comment"># 第一步通过旋转角度的办法求出五个顶点</span></span><br><span class="line">phi = <span class="number">4</span> * np.pi / <span class="number">5</span></span><br><span class="line">rotations = [[[np.cos(i * phi), -np.sin(i * phi)], [i * np.sin(phi), np.cos(i * phi)]] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">5</span>)]</span><br><span class="line">pentagram = np.array([[[[<span class="number">0</span>, <span class="number">-1</span>]] + [np.dot(m, (<span class="number">0</span>, <span class="number">-1</span>)) <span class="keyword">for</span> m <span class="keyword">in</span> rotations]]], dtype=np.float)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义缩放倍数和平移向量把五角星画在左半部分画面的上方</span></span><br><span class="line">pentagram = np.round(pentagram * <span class="number">80</span> + np.array([<span class="number">160</span>, <span class="number">120</span>])).astype(np.int)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将5个顶点作为多边形顶点连线，得到五角星</span></span><br><span class="line">cv2.polylines(canvas, pentagram, <span class="literal">True</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按像素为间隔从左至右在画面右半部份的上方画出HSV空间的色调连续变化</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">302</span>, <span class="number">600</span>):</span><br><span class="line">    color_pixel = np.array([[[round(<span class="number">180</span>*float(x<span class="number">-302</span>)/<span class="number">298</span>), <span class="number">255</span>, <span class="number">255</span>]]], dtype=np.uint8)</span><br><span class="line">    line_color = [int(c) <span class="keyword">for</span> c <span class="keyword">in</span> cv2.cvtColor(color_pixel, cv2.COLOR_HSV2BGR)[<span class="number">0</span>][<span class="number">0</span>]]</span><br><span class="line">    cv2.line(canvas, (x, <span class="number">0</span>), (x, <span class="number">147</span>), line_color)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果定义圆的线宽大于半斤，则等效于画圆点，随机在画面右下角的框内生成坐标</span></span><br><span class="line">np.random.seed(<span class="number">42</span>)</span><br><span class="line">n_pts = <span class="number">30</span></span><br><span class="line">pts_x = np.random.randint(<span class="number">310</span>, <span class="number">590</span>, n_pts)</span><br><span class="line">pts_y = np.random.randint(<span class="number">160</span>, <span class="number">390</span>, n_pts)</span><br><span class="line">pts = zip(pts_x, pts_y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画出每个点，颜色随机</span></span><br><span class="line"><span class="keyword">for</span> pt <span class="keyword">in</span> pts:</span><br><span class="line">    pt_color = [int(c) <span class="keyword">for</span> c <span class="keyword">in</span> np.random.randint(<span class="number">0</span>, <span class="number">255</span>, <span class="number">3</span>)]</span><br><span class="line">    cv2.circle(canvas, pt, <span class="number">3</span>, pt_color, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在左半部分最上方打印文字</span></span><br><span class="line">cv2.putText(canvas,</span><br><span class="line">            <span class="string">'Python-OpenCV Drawing Example'</span>,</span><br><span class="line">            (<span class="number">5</span>, <span class="number">15</span>),</span><br><span class="line">            cv2.FONT_HERSHEY_SIMPLEX,</span><br><span class="line">            <span class="number">0.5</span>,</span><br><span class="line">            (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">            <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">'Example of basic drawing functions'</span>, canvas)</span><br><span class="line">cv2.waitKey()</span><br></pre></td></tr></table></figure>
<p>执行这段代码得到如下的图像：  </p>
<p><img src="/img/opencv/1621223716-10a4c154b3b7573b6177e9a5aeea0968.png" alt=""></p>
<h2 id="1-2-5-视频功能"><a href="#1-2-5-视频功能" class="headerlink" title="1.2.5 视频功能"></a>1.2.5 视频功能</h2><p>视频中最常用的就是从视频设备采集图片或者视频，或者读取视频文件并从中采样。所以比较重要的也是两个模块，一个是VideoCapture，用于获取相机设备并捕获图像和视频，或是从文件中捕获。还有一个VideoWriter，用于生成视频。还是来看例子理解这两个功能的用法，首先是一个制作延时摄影视频的小例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">interval = <span class="number">60</span>       	<span class="comment"># 捕获图像的间隔，单位：秒</span></span><br><span class="line">num_frames = <span class="number">500</span>    	<span class="comment"># 捕获图像的总帧数</span></span><br><span class="line">out_fps = <span class="number">24</span>        	<span class="comment"># 输出文件的帧率</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># VideoCapture(0)表示打开默认的相机</span></span><br><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取捕获的分辨率</span></span><br><span class="line">size =(int(cap.get(cv2.CAP_PROP_FRAME_WIDTH)),</span><br><span class="line">       int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT)))</span><br><span class="line">       </span><br><span class="line"><span class="comment"># 设置要保存视频的编码，分辨率和帧率</span></span><br><span class="line">video = cv2.VideoWriter(</span><br><span class="line">    <span class="string">"time_lapse.avi"</span>, </span><br><span class="line">    cv2.VideoWriter_fourcc(<span class="string">'M'</span>,<span class="string">'P'</span>,<span class="string">'4'</span>,<span class="string">'2'</span>), </span><br><span class="line">    out_fps, </span><br><span class="line">    size</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于一些低画质的摄像头，前面的帧可能不稳定，略过</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">42</span>):</span><br><span class="line">    cap.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始捕获，通过read()函数获取捕获的帧</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num_frames):</span><br><span class="line">        _, frame = cap.read()</span><br><span class="line">        video.write(frame)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果希望把每一帧也存成文件，比如制作GIF，则取消下面的注释</span></span><br><span class="line">        <span class="comment"># filename = '&#123;:0&gt;6d&#125;.png'.format(i)</span></span><br><span class="line">        <span class="comment"># cv2.imwrite(filename, frame)</span></span><br><span class="line"></span><br><span class="line">        print(<span class="string">'Frame &#123;&#125; is captured.'</span>.format(i))</span><br><span class="line">        time.sleep(interval)</span><br><span class="line"><span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">    <span class="comment"># 提前停止捕获</span></span><br><span class="line">    print(<span class="string">'Stopped! &#123;&#125;/&#123;&#125; frames captured!'</span>.format(i, num_frames))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 释放资源并写入视频文件</span></span><br><span class="line">video.release()</span><br><span class="line">cap.release()</span><br></pre></td></tr></table></figure>
<p>这个例子实现了延时摄影的功能，把程序打开并将摄像头对准一些缓慢变化的画面，比如桌上缓慢蒸发的水，或者正在生长的小草，就能制作出有趣的延时摄影作品。比如下面这个链接中的图片就是用这段程序生成的：</p>
<p><a href="https://link.zhihu.com/?target=http%3A//images.cnitblog.com/blog2015/609274/201503/251904209276278.gif">http://images.cnitblog.com/blog2015/609274/201503/251904209276278.gif</a></p>
<p>程序的结构非常清晰简单，注释里也写清楚了每一步，所以流程就不解释了。需要提一下的有两点：一个是VideoWriter中的一个函数cv2.VideoWriter_fourcc()。这个函数指定了视频编码的格式，比如例子中用的是MP42，也就是MPEG-4，更多编码方式可以在下面的地址查询：</p>
<p><a href="https://link.zhihu.com/?target=http%3A//www.fourcc.org/codecs.php">Video Codecs by FOURCC</a></p>
<p>还有一个是KeyboardInterrupt，这是一个常用的异常，用来获取用户Ctrl+C的中止，捕获这个异常后直接结束循环并释放VideoCapture和VideoWriter的资源，使已经捕获好的部分视频可以顺利生成。</p>
<p>从视频中截取帧也是处理视频时常见的任务，下面代码实现的是遍历一个指定文件夹下的所有视频并按照指定的间隔进行截屏并保存：  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一个输入参数是包含视频片段的路径</span></span><br><span class="line">input_path = sys.argv[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二个输入参数是设定每隔多少帧截取一帧</span></span><br><span class="line">frame_interval = int(sys.argv[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出文件夹下所有的视频文件</span></span><br><span class="line">filenames = os.listdir(input_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取文件夹名称</span></span><br><span class="line">video_prefix = input_path.split(os.sep)[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立一个新的文件夹，名称为原文件夹名称后加上_frames</span></span><br><span class="line">frame_path = <span class="string">'&#123;&#125;_frames'</span>.format(input_path)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(frame_path):</span><br><span class="line">    os.mkdir(frame_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化一个VideoCapture对象</span></span><br><span class="line">cap = cv2.VideoCapture()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历所有文件</span></span><br><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> filenames:</span><br><span class="line">    filepath = os.sep.join([input_path, filename])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># VideoCapture::open函数可以从文件获取视频</span></span><br><span class="line">    cap.open(filepath)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取视频帧数</span></span><br><span class="line">    n_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 同样为了避免视频头几帧质量低下，黑屏或者无关等</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">42</span>):</span><br><span class="line">        cap.read()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n_frames):</span><br><span class="line">        ret, frame = cap.read()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 每隔frame_interval帧进行一次截屏操作</span></span><br><span class="line">        <span class="keyword">if</span> i % frame_interval == <span class="number">0</span>:</span><br><span class="line">            imagename = <span class="string">'&#123;&#125;_&#123;&#125;_&#123;:0&gt;6d&#125;.jpg'</span>.format(video_prefix, filename.split(<span class="string">'.'</span>)[<span class="number">0</span>], i)</span><br><span class="line">            imagepath = os.sep.join([frame_path, imagename])</span><br><span class="line">            print(<span class="string">'exported &#123;&#125;!'</span>.format(imagepath))</span><br><span class="line">            cv2.imwrite(imagepath, frame)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行结束释放资源</span></span><br><span class="line">cap.release()</span><br></pre></td></tr></table></figure>
<h2 id="6-3-用OpenCV实现数据增加小工具"><a href="#6-3-用OpenCV实现数据增加小工具" class="headerlink" title="6.3 用OpenCV实现数据增加小工具"></a>6.3 用OpenCV实现数据增加小工具</h2><p>到目前我们已经熟悉了numpy中的随机模块，多进程调用和OpenCV的基本操作，基于这些基础，本节将从思路到代码一步步实现一个最基本的数据增加小工具。</p>
<p>第三章和第四章都提到过数据增加（data augmentation），作为一种深度学习中的常用手段，数据增加对模型的泛化性和准确性都有帮助。数据增加的具体使用方式一般有两种，一种是实时增加，比如在Caffe中加入数据扰动层，每次图像都先经过扰动操作，再去训练，这样训练经过几代（epoch）之后，就等效于数据增加。还有一种是更加直接简单一些的，就是在训练之前就通过图像处理手段对数据样本进行扰动和增加，也就是本节要实现的。</p>
<p>这个例子中将包含三种基本类型的扰动：随机裁剪，随机旋转和随机颜色/明暗。</p>
<h2 id="6-3-1-随机裁剪"><a href="#6-3-1-随机裁剪" class="headerlink" title="6.3.1 随机裁剪"></a>6.3.1 随机裁剪</h2><p>AlexNet中已经讲过了随机裁剪的基本思路，我们的小例子中打算更进一步：在裁剪的时候考虑图像宽高比的扰动。在绝大多数用于分类的图片中，样本进入网络前都是要变为统一大小，所以宽高比扰动相当于对物体的横向和纵向进行了缩放，这样除了物体的位置扰动，又多出了一项扰动。只要变化范围控制合适，目标物体始终在画面内，这种扰动是有助于提升泛化性能的。实现这种裁剪的思路如下图所示：  </p>
<p><img src="/img/opencv/1621223716-255d4b823a09d82be60f3f16ced75caf.png" alt=""></p>
<p>图中最左边是一幅需要剪裁的画面，首先根据这幅画面我们可以算出一个宽高比w/h。然后设定一个小的扰动范围δ和要裁剪的画面占原画面的比例β，从-<img src="/img/opencv/1621223716-3a2a2988be0b89ac976cb6661a813ce0.svg" alt="[公式]">到<img src="/img/opencv/1621223716-3a2a2988be0b89ac976cb6661a813ce0.svg" alt="[公式]">之间按均匀采样，获取一个随机数<img src="/img/opencv/1621223716-2ac74f154261a9e383d221e8184250ee.svg" alt="[公式]">作为裁剪后画面的宽高比扰动的比例，则裁剪后画面的宽和高分别为：</p>
<p><img src="/img/opencv/1621223716-b38df31c19d566dda6d706d684fc84dc.svg" alt="[公式]"></p>
<p><img src="/img/opencv/1621223716-f53de8728cb333f889a3896cb81d897d.svg" alt="[公式]"></p>
<p>想象一下先把这个宽为w’，高为h’的区域置于原画面的右下角，则这个区域的左上角和原画面的左上角框出的小区域，如图中的虚线框所示，就是裁剪后区域左上角可以取值的范围。所以在这个区域内随机采一点作为裁剪区域的左上角，就实现了如图中位置随机，且宽高比也随机的裁剪。</p>
<h2 id="6-3-2-随机旋转"><a href="#6-3-2-随机旋转" class="headerlink" title="6.3.2 随机旋转"></a>6.3.2 随机旋转</h2><p>前面讲到过的旋转比起来，做数据增加时，一般希望旋转是沿着画面的中心。这样除了要知道旋转角度，还得计算平移的量才能让仿射变换的效果等效于旋转轴在画面中心，好在OpenCV中有现成的函数cv2.getRotationMatrix2D()可以使用。这个函数的第一个参数是旋转中心，第二个参数是逆时针旋转角度，第三个参数是缩放倍数，对于只是旋转的情况下这个值是1，返回值就是做仿射变换的矩阵。</p>
<p>直接用这个函数并接着使用cv2.warpAffine()会有一个潜在的问题，就是旋转之后会出现黑边。如果要旋转后的画面不包含黑边，就得沿着原来画面的轮廓做个内接矩形，该矩形的宽高比和原画面相同，如下图所示：  </p>
<p><img src="/img/opencv/1621223716-48cf5ce71521b9ccae94ddf9f87df391.png" alt=""></p>
<p>在图中，可以看到，限制内接矩形大小的主要是原画面更靠近中心的那条边，也就是图中比较长的一条边AB。因此我们只要沿着中心O和内接矩形的顶点方向的直线，求出和AB的交点P，就得到了内接矩形的大小。先来看长边的方程，考虑之前画面和横轴相交的点，经过角度-θ旋转后，到了图中的Q点所在：<br><img src="/img/opencv/1621223716-2ac198ce01fc763563797cb0b9d8664c.svg" alt="[公式]"></p>
<p>因为长边所在直线过Q点，且斜率为1/tan(θ)，所以有：  </p>
<p><img src="/img/opencv/1621223716-17be885a8ebc90308798e5f047282b60.svg" alt="[公式]"></p>
<p>这时候考虑OP这条直线：</p>
<p><img src="/img/opencv/1621223716-8b4414f2169eed54baea6ae0d1f286fd.svg" alt="[公式]"></p>
<p>把这个公式带入再前边一个公式，求解可以得到：</p>
<p><img src="/img/opencv/1621223716-b52c28052f4db75cbc906ac2e4f2d256.svg" alt="[公式]"></p>
<p>注意到在这个问题中，每个象限和相邻象限都是轴对称的，而且旋转角度对剪裁宽度和长度的影响是周期（T=π）变化，再加上我们关心的其实并不是四个点的位置，而是旋转后要截取的矩形的宽w’和高h’，所以复杂的分区间情况也简化了，首先对于旋转角度，因为周期为π，所以都可以化到0到π之间，然后因为对称性，进一步有：  </p>
<p><img src="/img/opencv/1621223716-8fd14bfde23d35f0178c24a40d5f86ac.svg" alt="[公式]"></p>
<p>于是对于0到π/2之间的θ，有：  </p>
<p><img src="/img/opencv/1621223716-98c2bd329ea1cfbf97e880a583af0aa4.svg" alt="[公式]"></p>
<p><img src="/img/opencv/1621223716-a7797fdc6274b26ddf7adacc6f134ba3.svg" alt="[公式]"></p>
<p><img src="/img/opencv/1621223716-f4a6bc97bef19d7bfd409565c5ba6e66.svg" alt="[公式]"></p>
<p><img src="/img/opencv/1621223716-fbd13ccdfb71fd86f44f19299f63241b.svg" alt="[公式]"></p>
<p>当然需要注意的是，对于宽高比非常大或者非常小的图片，旋转后如果裁剪往往得到的画面是非常小的一部分，甚至不包含目标物体。所以是否需要旋转，以及是否需要裁剪，如果裁剪角度多少合适，都要视情况而定。</p>
<h2 id="6-3-3-随机颜色和明暗"><a href="#6-3-3-随机颜色和明暗" class="headerlink" title="6.3.3 随机颜色和明暗"></a>6.3.3 随机颜色和明暗</h2><p>比起AlexNet论文里在PCA之后的主成分上做扰动的方法，本书用来实现随机的颜色以及明暗的方法相对简单很多，就是给HSV空间的每个通道，分别加上一个微小的扰动。其中对于色调，从-<img src="/img/opencv/1621223716-3a2a2988be0b89ac976cb6661a813ce0.svg" alt="[公式]">到<img src="/img/opencv/1621223716-3a2a2988be0b89ac976cb6661a813ce0.svg" alt="[公式]">之间按均匀采样，获取一个随机数<img src="/img/opencv/1621223716-2ac74f154261a9e383d221e8184250ee.svg" alt="[公式]">作为要扰动的值，然后新的像素值x’为原始像素值x +<img src="/img/opencv/1621223716-2ac74f154261a9e383d221e8184250ee.svg" alt="[公式]">；对于其他两个空间则是新像素值x’为原始像素值x的(1+<img src="/img/opencv/1621223716-2ac74f154261a9e383d221e8184250ee.svg" alt="[公式]">)倍，从而实现色调，饱和度和明暗度的扰动。</p>
<p>因为明暗度并不会对图像的直方图相对分布产生大的影响，所以在HSV扰动基础上，考虑再加入一个Gamma扰动，方法是设定一个大于1的Gamma值的上限γ，因为这个值通常会和1是一个量级，再用均匀采样的近似未必合适，所以从-logγ到logγ之间均匀采样一个值α，然后用<img src="/img/opencv/1621223716-65df056f74e04a2e5b7081e0da60e88e.svg" alt="[公式]"></p>
<p>作为Gamma值进行变换。</p>
<h3 id="6-3-4-多进程调用加速处理"><a href="#6-3-4-多进程调用加速处理" class="headerlink" title="6.3.4 多进程调用加速处理"></a>6.3.4 多进程调用加速处理</h3><p>做数据增加时如果样本量本身就不小，则处理起来可能会很耗费时间，所以可以考虑利用多进程并行处理。比如我们的例子中，设定使用场景是输入一个文件夹路径，该文件夹下包含了所有原始的数据样本。用户指定输出的文件夹和打算增加图片的总量。执行程序的时候，通过os.listdir()获取所有文件的路径，然后按照上一章讲过的多进程平均划分样本的办法，把文件尽可能均匀地分给不同进程，进行处理。</p>
<h3 id="6-3-5-代码：图片数据增加小工具"><a href="#6-3-5-代码：图片数据增加小工具" class="headerlink" title="6.3.5 代码：图片数据增加小工具"></a>6.3.5 代码：图片数据增加小工具</h3><p>按照前面4个部分的思路和方法，这节来实现这么一个图片数据增加小工具，首先对于一些基础的操作，我们定义在一个叫做image_augmentation.py的文件里：  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">定义裁剪函数，四个参数分别是：</span></span><br><span class="line"><span class="string">左上角横坐标x0</span></span><br><span class="line"><span class="string">左上角纵坐标y0</span></span><br><span class="line"><span class="string">裁剪宽度w</span></span><br><span class="line"><span class="string">裁剪高度h</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">crop_image = <span class="keyword">lambda</span> img, x0, y0, w, h: img[y0:y0+h, x0:x0+w]</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">随机裁剪</span></span><br><span class="line"><span class="string">area_ratio为裁剪画面占原画面的比例</span></span><br><span class="line"><span class="string">hw_vari是扰动占原高宽比的比例范围</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_crop</span><span class="params">(img, area_ratio, hw_vari)</span>:</span></span><br><span class="line">    h, w = img.shape[:<span class="number">2</span>]</span><br><span class="line">    hw_delta = np.random.uniform(-hw_vari, hw_vari)</span><br><span class="line">    hw_mult = <span class="number">1</span> + hw_delta</span><br><span class="line">	</span><br><span class="line">	<span class="comment"># 下标进行裁剪，宽高必须是正整数</span></span><br><span class="line">    w_crop = int(round(w*np.sqrt(area_ratio*hw_mult)))</span><br><span class="line">	</span><br><span class="line">	<span class="comment"># 裁剪宽度不可超过原图可裁剪宽度</span></span><br><span class="line">    <span class="keyword">if</span> w_crop &gt; w:</span><br><span class="line">        w_crop = w</span><br><span class="line">		</span><br><span class="line">    h_crop = int(round(h*np.sqrt(area_ratio/hw_mult)))</span><br><span class="line">    <span class="keyword">if</span> h_crop &gt; h:</span><br><span class="line">        h_crop = h</span><br><span class="line">	</span><br><span class="line">	<span class="comment"># 随机生成左上角的位置</span></span><br><span class="line">    x0 = np.random.randint(<span class="number">0</span>, w-w_crop+<span class="number">1</span>)</span><br><span class="line">    y0 = np.random.randint(<span class="number">0</span>, h-h_crop+<span class="number">1</span>)</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> crop_image(img, x0, y0, w_crop, h_crop)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">定义旋转函数：</span></span><br><span class="line"><span class="string">angle是逆时针旋转的角度</span></span><br><span class="line"><span class="string">crop是个布尔值，表明是否要裁剪去除黑边</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotate_image</span><span class="params">(img, angle, crop)</span>:</span></span><br><span class="line">    h, w = img.shape[:<span class="number">2</span>]</span><br><span class="line">	</span><br><span class="line">	<span class="comment"># 旋转角度的周期是360°</span></span><br><span class="line">    angle %= <span class="number">360</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment"># 用OpenCV内置函数计算仿射矩阵</span></span><br><span class="line">    M_rotate = cv2.getRotationMatrix2D((w/<span class="number">2</span>, h/<span class="number">2</span>), angle, <span class="number">1</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="comment"># 得到旋转后的图像</span></span><br><span class="line">    img_rotated = cv2.warpAffine(img, M_rotate, (w, h))</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 如果需要裁剪去除黑边</span></span><br><span class="line">    <span class="keyword">if</span> crop:</span><br><span class="line">	    <span class="comment"># 对于裁剪角度的等效周期是180°</span></span><br><span class="line">        angle_crop = angle % <span class="number">180</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment"># 并且关于90°对称</span></span><br><span class="line">        <span class="keyword">if</span> angle_crop &gt; <span class="number">90</span>:</span><br><span class="line">            angle_crop = <span class="number">180</span> - angle_crop</span><br><span class="line">			</span><br><span class="line">		<span class="comment"># 转化角度为弧度</span></span><br><span class="line">        theta = angle_crop * np.pi / <span class="number">180.0</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment"># 计算高宽比</span></span><br><span class="line">        hw_ratio = float(h) / float(w)</span><br><span class="line">		</span><br><span class="line">		<span class="comment"># 计算裁剪边长系数的分子项</span></span><br><span class="line">        tan_theta = np.tan(theta)</span><br><span class="line">        numerator = np.cos(theta) + np.sin(theta) * tan_theta</span><br><span class="line">		</span><br><span class="line">		<span class="comment"># 计算分母项中和宽高比相关的项</span></span><br><span class="line">        r = hw_ratio <span class="keyword">if</span> h &gt; w <span class="keyword">else</span> <span class="number">1</span> / hw_ratio</span><br><span class="line">		</span><br><span class="line">		<span class="comment"># 计算分母项</span></span><br><span class="line">        denominator = r * tan_theta + <span class="number">1</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment"># 计算最终的边长系数</span></span><br><span class="line">        crop_mult = numerator / denominator</span><br><span class="line">		</span><br><span class="line">		<span class="comment"># 得到裁剪区域</span></span><br><span class="line">        w_crop = int(round(crop_mult*w))</span><br><span class="line">        h_crop = int(round(crop_mult*h))</span><br><span class="line">        x0 = int((w-w_crop)/<span class="number">2</span>)</span><br><span class="line">        y0 = int((h-h_crop)/<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        img_rotated = crop_image(img_rotated, x0, y0, w_crop, h_crop)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> img_rotated</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">随机旋转</span></span><br><span class="line"><span class="string">angle_vari是旋转角度的范围[-angle_vari, angle_vari)</span></span><br><span class="line"><span class="string">p_crop是要进行去黑边裁剪的比例</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_rotate</span><span class="params">(img, angle_vari, p_crop)</span>:</span></span><br><span class="line">    angle = np.random.uniform(-angle_vari, angle_vari)</span><br><span class="line">    crop = <span class="literal">False</span> <span class="keyword">if</span> np.random.random() &gt; p_crop <span class="keyword">else</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> rotate_image(img, angle, crop)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">定义hsv变换函数：</span></span><br><span class="line"><span class="string">hue_delta是色调变化比例</span></span><br><span class="line"><span class="string">sat_delta是饱和度变化比例</span></span><br><span class="line"><span class="string">val_delta是明度变化比例</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hsv_transform</span><span class="params">(img, hue_delta, sat_mult, val_mult)</span>:</span></span><br><span class="line">    img_hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV).astype(np.float)</span><br><span class="line">    img_hsv[:, :, <span class="number">0</span>] = (img_hsv[:, :, <span class="number">0</span>] + hue_delta) % <span class="number">180</span></span><br><span class="line">    img_hsv[:, :, <span class="number">1</span>] *= sat_mult</span><br><span class="line">    img_hsv[:, :, <span class="number">2</span>] *= val_mult</span><br><span class="line">    img_hsv[img_hsv &gt; <span class="number">255</span>] = <span class="number">255</span></span><br><span class="line">    <span class="keyword">return</span> cv2.cvtColor(np.round(img_hsv).astype(np.uint8), cv2.COLOR_HSV2BGR)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">随机hsv变换</span></span><br><span class="line"><span class="string">hue_vari是色调变化比例的范围</span></span><br><span class="line"><span class="string">sat_vari是饱和度变化比例的范围</span></span><br><span class="line"><span class="string">val_vari是明度变化比例的范围</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_hsv_transform</span><span class="params">(img, hue_vari, sat_vari, val_vari)</span>:</span></span><br><span class="line">    hue_delta = np.random.randint(-hue_vari, hue_vari)</span><br><span class="line">    sat_mult = <span class="number">1</span> + np.random.uniform(-sat_vari, sat_vari)</span><br><span class="line">    val_mult = <span class="number">1</span> + np.random.uniform(-val_vari, val_vari)</span><br><span class="line">    <span class="keyword">return</span> hsv_transform(img, hue_delta, sat_mult, val_mult)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">定义gamma变换函数：</span></span><br><span class="line"><span class="string">gamma就是Gamma</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gamma_transform</span><span class="params">(img, gamma)</span>:</span></span><br><span class="line">    gamma_table = [np.power(x / <span class="number">255.0</span>, gamma) * <span class="number">255.0</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">256</span>)]</span><br><span class="line">    gamma_table = np.round(np.array(gamma_table)).astype(np.uint8)</span><br><span class="line">    <span class="keyword">return</span> cv2.LUT(img, gamma_table)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">随机gamma变换</span></span><br><span class="line"><span class="string">gamma_vari是Gamma变化的范围[1/gamma_vari, gamma_vari)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_gamma_transform</span><span class="params">(img, gamma_vari)</span>:</span></span><br><span class="line">    log_gamma_vari = np.log(gamma_vari)</span><br><span class="line">    alpha = np.random.uniform(-log_gamma_vari, log_gamma_vari)</span><br><span class="line">    gamma = np.exp(alpha)</span><br><span class="line">    <span class="keyword">return</span> gamma_transform(img, gamma)</span><br></pre></td></tr></table></figure>
<p>调用这些函数需要通过一个主程序。这个主程序里首先定义三个子模块，定义一个函数parse_arg()通过Python的argparse模块定义了各种输入参数和默认值。需要注意的是这里用argparse来输入所有参数是因为参数总量并不是特别多，如果增加了更多的扰动方法，更合适的参数输入方式可能是通过一个配置文件。然后定义一个生成待处理图像列表的函数generate_image_list()，根据输入中要增加图片的数量和并行进程的数目尽可能均匀地为每个进程生成了需要处理的任务列表。执行随机扰动的代码定义在augment_images()中，这个函数是每个进程内进行实际处理的函数，执行顺序是镜像<img src="/img/opencv/1621223716-2bb97056aaed2265ded7349caef197b1.svg" alt="[公式]">裁剪<img src="/img/opencv/1621223716-2bb97056aaed2265ded7349caef197b1.svg" alt="[公式]">旋转<img src="/img/opencv/1621223716-2bb97056aaed2265ded7349caef197b1.svg" alt="[公式]">HSV<img src="/img/opencv/1621223716-2bb97056aaed2265ded7349caef197b1.svg" alt="[公式]">Gamma。需要注意的是镜像<img src="/img/opencv/1621223716-2bb97056aaed2265ded7349caef197b1.svg" alt="[公式]">裁剪，因为只是个演示例子，这未必是一个合适的顺序。最后定义一个main函数进行调用，代码如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">import argparse</span><br><span class="line">import random</span><br><span class="line">import math</span><br><span class="line">from multiprocessing import Process</span><br><span class="line">from multiprocessing import cpu_count</span><br><span class="line"></span><br><span class="line">import cv2</span><br><span class="line"></span><br><span class="line"># 导入image_augmentation.py为一个可调用模块</span><br><span class="line">import image_augmentation as ia</span><br><span class="line"></span><br><span class="line"># 利用Python的argparse模块读取输入输出和各种扰动参数</span><br><span class="line">def parse_args():</span><br><span class="line">    parser &#x3D; argparse.ArgumentParser(</span><br><span class="line">        description&#x3D;&#39;A Simple Image Data Augmentation Tool&#39;,</span><br><span class="line">        formatter_class&#x3D;argparse.ArgumentDefaultsHelpFormatter)</span><br><span class="line"></span><br><span class="line">    parser.add_argument(&#39;input_dir&#39;,</span><br><span class="line">                        help&#x3D;&#39;Directory containing images&#39;)</span><br><span class="line">    parser.add_argument(&#39;output_dir&#39;,</span><br><span class="line">                        help&#x3D;&#39;Directory for augmented images&#39;)</span><br><span class="line">    parser.add_argument(&#39;num&#39;,</span><br><span class="line">                        help&#x3D;&#39;Number of images to be augmented&#39;,</span><br><span class="line">                        type&#x3D;int)</span><br><span class="line"></span><br><span class="line">    parser.add_argument(&#39;--num_procs&#39;,</span><br><span class="line">                        help&#x3D;&#39;Number of processes for paralleled augmentation&#39;,</span><br><span class="line">                        type&#x3D;int, default&#x3D;cpu_count())</span><br><span class="line"></span><br><span class="line">    parser.add_argument(&#39;--p_mirror&#39;,</span><br><span class="line">                        help&#x3D;&#39;Ratio to mirror an image&#39;,</span><br><span class="line">                        type&#x3D;float, default&#x3D;0.5)</span><br><span class="line"></span><br><span class="line">    parser.add_argument(&#39;--p_crop&#39;,</span><br><span class="line">                        help&#x3D;&#39;Ratio to randomly crop an image&#39;,</span><br><span class="line">                        type&#x3D;float, default&#x3D;1.0)</span><br><span class="line">    parser.add_argument(&#39;--crop_size&#39;,</span><br><span class="line">                        help&#x3D;&#39;The ratio of cropped image size to original image size, in area&#39;,</span><br><span class="line">                        type&#x3D;float, default&#x3D;0.8)</span><br><span class="line">    parser.add_argument(&#39;--crop_hw_vari&#39;,</span><br><span class="line">                        help&#x3D;&#39;Variation of h&#x2F;w ratio&#39;,</span><br><span class="line">                        type&#x3D;float, default&#x3D;0.1)</span><br><span class="line"></span><br><span class="line">    parser.add_argument(&#39;--p_rotate&#39;,</span><br><span class="line">                        help&#x3D;&#39;Ratio to randomly rotate an image&#39;,</span><br><span class="line">                        type&#x3D;float, default&#x3D;1.0)</span><br><span class="line">    parser.add_argument(&#39;--p_rotate_crop&#39;,</span><br><span class="line">                        help&#x3D;&#39;Ratio to crop out the empty part in a rotated image&#39;,</span><br><span class="line">                        type&#x3D;float, default&#x3D;1.0)</span><br><span class="line">    parser.add_argument(&#39;--rotate_angle_vari&#39;,</span><br><span class="line">                        help&#x3D;&#39;Variation range of rotate angle&#39;,</span><br><span class="line">                        type&#x3D;float, default&#x3D;10.0)</span><br><span class="line"></span><br><span class="line">    parser.add_argument(&#39;--p_hsv&#39;,</span><br><span class="line">                        help&#x3D;&#39;Ratio to randomly change gamma of an image&#39;,</span><br><span class="line">                        type&#x3D;float, default&#x3D;1.0)</span><br><span class="line">    parser.add_argument(&#39;--hue_vari&#39;,</span><br><span class="line">                        help&#x3D;&#39;Variation of hue&#39;,</span><br><span class="line">                        type&#x3D;int, default&#x3D;10)</span><br><span class="line">    parser.add_argument(&#39;--sat_vari&#39;,</span><br><span class="line">                        help&#x3D;&#39;Variation of saturation&#39;,</span><br><span class="line">                        type&#x3D;float, default&#x3D;0.1)</span><br><span class="line">    parser.add_argument(&#39;--val_vari&#39;,</span><br><span class="line">                        help&#x3D;&#39;Variation of value&#39;,</span><br><span class="line">                        type&#x3D;float, default&#x3D;0.1)</span><br><span class="line"></span><br><span class="line">    parser.add_argument(&#39;--p_gamma&#39;,</span><br><span class="line">                        help&#x3D;&#39;Ratio to randomly change gamma of an image&#39;,</span><br><span class="line">                        type&#x3D;float, default&#x3D;1.0)</span><br><span class="line">    parser.add_argument(&#39;--gamma_vari&#39;,</span><br><span class="line">                        help&#x3D;&#39;Variation of gamma&#39;,</span><br><span class="line">                        type&#x3D;float, default&#x3D;2.0)</span><br><span class="line"></span><br><span class="line">    args &#x3D; parser.parse_args()</span><br><span class="line">    args.input_dir &#x3D; args.input_dir.rstrip(&#39;&#x2F;&#39;)</span><br><span class="line">    args.output_dir &#x3D; args.output_dir.rstrip(&#39;&#x2F;&#39;)</span><br><span class="line"></span><br><span class="line">    return args</span><br><span class="line"></span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">根据进程数和要增加的目标图片数，</span><br><span class="line">生成每个进程要处理的文件列表和每个文件要增加的数目</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">def generate_image_list(args):</span><br><span class="line">    # 获取所有文件名和文件总数</span><br><span class="line">    filenames &#x3D; os.listdir(args.input_dir)</span><br><span class="line">    num_imgs &#x3D; len(filenames)</span><br><span class="line"></span><br><span class="line">	# 计算平均处理的数目并向下取整</span><br><span class="line">    num_ave_aug &#x3D; int(math.floor(args.num&#x2F;num_imgs))</span><br><span class="line">	</span><br><span class="line">	# 剩下的部分不足平均分配到每一个文件，所以做成一个随机幸运列表</span><br><span class="line">	# 对于幸运的文件就多增加一个，凑够指定的数目</span><br><span class="line">    rem &#x3D; args.num - num_ave_aug*num_imgs</span><br><span class="line">    lucky_seq &#x3D; [True]*rem + [False]*(num_imgs-rem)</span><br><span class="line">    random.shuffle(lucky_seq)</span><br><span class="line"></span><br><span class="line">	# 根据平均分配和幸运表策略，</span><br><span class="line">	# 生成每个文件的全路径和对应要增加的数目并放到一个list里</span><br><span class="line">    img_list &#x3D; [</span><br><span class="line">        (os.sep.join([args.input_dir, filename]), num_ave_aug+1 if lucky else num_ave_aug)</span><br><span class="line">        for filename, lucky in zip(filenames, lucky_seq)</span><br><span class="line">    ]</span><br><span class="line">	</span><br><span class="line">	# 文件可能大小不一，处理时间也不一样，</span><br><span class="line">	# 所以随机打乱，尽可能保证处理时间均匀</span><br><span class="line">    random.shuffle(img_list)</span><br><span class="line"></span><br><span class="line">	# 生成每个进程的文件列表，</span><br><span class="line">	# 尽可能均匀地划分每个进程要处理的数目</span><br><span class="line">    length &#x3D; float(num_imgs) &#x2F; float(args.num_procs)</span><br><span class="line">    indices &#x3D; [int(round(i * length)) for i in range(args.num_procs + 1)]</span><br><span class="line">    return [img_list[indices[i]:indices[i + 1]] for i in range(args.num_procs)]</span><br><span class="line"></span><br><span class="line"># 每个进程内调用图像处理函数进行扰动的函数</span><br><span class="line">def augment_images(filelist, args):</span><br><span class="line">    # 遍历所有列表内的文件</span><br><span class="line">    for filepath, n in filelist:</span><br><span class="line">        img &#x3D; cv2.imread(filepath)</span><br><span class="line">        filename &#x3D; filepath.split(os.sep)[-1]</span><br><span class="line">        dot_pos &#x3D; filename.rfind(&#39;.&#39;)</span><br><span class="line">		</span><br><span class="line">		# 获取文件名和后缀名</span><br><span class="line">        imgname &#x3D; filename[:dot_pos]</span><br><span class="line">        ext &#x3D; filename[dot_pos:]</span><br><span class="line"></span><br><span class="line">        print(&#39;Augmenting &#123;&#125; ...&#39;.format(filename))</span><br><span class="line">        for i in range(n):</span><br><span class="line">            img_varied &#x3D; img.copy()</span><br><span class="line">			</span><br><span class="line">			# 扰动后文件名的前缀</span><br><span class="line">            varied_imgname &#x3D; &#39;&#123;&#125;_&#123;:0&gt;3d&#125;_&#39;.format(imgname, i)</span><br><span class="line">			</span><br><span class="line">			# 按照比例随机对图像进行镜像</span><br><span class="line">            if random.random() &lt; args.p_mirror:</span><br><span class="line">			    # 利用numpy.fliplr(img_varied)也能实现</span><br><span class="line">                img_varied &#x3D; cv2.flip(img_varied, 1)</span><br><span class="line">                varied_imgname +&#x3D; &#39;m&#39;</span><br><span class="line">			</span><br><span class="line">			# 按照比例随机对图像进行裁剪</span><br><span class="line">            if random.random() &lt; args.p_crop:</span><br><span class="line">                img_varied &#x3D; ia.random_crop(</span><br><span class="line">                    img_varied,</span><br><span class="line">                    args.crop_size,</span><br><span class="line">                    args.crop_hw_vari)</span><br><span class="line">                varied_imgname +&#x3D; &#39;c&#39;</span><br><span class="line">			</span><br><span class="line">			# 按照比例随机对图像进行旋转</span><br><span class="line">            if random.random() &lt; args.p_rotate:</span><br><span class="line">                img_varied &#x3D; ia.random_rotate(</span><br><span class="line">                    img_varied,</span><br><span class="line">                    args.rotate_angle_vari,</span><br><span class="line">                    args.p_rotate_crop)</span><br><span class="line">                varied_imgname +&#x3D; &#39;r&#39;</span><br><span class="line">			</span><br><span class="line">			# 按照比例随机对图像进行HSV扰动</span><br><span class="line">            if random.random() &lt; args.p_hsv:</span><br><span class="line">                img_varied &#x3D; ia.random_hsv_transform(</span><br><span class="line">                    img_varied,</span><br><span class="line">                    args.hue_vari,</span><br><span class="line">                    args.sat_vari,</span><br><span class="line">                    args.val_vari)</span><br><span class="line">                varied_imgname +&#x3D; &#39;h&#39;</span><br><span class="line">			</span><br><span class="line">			# 按照比例随机对图像进行Gamma扰动</span><br><span class="line">            if random.random() &lt; args.p_gamma:</span><br><span class="line">                img_varied &#x3D; ia.random_gamma_transform(</span><br><span class="line">                    img_varied,</span><br><span class="line">                    args.gamma_vari)</span><br><span class="line">                varied_imgname +&#x3D; &#39;g&#39;</span><br><span class="line">			</span><br><span class="line">			# 生成扰动后的文件名并保存在指定的路径</span><br><span class="line">            output_filepath &#x3D; os.sep.join([</span><br><span class="line">                args.output_dir,</span><br><span class="line">                &#39;&#123;&#125;&#123;&#125;&#39;.format(varied_imgname, ext)])</span><br><span class="line">            cv2.imwrite(output_filepath, img_varied)</span><br><span class="line"></span><br><span class="line"># 主函数</span><br><span class="line">def main():</span><br><span class="line">    # 获取输入输出和变换选项</span><br><span class="line">    args &#x3D; parse_args()</span><br><span class="line">    params_str &#x3D; str(args)[10:-1]</span><br><span class="line"></span><br><span class="line">	# 如果输出文件夹不存在，则建立文件夹</span><br><span class="line">    if not os.path.exists(args.output_dir):</span><br><span class="line">        os.mkdir(args.output_dir)</span><br><span class="line"></span><br><span class="line">    print(&#39;Starting image data augmentation for &#123;&#125;\n&#39;</span><br><span class="line">          &#39;with\n&#123;&#125;\n&#39;.format(args.input_dir, params_str))</span><br><span class="line"></span><br><span class="line">	# 生成每个进程要处理的列表</span><br><span class="line">    sublists &#x3D; generate_image_list(args)</span><br><span class="line">	</span><br><span class="line">	# 创建进程</span><br><span class="line">    processes &#x3D; [Process(target&#x3D;augment_images, args&#x3D;(x, args, )) for x in sublists]</span><br><span class="line"></span><br><span class="line">	# 并行多进程处理</span><br><span class="line">    for p in processes:</span><br><span class="line">        p.start()</span><br><span class="line"></span><br><span class="line">    for p in processes:</span><br><span class="line">        p.join()</span><br><span class="line"></span><br><span class="line">    print(&#39;\nDone!&#39;)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>为了排版方便，并没有很遵守Python的规范（PEP8）。注意到除了前面提的三种类型的变化，还增加了镜像变化，这主要是因为这种变换太简单了，顺手就写上了。还有默认进程数用的是cpu_count()函数，这个获取的是cpu的核数。把这段代码保存为run_augmentation.py，然后在命令行输入：</p>
<p>>&gt; python run_augmentation.py -h   </p>
<p>或者</p>
<p>>&gt; python run_augmentation.py —help  </p>
<p>就能看到脚本的使用方法，每个参数的含义，还有默认值。接下里来执行一个图片增加任务：</p>
<p>>&gt; python run_augmentation.py imagenet_samples more_samples 1000 —rotate_angle_vari 180 —p_rotate_crop 0.5  </p>
<p>其中imagenet_samples为一些从imagenet图片url中随机下载的一些图片，—rotate_angle_vari设为180方便测试全方向的旋转，—p_rotate_crop设置为0.5，让旋转裁剪对一半图片生效。扰动增加后的1000张图片在more_samples文件夹下，得到的部分结果如下：</p>
<p><img src="/img/opencv/1621223716-54ad7b68157ba512c83f7284139ffd2e.png" alt=""></p>
<h2 id="6-4-用OpenCV实现数据标注小工具"><a href="#6-4-用OpenCV实现数据标注小工具" class="headerlink" title="6.4 用OpenCV实现数据标注小工具"></a>6.4 用OpenCV实现数据标注小工具</h2><p>除了对图像的处理，OpenCV的图形用户界面（<strong>G</strong>raphical <strong>U</strong>ser <strong>I</strong>nterface, <strong>GUI</strong>）和绘图等相关功能也是很有用的功能，无论是可视化，图像调试还是我们这节要实现的标注任务，都可以有所帮助。这节先介绍OpenCV窗口的最基本使用和交互，然后基于这些基础和之前的知识实现一个用于物体检测任务标注的小工具。</p>
<h2 id="6-4-1-OpenCV窗口循环"><a href="#6-4-1-OpenCV窗口循环" class="headerlink" title="6.4.1 OpenCV窗口循环"></a>6.4.1 OpenCV窗口循环</h2><p>OpenCV显示一幅图片的函数是cv2.imshow()，第一个参数是显示图片的窗口名称，第二个参数是图片的array。不过如果直接执行这个函数的话，什么都不会发生，因为这个函数得配合cv2.waitKey()一起使用。cv2.waitKey()指定当前的窗口显示要持续的毫秒数，比如cv2.waitKey(1000)就是显示一秒，然后窗口就关闭了。比较特殊的是cv2.waitKey(0)，并不是显示0毫秒的意思，而是一直显示，直到有键盘上的按键被按下，或者鼠标点击了窗口的小叉子才关闭。cv2.waitKey()的默认参数就是0，所以对于图像展示的场景，cv2.waitKey()或者cv2.waitKey(0)是最常用的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'Aitutaki.png'</span>)</span><br><span class="line">cv2.imshow(<span class="string">'Honeymoon Island'</span>, img)</span><br><span class="line">cv2.waitKey()</span><br></pre></td></tr></table></figure>
<p>执行这段代码得到如下窗口：</p>
<p><img src="/img/opencv/1621223716-1d500e00cebb3d8bb4301a554f9cc5d7.png" alt=""></p>
<p>cv2.waitKey()参数不为零的时候则可以和循环结合产生动态画面，比如在6.2.4的延时小例子中，我们把延时摄影保存下来的所有图像放到一个叫做frames的文件夹下。下面代码从frames的文件夹下读取所有图片并以24的帧率在窗口中显示成动画：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> cycle</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出frames文件夹下的所有图片</span></span><br><span class="line">filenames = os.listdir(<span class="string">'frames'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过itertools.cycle生成一个无限循环的迭代器，每次迭代都输出下一张图像对象</span></span><br><span class="line">img_iter = cycle([cv2.imread(os.sep.join([<span class="string">'frames'</span>, x])) <span class="keyword">for</span> x <span class="keyword">in</span> filenames])</span><br><span class="line"></span><br><span class="line">key = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> key &amp; <span class="number">0xFF</span> != <span class="number">27</span>:</span><br><span class="line">    cv2.imshow(<span class="string">'Animation'</span>, next(img_iter))</span><br><span class="line">    key = cv2.waitKey(<span class="number">42</span>)</span><br></pre></td></tr></table></figure>
<p>在这个例子中我们采用了Python的itertools模块中的cycle函数，这个函数可以把一个可遍历结构编程一个无限循环的迭代器。另外从这个例子中我们还发现，cv2.waitKey()返回的就是键盘上出发的按键。对于字母就是ascii码，特殊按键比如上下左右等，则对应特殊的值，其实这就是键盘事件的最基本用法。</p>
<h2 id="6-4-2-鼠标和键盘事件"><a href="#6-4-2-鼠标和键盘事件" class="headerlink" title="6.4.2 鼠标和键盘事件"></a>6.4.2 鼠标和键盘事件</h2><p>因为GUI总是交互的，所以鼠标和键盘事件基本使用必不可少，上节已经提到了cv2.waitKey()就是获取键盘消息的最基本方法。比如下面这段循环代码就能够获取键盘上按下的按键，并在终端输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">while key !&#x3D; 27:</span><br><span class="line">    cv2.imshow(&#39;Honeymoon Island&#39;, img)</span><br><span class="line">    key &#x3D; cv2.waitKey()</span><br><span class="line">    # 如果获取的键值小于256则作为ascii码输出对应字符，否则直接输出值</span><br><span class="line">    msg &#x3D; &#39;&#123;&#125; is pressed&#39;.format(chr(key) if key &lt; 256 else key)</span><br><span class="line">    print(msg)</span><br></pre></td></tr></table></figure>
<p>通过这个程序我们能获取一些常用特殊按键的值，比如在笔者用的机器上，四个方向的按键和删除键对应的值如下：</p>
<p>-<br>上（↑）：65362</p>
<p>-<br>下（↓）：65364</p>
<p>-<br>左（←）：65361</p>
<p>-<br>右（→）：65363</p>
<p>-<br>删除（Delete）：65535</p>
<p>需要注意的是在不同的操作系统里这些值可能是不一样的。鼠标事件比起键盘事件稍微复杂一点点，需要定义一个回调函数，然后把回调函数和一个指定名称的窗口绑定，这样只要鼠标位于画面区域内的事件就都能捕捉到。把下面这段代码插入到上段代码的while之前，就能获取当前鼠标的位置和动作并输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># 定义鼠标事件回调函数</span><br><span class="line">def on_mouse(event, x, y, flags, param):</span><br><span class="line"></span><br><span class="line">    # 鼠标左键按下，抬起，双击</span><br><span class="line">    if event &#x3D;&#x3D; cv2.EVENT_LBUTTONDOWN:</span><br><span class="line">        print(&#39;Left button down at (&#123;&#125;, &#123;&#125;)&#39;.format(x, y))</span><br><span class="line">    elif event &#x3D;&#x3D; cv2.EVENT_LBUTTONUP:</span><br><span class="line">        print(&#39;Left button up at (&#123;&#125;, &#123;&#125;)&#39;.format(x, y))</span><br><span class="line">    elif event &#x3D;&#x3D; cv2.EVENT_LBUTTONDBLCLK:</span><br><span class="line">        print(&#39;Left button double clicked at (&#123;&#125;, &#123;&#125;)&#39;.format(x, y))</span><br><span class="line"></span><br><span class="line">    # 鼠标右键按下，抬起，双击</span><br><span class="line">    elif event &#x3D;&#x3D; cv2.EVENT_RBUTTONDOWN:</span><br><span class="line">        print(&#39;Right button down at (&#123;&#125;, &#123;&#125;)&#39;.format(x, y))</span><br><span class="line">    elif event &#x3D;&#x3D; cv2.EVENT_RBUTTONUP:</span><br><span class="line">        print(&#39;Right button up at (&#123;&#125;, &#123;&#125;)&#39;.format(x, y))</span><br><span class="line">    elif event &#x3D;&#x3D; cv2.EVENT_RBUTTONDBLCLK:</span><br><span class="line">        print(&#39;Right button double clicked at (&#123;&#125;, &#123;&#125;)&#39;.format(x, y))</span><br><span class="line"></span><br><span class="line">    # 鼠标中&#x2F;滚轮键（如果有的话）按下，抬起，双击</span><br><span class="line">    elif event &#x3D;&#x3D; cv2.EVENT_MBUTTONDOWN:</span><br><span class="line">        print(&#39;Middle button down at (&#123;&#125;, &#123;&#125;)&#39;.format(x, y))</span><br><span class="line">    elif event &#x3D;&#x3D; cv2.EVENT_MBUTTONUP:</span><br><span class="line">        print(&#39;Middle button up at (&#123;&#125;, &#123;&#125;)&#39;.format(x, y))</span><br><span class="line">    elif event &#x3D;&#x3D; cv2.EVENT_MBUTTONDBLCLK:</span><br><span class="line">        print(&#39;Middle button double clicked at (&#123;&#125;, &#123;&#125;)&#39;.format(x, y))</span><br><span class="line"></span><br><span class="line">    # 鼠标移动</span><br><span class="line">    elif event &#x3D;&#x3D; cv2.EVENT_MOUSEMOVE:</span><br><span class="line">        print(&#39;Moving at (&#123;&#125;, &#123;&#125;)&#39;.format(x, y))</span><br><span class="line"></span><br><span class="line"># 为指定的窗口绑定自定义的回调函数</span><br><span class="line">cv2.namedWindow(&#39;Honeymoon Island&#39;)</span><br><span class="line">cv2.setMouseCallback(&#39;Honeymoon Island&#39;, on_mouse)</span><br></pre></td></tr></table></figure>
<h3 id="6-4-3-代码：物体检测标注的小工具"><a href="#6-4-3-代码：物体检测标注的小工具" class="headerlink" title="6.4.3 代码：物体检测标注的小工具"></a>6.4.3 代码：物体检测标注的小工具</h3><p>基于上面两小节的基本使用，就能和OpenCV的基本绘图功能就能实现一个超级简单的物体框标注小工具了。基本思路是对要标注的图像建立一个窗口循环，然后每次循环的时候对图像进行一次拷贝。鼠标在画面上画框的操作，以及已经画好的框的相关信息在全局变量中保存，并且在每个循环中根据这些信息，在拷贝的图像上再画一遍，然后显示这份拷贝的图像。</p>
<p>基于这种实现思路，使用上我们采用一个尽量简化的设计：</p>
<p>-<br>输入是一个文件夹，下面包含了所有要标注物体框的图片。如果图片中标注了物体，则生成一个相同名称加额外后缀名的文件保存标注信息。</p>
<p>-<br>标注的方式是按下鼠标左键选择物体框的左上角，松开鼠标左键选择物体框的右下角，鼠标右键删除上一个标注好的物体框。所有待标注物体的类别，和标注框颜色由用户自定义，如果没有定义则默认只标注一种物体，定义该物体名称叫“Object”。</p>
<p>-<br>方向键的←和→用来遍历图片，↑和↓用来选择当前要标注的物体，Delete键删除一张图片和对应的标注信息。</p>
<p>每张图片的标注信息，以及自定义标注物体和颜色的信息，用一个元组表示，第一个元素是物体名字，第二个元素是代表BGR颜色的tuple或者是代表标注框坐标的元组。对于这种并不复杂复杂的数据结构，我们直接利用Python的repr()函数，把数据结构保存成机器可读的字符串放到文件里，读取的时候用eval()函数就能直接获得数据。这样的方便之处在于不需要单独写个格式解析器。如果需要可以在此基础上再编写一个转换工具就能够转换成常见的Pascal VOC的标注格式或是其他的自定义格式。</p>
<p>在这些思路和设计下，我们定义标注信息文件的格式的例子如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(&#39;Hill&#39;, ((221, 163), (741, 291)))</span><br><span class="line">(&#39;Horse&#39;, ((465, 430), (613, 570)))</span><br></pre></td></tr></table></figure>
<p>元组中第一项是物体名称，第二项是标注框左上角和右下角的坐标。这里之所以不把标注信息的数据直接用pickle保存，是因为数据本身不会很复杂，直接保存还有更好的可读性。自定义标注物体和对应标注框颜色的格式也类似，不过更简单些，因为括号可以不写，具体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#39;Horse&#39;, (255, 255, 0)</span><br><span class="line">&#39;Hill&#39;, (0, 255, 255)</span><br><span class="line">&#39;DiaoSi&#39;, (0, 0, 255)</span><br></pre></td></tr></table></figure>
<p>第一项是物体名称，第二项是物体框的颜色。使用的时候把自己定义好的内容放到一个文本里，然后保存成和待标注文件夹同名，后缀名为labels的文件。比如我们在一个叫samples的文件夹下放上一些草原的照片，然后自定义一个samples.labels的文本文件。把上段代码的内容放进去，就定义了小山头的框为黄色，骏马的框为青色，以及红色的屌丝。基于以上，标注小工具的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">import cv2</span><br><span class="line"></span><br><span class="line"># tkinter是Python内置的简单GUI库，实现一些比如打开文件夹，确认删除等操作十分方便</span><br><span class="line">from tkFileDialog import askdirectory</span><br><span class="line">from tkMessageBox import askyesno</span><br><span class="line"></span><br><span class="line"># 定义标注窗口的默认名称</span><br><span class="line">WINDOW_NAME &#x3D; &#39;Simple Bounding Box Labeling Tool&#39;</span><br><span class="line"></span><br><span class="line"># 定义画面刷新的大概帧率（是否能达到取决于电脑性能）</span><br><span class="line">FPS &#x3D; 24</span><br><span class="line"></span><br><span class="line"># 定义支持的图像格式</span><br><span class="line">SUPPOTED_FORMATS &#x3D; [&#39;jpg&#39;, &#39;jpeg&#39;, &#39;png&#39;]</span><br><span class="line"></span><br><span class="line"># 定义默认物体框的名字为Object，颜色蓝色，当没有用户自定义物体时用默认物体</span><br><span class="line">DEFAULT_COLOR &#x3D; &#123;&#39;Object&#39;: (255, 0, 0)&#125;</span><br><span class="line"></span><br><span class="line"># 定义灰色，用于信息显示的背景和未定义物体框的显示</span><br><span class="line">COLOR_GRAY &#x3D; (192, 192, 192)</span><br><span class="line"></span><br><span class="line"># 在图像下方多出BAR_HEIGHT这么多像素的区域用于显示文件名和当前标注物体等信息</span><br><span class="line">BAR_HEIGHT &#x3D; 16</span><br><span class="line"></span><br><span class="line"># 上下左右，ESC及删除键对应的cv.waitKey()的返回值</span><br><span class="line"># 注意这个值根据操作系统不同有不同，可以通过6.4.2中的代码获取</span><br><span class="line">KEY_UP &#x3D; 65362</span><br><span class="line">KEY_DOWN &#x3D; 65364</span><br><span class="line">KEY_LEFT &#x3D; 65361</span><br><span class="line">KEY_RIGHT &#x3D; 65363</span><br><span class="line">KEY_ESC &#x3D; 27</span><br><span class="line">KEY_DELETE &#x3D; 65535</span><br><span class="line"></span><br><span class="line"># 空键用于默认循环</span><br><span class="line">KEY_EMPTY &#x3D; 0</span><br><span class="line"></span><br><span class="line">get_bbox_name &#x3D; &#39;&#123;&#125;.bbox&#39;.format</span><br><span class="line"></span><br><span class="line"># 定义物体框标注工具类</span><br><span class="line">class SimpleBBoxLabeling:</span><br><span class="line"></span><br><span class="line">    def __init__(self, data_dir, fps&#x3D;FPS, window_name&#x3D;None):</span><br><span class="line">        self._data_dir &#x3D; data_dir</span><br><span class="line">        self.fps &#x3D; fps</span><br><span class="line">        self.window_name &#x3D; window_name if window_name else WINDOW_NAME</span><br><span class="line"></span><br><span class="line">        #pt0是正在画的左上角坐标，pt1是鼠标所在坐标</span><br><span class="line">        self._pt0 &#x3D; None</span><br><span class="line">        self._pt1 &#x3D; None</span><br><span class="line"></span><br><span class="line">        # 表明当前是否正在画框的状态标记</span><br><span class="line">        self._drawing &#x3D; False</span><br><span class="line"></span><br><span class="line">        # 当前标注物体的名称</span><br><span class="line">        self._cur_label &#x3D; None</span><br><span class="line"></span><br><span class="line">        # 当前图像对应的所有已标注框</span><br><span class="line">        self._bboxes &#x3D; []</span><br><span class="line"></span><br><span class="line">        # 如果有用户自定义的标注信息则读取，否则用默认的物体和颜色</span><br><span class="line">        label_path &#x3D; &#39;&#123;&#125;.labels&#39;.format(self._data_dir)</span><br><span class="line">        self.label_colors &#x3D; DEFAULT_COLOR if not os.path.exists(label_path) else self.load_labels(label_path)</span><br><span class="line"></span><br><span class="line">        # 获取已经标注的文件列表和还未标注的文件列表</span><br><span class="line">        imagefiles &#x3D; [x for x in os.listdir(self._data_dir) if x[x.rfind(&#39;.&#39;) + 1:].lower() in SUPPOTED_FORMATS]</span><br><span class="line">        labeled &#x3D; [x for x in imagefiles if os.path.exists(get_bbox_name(x))]</span><br><span class="line">        to_be_labeled &#x3D; [x for x in imagefiles if x not in labeled]</span><br><span class="line"></span><br><span class="line">        # 每次打开一个文件夹，都自动从还未标注的第一张开始</span><br><span class="line">        self._filelist &#x3D; labeled + to_be_labeled</span><br><span class="line">        self._index &#x3D; len(labeled)</span><br><span class="line">        if self._index &gt; len(self._filelist) - 1:</span><br><span class="line">            self._index &#x3D; len(self._filelist) - 1</span><br><span class="line"></span><br><span class="line">    # 鼠标回调函数</span><br><span class="line">    def _mouse_ops(self, event, x, y, flags, param):</span><br><span class="line"></span><br><span class="line">        # 按下左键时，坐标为左上角，同时表明开始画框，改变drawing标记为True</span><br><span class="line">        if event &#x3D;&#x3D; cv2.EVENT_LBUTTONDOWN:</span><br><span class="line">            self._drawing &#x3D; True</span><br><span class="line">            self._pt0 &#x3D; (x, y)</span><br><span class="line"></span><br><span class="line">        # 左键抬起，表明当前框画完了，坐标记为右下角，并保存，同时改变drawing标记为False</span><br><span class="line">        elif event &#x3D;&#x3D; cv2.EVENT_LBUTTONUP:</span><br><span class="line">            self._drawing &#x3D; False</span><br><span class="line">            self._pt1 &#x3D; (x, y)</span><br><span class="line">            self._bboxes.append((self._cur_label, (self._pt0, self._pt1)))</span><br><span class="line"></span><br><span class="line">        # 实时更新右下角坐标方便画框</span><br><span class="line">        elif event &#x3D;&#x3D; cv2.EVENT_MOUSEMOVE:</span><br><span class="line">            self._pt1 &#x3D; (x, y)</span><br><span class="line"></span><br><span class="line">        # 鼠标右键删除最近画好的框</span><br><span class="line">        elif event &#x3D;&#x3D; cv2.EVENT_RBUTTONUP:</span><br><span class="line">            if self._bboxes:</span><br><span class="line">                self._bboxes.pop()</span><br><span class="line"></span><br><span class="line">    # 清除所有标注框和当前状态</span><br><span class="line">    def _clean_bbox(self):</span><br><span class="line">        self._pt0 &#x3D; None</span><br><span class="line">        self._pt1 &#x3D; None</span><br><span class="line">        self._drawing &#x3D; False</span><br><span class="line">        self._bboxes &#x3D; []</span><br><span class="line"></span><br><span class="line">    # 画标注框和当前信息的函数</span><br><span class="line">    def _draw_bbox(self, img):</span><br><span class="line"></span><br><span class="line">        # 在图像下方多出BAR_HEIGHT这么多像素的区域用于显示文件名和当前标注物体等信息</span><br><span class="line">        h, w &#x3D; img.shape[:2]</span><br><span class="line">        canvas &#x3D; cv2.copyMakeBorder(img, 0, BAR_HEIGHT, 0, 0, cv2.BORDER_CONSTANT, value&#x3D;COLOR_GRAY)</span><br><span class="line"></span><br><span class="line">        # 正在标注的物体信息，如果鼠标左键已经按下，则显示两个点坐标，否则显示当前待标注物体的名称</span><br><span class="line">        label_msg &#x3D; &#39;&#123;&#125;: &#123;&#125;, &#123;&#125;&#39;.format(self._cur_label, self._pt0, self._pt1) \</span><br><span class="line">            if self._drawing \</span><br><span class="line">            else &#39;Current label: &#123;&#125;&#39;.format(self._cur_label)</span><br><span class="line"></span><br><span class="line">        # 显示当前文件名，文件个数信息</span><br><span class="line">        msg &#x3D; &#39;&#123;&#125;&#x2F;&#123;&#125;: &#123;&#125; | &#123;&#125;&#39;.format(self._index + 1, len(self._filelist), self._filelist[self._index], label_msg)</span><br><span class="line">        cv2.putText(canvas, msg, (1, h+12),</span><br><span class="line">                    cv2.FONT_HERSHEY_SIMPLEX,</span><br><span class="line">                    0.5, (0, 0, 0), 1)</span><br><span class="line"></span><br><span class="line">        # 画出已经标好的框和对应名字</span><br><span class="line">        for label, (bpt0, bpt1) in self._bboxes:</span><br><span class="line">            label_color &#x3D; self.label_colors[label] if label in self.label_colors else COLOR_GRAY</span><br><span class="line">            cv2.rectangle(canvas, bpt0, bpt1, label_color, thickness&#x3D;2)</span><br><span class="line">            cv2.putText(canvas, label, (bpt0[0]+3, bpt0[1]+15),</span><br><span class="line">                        cv2.FONT_HERSHEY_SIMPLEX,</span><br><span class="line">                        0.5, label_color, 2)</span><br><span class="line"></span><br><span class="line">        # 画正在标注的框和对应名字</span><br><span class="line">        if self._drawing:</span><br><span class="line">            label_color &#x3D; self.label_colors[self._cur_label] if self._cur_label in self.label_colors else COLOR_GRAY</span><br><span class="line">            if self._pt1[0] &gt;&#x3D; self._pt0[0] and self._pt1[1] &gt;&#x3D; self._pt0[1]:</span><br><span class="line">                cv2.rectangle(canvas, self._pt0, self._pt1, label_color, thickness&#x3D;2)</span><br><span class="line">            cv2.putText(canvas, self._cur_label, (self._pt0[0] + 3, self._pt0[1] + 15),</span><br><span class="line">                        cv2.FONT_HERSHEY_SIMPLEX,</span><br><span class="line">                        0.5, label_color, 2)</span><br><span class="line">        return canvas</span><br><span class="line"></span><br><span class="line">    # 利用repr()导出标注框数据到文件</span><br><span class="line">    @staticmethod</span><br><span class="line">    def export_bbox(filepath, bboxes):</span><br><span class="line">        if bboxes:</span><br><span class="line">            with open(filepath, &#39;w&#39;) as f:</span><br><span class="line">                for bbox in bboxes:</span><br><span class="line">                    line &#x3D; repr(bbox) + &#39;\n&#39;</span><br><span class="line">                    f.write(line)</span><br><span class="line">        elif os.path.exists(filepath):</span><br><span class="line">            os.remove(filepath)</span><br><span class="line"></span><br><span class="line">    # 利用eval()读取标注框字符串到数据</span><br><span class="line">    @staticmethod</span><br><span class="line">    def load_bbox(filepath):</span><br><span class="line">        bboxes &#x3D; []</span><br><span class="line">        with open(filepath, &#39;r&#39;) as f:</span><br><span class="line">            line &#x3D; f.readline().rstrip()</span><br><span class="line">            while line:</span><br><span class="line">                bboxes.append(eval(line))</span><br><span class="line">                line &#x3D; f.readline().rstrip()</span><br><span class="line">        return bboxes</span><br><span class="line"></span><br><span class="line">    # 利用eval()读取物体及对应颜色信息到数据</span><br><span class="line">    @staticmethod</span><br><span class="line">    def load_labels(filepath):</span><br><span class="line">        label_colors &#x3D; &#123;&#125;</span><br><span class="line">        with open(filepath, &#39;r&#39;) as f:</span><br><span class="line">            line &#x3D; f.readline().rstrip()</span><br><span class="line">            while line:</span><br><span class="line">                label, color &#x3D; eval(line)</span><br><span class="line">                label_colors[label] &#x3D; color</span><br><span class="line">                line &#x3D; f.readline().rstrip()</span><br><span class="line">        return label_colors</span><br><span class="line"></span><br><span class="line">    # 读取图像文件和对应标注框信息（如果有的话）</span><br><span class="line">    @staticmethod</span><br><span class="line">    def load_sample(filepath):</span><br><span class="line">        img &#x3D; cv2.imread(filepath)</span><br><span class="line">        bbox_filepath &#x3D; get_bbox_name(filepath)</span><br><span class="line">        bboxes &#x3D; []</span><br><span class="line">        if os.path.exists(bbox_filepath):</span><br><span class="line">            bboxes &#x3D; SimpleBBoxLabeling.load_bbox(bbox_filepath)</span><br><span class="line">        return img, bboxes</span><br><span class="line"></span><br><span class="line">    # 导出当前标注框信息并清空</span><br><span class="line">    def _export_n_clean_bbox(self):</span><br><span class="line">        bbox_filepath &#x3D; os.sep.join([self._data_dir, get_bbox_name(self._filelist[self._index])])</span><br><span class="line">        self.export_bbox(bbox_filepath, self._bboxes)</span><br><span class="line">        self._clean_bbox()</span><br><span class="line"></span><br><span class="line">    # 删除当前样本和对应的标注框信息</span><br><span class="line">    def _delete_current_sample(self):</span><br><span class="line">        filename &#x3D; self._filelist[self._index]</span><br><span class="line">        filepath &#x3D; os.sep.join([self._data_dir, filename])</span><br><span class="line">        if os.path.exists(filepath):</span><br><span class="line">            os.remove(filepath)</span><br><span class="line">        filepath &#x3D; get_bbox_name(filepath)</span><br><span class="line">        if os.path.exists(filepath):</span><br><span class="line">            os.remove(filepath)</span><br><span class="line">        self._filelist.pop(self._index)</span><br><span class="line">        print(&#39;&#123;&#125; is deleted!&#39;.format(filename))</span><br><span class="line">		</span><br><span class="line">    # 开始OpenCV窗口循环的方法，定义了程序的主逻辑</span><br><span class="line">    def start(self):</span><br><span class="line"></span><br><span class="line">	    # 之前标注的文件名，用于程序判断是否需要执行一次图像读取</span><br><span class="line">        last_filename &#x3D; &#39;&#39;</span><br><span class="line">		</span><br><span class="line">        # 标注物体在列表中的下标</span><br><span class="line">        label_index &#x3D; 0</span><br><span class="line">		</span><br><span class="line">        # 所有标注物体名称的列表</span><br><span class="line">        labels &#x3D; self.label_colors.keys()</span><br><span class="line"></span><br><span class="line">        # 待标注物体的种类数</span><br><span class="line">        n_labels &#x3D; len(labels)</span><br><span class="line"></span><br><span class="line">        # 定义窗口和鼠标回调</span><br><span class="line">        cv2.namedWindow(self.window_name)</span><br><span class="line">        cv2.setMouseCallback(self.window_name, self._mouse_ops)</span><br><span class="line">        key &#x3D; KEY_EMPTY</span><br><span class="line"></span><br><span class="line">        # 定义每次循环的持续时间</span><br><span class="line">        delay &#x3D; int(1000 &#x2F; FPS)</span><br><span class="line"></span><br><span class="line">        # 只要没有按下Esc键，就持续循环</span><br><span class="line">        while key !&#x3D; KEY_ESC:</span><br><span class="line"></span><br><span class="line">            # 上下键用于选择当前标注物体</span><br><span class="line">            if key &#x3D;&#x3D; KEY_UP:</span><br><span class="line">                if label_index &#x3D;&#x3D; 0:</span><br><span class="line">                    pass</span><br><span class="line">                else:</span><br><span class="line">                    label_index -&#x3D; 1</span><br><span class="line"></span><br><span class="line">            elif key &#x3D;&#x3D; KEY_DOWN:</span><br><span class="line">                if label_index &#x3D;&#x3D; n_labels - 1:</span><br><span class="line">                    pass</span><br><span class="line">                else:</span><br><span class="line">                    label_index +&#x3D; 1</span><br><span class="line"></span><br><span class="line">            # 左右键切换当前标注的图片</span><br><span class="line">            elif key &#x3D;&#x3D; KEY_LEFT:</span><br><span class="line">                # 已经到了第一张图片的话就不需要清空上一张</span><br><span class="line">                if self._index &gt; 0:</span><br><span class="line">                    self._export_n_clean_bbox()</span><br><span class="line"></span><br><span class="line">                self._index -&#x3D; 1</span><br><span class="line">                if self._index &lt; 0:</span><br><span class="line">                    self._index &#x3D; 0</span><br><span class="line"></span><br><span class="line">            elif key &#x3D;&#x3D; KEY_RIGHT:</span><br><span class="line">                # 已经到了最后一张图片的话就不需要清空上一张</span><br><span class="line">                if self._index &lt; len(self._filelist) - 1:</span><br><span class="line">                    self._export_n_clean_bbox()</span><br><span class="line"></span><br><span class="line">                self._index +&#x3D; 1</span><br><span class="line">                if self._index &gt; len(self._filelist) - 1:</span><br><span class="line">                    self._index &#x3D; len(self._filelist) - 1</span><br><span class="line"></span><br><span class="line">            # 删除当前图片和对应标注信息</span><br><span class="line">            elif key &#x3D;&#x3D; KEY_DELETE:</span><br><span class="line">                if askyesno(&#39;Delete Sample&#39;, &#39;Are you sure?&#39;):</span><br><span class="line">                    self._delete_current_sample()</span><br><span class="line">                    key &#x3D; KEY_EMPTY</span><br><span class="line">                    continue</span><br><span class="line"></span><br><span class="line">            # 如果键盘操作执行了换图片，则重新读取，更新图片</span><br><span class="line">            filename &#x3D; self._filelist[self._index]</span><br><span class="line">            if filename !&#x3D; last_filename:</span><br><span class="line">                filepath &#x3D; os.sep.join([self._data_dir, filename])</span><br><span class="line">                img, self._bboxes &#x3D; self.load_sample(filepath)</span><br><span class="line"></span><br><span class="line">            # 更新当前标注物体名称</span><br><span class="line">            self._cur_label &#x3D; labels[label_index]</span><br><span class="line"></span><br><span class="line">            # 把标注和相关信息画在图片上并显示指定的时间</span><br><span class="line">            canvas &#x3D; self._draw_bbox(img)</span><br><span class="line">            cv2.imshow(self.window_name, canvas)</span><br><span class="line">            key &#x3D; cv2.waitKey(delay)</span><br><span class="line"></span><br><span class="line">            # 当前文件名就是下次循环的老文件名</span><br><span class="line">            last_filename &#x3D; filename</span><br><span class="line"></span><br><span class="line">        print(&#39;Finished!&#39;)</span><br><span class="line"></span><br><span class="line">        cv2.destroyAllWindows()</span><br><span class="line">        # 如果退出程序，需要对当前进行保存</span><br><span class="line">        self.export_bbox(os.sep.join([self._data_dir, get_bbox_name(filename)]), self._bboxes)</span><br><span class="line"></span><br><span class="line">        print(&#39;Labels updated!&#39;)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    dir_with_images &#x3D; askdirectory(title&#x3D;&#39;Where are the images?&#39;)</span><br><span class="line">    labeling_task &#x3D; SimpleBBoxLabeling(dir_with_images)</span><br><span class="line">    labeling_task.start()</span><br></pre></td></tr></table></figure>
<p>需要注意的是几个比较通用且独立的方法前加上了一句@staticmethod，表明是个静态方法。执行这个程序，并选择samples文件夹，标注时的画面如下图：</p>
<p><img src="/img/opencv/1621223716-662b7d508d4aaa4f36b571f659369358.png" alt=""></p>
<h2 id="看完本文，我感觉Python基础已经可以了，我要浪，我要生成图片："><a href="#看完本文，我感觉Python基础已经可以了，我要浪，我要生成图片：" class="headerlink" title="看完本文，我感觉Python基础已经可以了，我要浪，我要生成图片："></a>看完本文，我感觉Python基础已经可以了，我要浪，我要生成图片：</h2><p>1) 生成欺骗神经网络的诡异图片（有代码，比较老，需改）：</p>
<p><a href="https://zhuanlan.zhihu.com/p/26122612" target="_blank" rel="noopener">YE Y：用Caffe生成对抗样本​zhuanlan.zhihu.com<img src="/img/opencv/1621223716-32174e8fbcb531a7119a6de3d36193de.jpg" alt="图标"></a></p>
<p>2) 最简单的GAN的例子（有代码，比较老，需小改）：</p>
<p><a href="https://zhuanlan.zhihu.com/p/27343585" target="_blank" rel="noopener">YE Y：用GAN生成二维样本的小例子​zhuanlan.zhihu.com<img src="/img/opencv/1621223716-9962244af381284c378c833c6c662624.jpg" alt="图标"></a></p>
<p>3) <strong>我会开车</strong>：稍微进阶一点的GAN（无代码，但有图）</p>
<p><a href="https://zhuanlan.zhihu.com/p/27199954" target="_blank" rel="noopener">YE Y：提高驾驶技术：用GAN去除(爱情)动作片中的马赛克和衣服​zhuanlan.zhihu.com<img src="/img/opencv/1621223716-21c458573cfaf222eefe0333ed59caf7.jpg" alt="图标"></a></p>

                
                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2021/05/18/lepeng-python-Python-第三方模块之-imgaug-图像-augmentation/" data-toggle="tooltip" data-placement="top" title="Python 第三方模块之 imgaug - 图像 augmentation">&larr; Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2021/05/17/lepeng-python-Python-第三方模块之-opencv-视频截取/" data-toggle="tooltip" data-placement="top" title="Python 第三方模块之 opencv - 视频截取">Next Post &rarr;</a>
                    </li>
                    
                </ul>

                <!-- tip start -->
                

                
                <div class="comment_notes">
                    <p>
                        study well and make progress every day; study well and progress every day; study hard and make progress every day.
                    </p>
                </div>
                
                <!-- tip end -->

                <!-- Music start-->
                
                <!-- Music end -->

                <!-- Sharing -->
                
                <div class="social-share"  data-wechat-qrcode-helper="" align="center"></div>
                <!--  css & js -->
                <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">
                <script src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>
                
                <!-- Sharing -->

                <!-- gitment start -->
                
                <!-- gitment end -->

                <!-- 来必力City版安装代码 -->
                
                <!-- City版安装代码已完成 -->

                <!-- disqus comment start -->
                
                <!-- disqus comment end -->
            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

    
      
        <aside id="sidebar">
          <div id="toc" class="toc-article">
          <strong class="toc-title">Contents</strong>
          
            
              <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#Python-OpenCV"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">Python-OpenCV</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#1-1-OpenCV简介"><span class="toc-nav-number">1.1.</span> <span class="toc-nav-text">1.1 OpenCV简介</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-1-1-OpenCV的结构"><span class="toc-nav-number">1.1.1.</span> <span class="toc-nav-text">1.1.1 OpenCV的结构</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-1-2-安装和使用OpenCV"><span class="toc-nav-number">1.1.2.</span> <span class="toc-nav-text">1.1.2 安装和使用OpenCV</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#1-2-Python-OpenCV基础"><span class="toc-nav-number">1.2.</span> <span class="toc-nav-text">1.2 Python-OpenCV基础</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-2-1-图像的表示"><span class="toc-nav-number">1.2.1.</span> <span class="toc-nav-text">1.2.1 图像的表示</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-2-2-基本图像处理"><span class="toc-nav-number">1.2.2.</span> <span class="toc-nav-text">1.2.2 基本图像处理</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#示例"><span class="toc-nav-number">1.2.2.1.</span> <span class="toc-nav-text">示例</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#存取图像"><span class="toc-nav-number">1.2.2.2.</span> <span class="toc-nav-text">存取图像</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#缩放，裁剪和补边"><span class="toc-nav-number">1.2.2.3.</span> <span class="toc-nav-text">缩放，裁剪和补边</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#色调，明暗，直方图和Gamma曲线"><span class="toc-nav-number">1.2.2.4.</span> <span class="toc-nav-text">色调，明暗，直方图和Gamma曲线</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-2-3-图像的仿射变换"><span class="toc-nav-number">1.2.3.</span> <span class="toc-nav-text">1.2.3 图像的仿射变换</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-2-4-基本绘图"><span class="toc-nav-number">1.2.4.</span> <span class="toc-nav-text">1.2.4 基本绘图</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#1-2-5-视频功能"><span class="toc-nav-number">1.3.</span> <span class="toc-nav-text">1.2.5 视频功能</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#6-3-用OpenCV实现数据增加小工具"><span class="toc-nav-number">1.4.</span> <span class="toc-nav-text">6.3 用OpenCV实现数据增加小工具</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#6-3-1-随机裁剪"><span class="toc-nav-number">1.5.</span> <span class="toc-nav-text">6.3.1 随机裁剪</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#6-3-2-随机旋转"><span class="toc-nav-number">1.6.</span> <span class="toc-nav-text">6.3.2 随机旋转</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#6-3-3-随机颜色和明暗"><span class="toc-nav-number">1.7.</span> <span class="toc-nav-text">6.3.3 随机颜色和明暗</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#6-3-4-多进程调用加速处理"><span class="toc-nav-number">1.7.1.</span> <span class="toc-nav-text">6.3.4 多进程调用加速处理</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#6-3-5-代码：图片数据增加小工具"><span class="toc-nav-number">1.7.2.</span> <span class="toc-nav-text">6.3.5 代码：图片数据增加小工具</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#6-4-用OpenCV实现数据标注小工具"><span class="toc-nav-number">1.8.</span> <span class="toc-nav-text">6.4 用OpenCV实现数据标注小工具</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#6-4-1-OpenCV窗口循环"><span class="toc-nav-number">1.9.</span> <span class="toc-nav-text">6.4.1 OpenCV窗口循环</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#6-4-2-鼠标和键盘事件"><span class="toc-nav-number">1.10.</span> <span class="toc-nav-text">6.4.2 鼠标和键盘事件</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#6-4-3-代码：物体检测标注的小工具"><span class="toc-nav-number">1.10.1.</span> <span class="toc-nav-text">6.4.3 代码：物体检测标注的小工具</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#看完本文，我感觉Python基础已经可以了，我要浪，我要生成图片："><span class="toc-nav-number">1.11.</span> <span class="toc-nav-text">看完本文，我感觉Python基础已经可以了，我要浪，我要生成图片：</span></a></li></ol></li></ol>
            
          
          </div>
        </aside>
      
    

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#Python" title="Python">Python</a>
                        
                          <a class="tag" href="/tags/#Python 第三方模块" title="Python 第三方模块">Python 第三方模块</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                        <li><a href="https://blog.csdn.net/fenglepeng" target="_blank">Feng Lepeng&#39;s CSDN</a></li>
                    
                </ul>
                
            </div>
        </div>
    </div>
</article>




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: 'ℬ'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>


<style  type="text/css">
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">

                

                

                

                

                

                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy;
                    <a href="https://beian.miit.gov.cn/" target="_blank" rel="noopener">京ICP备18055501号-2</a>;
                    Feng Lepeng 2022
                    <br>
                    Powered by 
                    <a href="https://github.com/dusign/hexo-theme-snail" target="_blank" rel="noopener">
                        <i>hexo-theme-snail</i>
                    </a> | 
                    <iframe name="star" style="margin-left: 2px; margin-bottom:-5px;" frameborder="0" scrolling="0"
                        width="100px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=flepeng&repo=hexo-theme-lp&type=star">
                    </iframe>
                </p>
            </div>
        </div>
    </div>

</footer>

<!-- jQuery -->

<script src="/js/jquery.min.js"></script>


<!-- Bootstrap Core JavaScript -->

<script src="/js/bootstrap.min.js"></script>


<!-- Custom Theme JavaScript -->

<script src="/js/hux-blog.min.js"></script>


<!-- Search -->

<script src="/js/search.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://flepeng.github.io/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-XXXXXXXX-X';
    var _gaDomain = 'yoursite';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>




<!-- Baidu Tongji -->


<!-- Search -->

    <script type="text/javascript">      
        var search_path = "search.xml";
        if (search_path.length == 0) {
            search_path = "search.xml";
        }
    var path = "/" + search_path;
    searchFunc(path, 'local-search-input', 'local-search-result');
    </script>


<!-- busuanzi -->
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>

    
        <!-- background effects line -->
        

        
            <script type="text/javascript" src="/js/mouse-click.js" content='[&#34;🌱&#34;,&#34;just do it&#34;,&#34;🍀&#34;]' color='[&#34;rgb(121,93,179)&#34; ,&#34;rgb(76,180,231)&#34; ,&#34;rgb(184,90,154)&#34;]'></script>
        

        <!-- background effects end -->
    

    <!--<script size="50" alpha='0.3' zIndex="-999" src="/js/ribbonStatic.js"></script>-->
    
        <script src="/js/ribbonDynamic.js"></script>
    
</body>

</html>
