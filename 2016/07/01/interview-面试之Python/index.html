<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <script data-ad-client="ca-pub-2488174175014870" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script> <!-- google ad -->
    <meta name="google-site-verification" content="40lMg4eqLLbXoDcpN3h-cEnfmselbQ8tUzNvuC0IRIs" /><!-- google 站点认证 -->
    <meta name="baidu-site-verification" content="093lY4ziMu" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="description" content="A hexo theme">
    <meta name="keyword"  content="hexo, hexo-theme-lp">
    <link rel="shortcut icon" href="/img/ironman-draw.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <!--<link href='http://fonts.googleapis.com/css?family=Montserrat:400,700' rel='stylesheet' type='text/css'>-->
    <title>
        
          面试之Python基础 - Hexo-theme-lp
        
    </title>

    <link rel="canonical" href="https://flepeng.github.io/2016/07/01/interview-面试之Python/">

    <!-- Bootstrap Core CSS -->
    
<link rel="stylesheet" href="/css/bootstrap.min.css">


    <!-- Custom CSS --> 
    
        
<link rel="stylesheet" href="/css/dusign-light.css">

        
<link rel="stylesheet" href="/css/dusign-common-light.css">

        
<link rel="stylesheet" href="/css/font-awesome.css">

        
<link rel="stylesheet" href="/css/toc.css">

        <!-- background effects end -->
    
    
    <!-- Pygments Highlight CSS -->
    
<link rel="stylesheet" href="/css/highlight.css">


    
<link rel="stylesheet" href="/css/widget.css">


    
<link rel="stylesheet" href="/css/rocket.css">


    
<link rel="stylesheet" href="/css/signature.css">


    
<link rel="stylesheet" href="/css/fonts.googleapis.css">


    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">

    <!-- photography -->
    
<link rel="stylesheet" href="/css/photography.css">


    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- background effects start -->
    
    <!-- background effects end -->

	<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            
                background-image: linear-gradient(rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.3)), url('/img/header_img/archive-bg.jpg')
                /*post*/
            
        
    }
    
    #signature{
        background-image: url('/img/signature/dusign.png');
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#面试" title="面试">面试</a>
                            
                              <a class="tag" href="/tags/#Python" title="Python">Python</a>
                            
                        </div>
                        <h1>面试之Python基础</h1>
                        <h2 class="subheading"></h2>
                        <span class="meta">
                            Posted by Lepeng on
                            2016-07-01
                        </span>

                        
                            <div class="blank_box"></div>
                            <span class="meta">
                                Words <span class="post-count">12.2k</span> and
                                Reading Time <span class="post-count">49</span> Minutes
                            </span>
                            <div class="blank_box"></div>
                            <!-- 不蒜子统计 start -->
                            <span class="meta">
                                Viewed <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span> Times
                            </span>
                            <!-- 不蒜子统计 end -->
                        

                    </div>
                

                </div>
            </div>
        </div>      
    </div>

    
    <div class="waveWrapper">
        <div class="wave wave_before" style="background-image: url('/img/wave-light.png')"></div>
        <div class="wave wave_after" style="background-image: url('/img/wave-light.png')"></div>
    </div>
    
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Lepeng</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/categories/">Categories</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archive/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                    
                    <li>
                        <a href="http://flepeng.com" target="_blank">chinese_blog</a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h2 id="爱好"><a href="#爱好" class="headerlink" title="爱好"></a>爱好</h2><p>1、为什么学习Python</p>
<p>家里有在这个IT圈子里面，也想让我接触这个圈子，给我建议学Python，然后自己通过百度和向有学过Python的同学了解了Python，<br>Python这门语言，入门比较简单，它简单易学，生态圈比较强大，涉及的地方比较多，特别是在人工智能，和数据分析这方面。在未来我觉得是往自动化，人工智能这方面发展的，所以学习了Python</p>
<p>2、通过什么途径学习Python</p>
<p>刚开始接触Python的时候，到网上里面跟着视频学基础，再后来网上到看技术贴，然后看到有人推荐廖雪峰的Python教程，练项目到GitHub上面找一些小项目学习。</p>
<h2 id="编程基础"><a href="#编程基础" class="headerlink" title="编程基础"></a>编程基础</h2><p>3、谈谈对Python的了解和其他语言的区别</p>
<p>优点:</p>
<ul>
<li>Python属于解释型语言，当程序运行时，是一行一行的解释并运行，所以调式代码很方便，开发效率高；</li>
<li>Python 语法简洁优美，功能强大，标准库与第三方库都非常强大，而且应用领域也非常广；  </li>
<li>龟叔给Python定位是任其自由发展、优雅、明确、简单；  </li>
<li>Python 易于学习;  </li>
<li>用少量的代码构建出很多功能;（高效的高级数据结构）  </li>
<li>Python完全支持面向对象;  </li>
<li>Python 是跨平台且开源的。可移植性，可扩展性，可嵌入性都很强  </li>
<li>动态类型</li>
</ul>
<p>缺点：</p>
<ul>
<li>运行速度慢，Python的运行速度相较与C，肯定是慢了  </li>
<li>Python弱类型（强类型是指不允许隐式变量类型转换，弱类型则允许隐式类型转换）</li>
</ul>
<p>与其他语言相比：</p>
<ul>
<li>与java相比：在很多方面，Python比Java要简单，比如java中所有变量必须声明才能使用，而Python不需要声明,用少量的代码构建出很多功能;（高效的高级数据结构）</li>
<li>与php相比：python标准包直接提供了工具，并且相对于PHP代码更易于维护;</li>
<li>与c相比：Python 和 C Python这门语言是由C开发而来</li>
</ul>
<p>4、简述解释型和编译型编程语言</p>
<ul>
<li>解释型：就是边解释边执行（Python，php）  </li>
<li>编译型：编译后再执行（c、java、c#）</li>
</ul>
<p>5、Python的解释器种类以及相关特点？</p>
<ul>
<li><p>CPython：官方版本的解释器。使用C语言开发的，所以叫CPython。在命令行下运行python就是启动CPython解释器。CPython是使用最广的Python解释器。教程的所有代码也都在CPython下执行。</p>
</li>
<li><p>IPython：IPython是基于CPython之上的一个交互式解释器，也就是说，IPython只是在交互方式上有所增强，但是执行Python代码的功能和CPython是完全一样的。CPython用&gt;&gt;&gt;作为提示符，而IPython用In [序号]:作为提示符。</p>
</li>
<li><p>PyPy：由Python写的解释器，它的执行速度是最快。PyPy采用JIT技术，对Python代码进行动态编译（注意不是解释），绝大部分Python代码都可以在PyPy下运行，但是PyPy和CPython有一些是不同的，这就导致相同的Python代码在两种解释器下执行可能会有不同的结果。</p>
</li>
<li><p>Jython：Jython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。</p>
</li>
<li><p>IronPython：IronPython和Jython类似，只不过IronPython是运行在.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。</p>
</li>
<li><p>小结：  </p>
<ul>
<li>Python的解释器很多，但使用最广泛的还是CPython。  </li>
<li>如果要和Java或.Net平台交互，最好的办法不是用Jython或IronPython，而是通过网络调用来交互，确保各程序之间的独立性。</li>
</ul>
</li>
</ul>
<p>6、位和字节的关系</p>
<p>1字节 = 8位<br>位（bit，又名“比特”，简写为b）：数据传输是以大多是以“位”（bit）为单位<br>字节（Byte，简写为B）：数据存储是以“字节”（Byte）为单位，字节是最小一级的信息单位<br>一个位就代表一个0或1（即一个二进制），二进制是构成存储器的最小单位，每8个位（bit）组成一个字节（Byte）</p>
<p>7、b、B、KB、MB、GB的关系</p>
<p>1B = 8 bit<br>1kb = 1024 B<br>1 MB = 1024 KB<br>1 GB = 1024 MB</p>
<p>8、ascii、unicode、utf-8、gbk 区别</p>
<ul>
<li>ascii：最多只能用8位来表示（一个字节），即：2**8 = 256，所以，ASCII码最多只能表示 256 个符号。  </li>
<li>unicode（万国码）：任何一个字符==两个字节  </li>
<li>utf-8（万国码的升级版）：一个中文字符==三个字节，英文是一个字节，欧洲的是 2个字节</li>
<li>gbk（国内版本）：一个中文字符==2个字节，英文是一个字节</li>
<li>gbk 转 utf-8 需通过媒介 unicode</li>
<li>python2 对内容进行编码默认ascii,python3对内容进行编码的默认为utf-8。  </li>
</ul>
<p>9、字节码和机器码的区别</p>
<ul>
<li><p>机器码(machine code)，学名机器语言指令，有时也被称为原生码（Native Code），是电脑的CPU可直接解读的数据。<br>总结：机器码是电脑CPU直接读取运行的机器指令，运行速度最快，但是非常晦涩难懂，也比较难编写</p>
</li>
<li><p>字节码（Bytecode）是一种包含执行程序、由一序列 op 代码/数据对 组成的二进制文件。<br>字节码是一种中间码，它比机器码更抽象，需要直译器转译后才能成为机器码的中间代码。<br>总结：字节码是一种中间状态（中间码）的二进制代码（文件）。需要直译器转译后才能成为机器码。</p>
</li>
</ul>
<h2 id="Python-基础"><a href="#Python-基础" class="headerlink" title="Python 基础"></a>Python 基础</h2><p>8、PE8规范</p>
<ol>
<li>使用4个空格而不是tab键进行缩进。  </li>
<li>每行长度不能超过79  </li>
<li>使用空行来间隔函数和类，以及函数内部的大块代码  </li>
<li>必要时候，在每一行下写注释  </li>
<li>使用文档注释，写出函数注释  </li>
<li>在操作符和逗号之后使用空格，但是不要在括号内部使用  </li>
<li>命名类和函数的时候使用一致的方式，比如使用CamelCase来命名类，使用lower_case_with_underscores来命名函数和方法  </li>
<li>在类中总是使用self来作为默认  </li>
<li>尽量不要使用魔法方法  </li>
<li>默认使用UTF-8，甚至ASCII作为编码方式  </li>
<li>换行可以使用反斜杠，最好使用圆括号  </li>
<li>不要在一句import中多个库</li>
<li><p>空格的使用</p>
<ul>
<li>各种右括号前不要加空格。  </li>
<li>逗号、冒号、分号前不要加空格。  </li>
<li>函数的左括号前不要加空格。如Func(1)  </li>
<li>序列的左括号前不要加空格。如list[2]  </li>
<li>操作符左右各加一个空格，不要为了对齐增加空格  </li>
<li>函数默认参数使用的赋值符左右省略空格  </li>
<li>不要将多句语句写在同一行，尽管使用‘；’允许</li>
</ul>
</li>
<li><p>if/for/while语句中，即使执行语句只有一句，也必须另起一行  </p>
</li>
<li>函数命名使用全部小写的方式，常量命名使用大写，类属性（方法和变量）使用小写  </li>
<li>类的命名首字母大写</li>
</ol>
<p>9、简述变量命名规范 </p>
<ol>
<li>以字母，数字，下划线任由结合  </li>
<li>不能以命名太长，不使用拼音，中文  </li>
<li>不能以数字开头  </li>
<li>不能用关键词</li>
</ol>
<p>11、python递归的最大层数</p>
<p>Python中默认的递归层数约为998左右(会报错) 和计算机性能有关系</p>
<p>15、三元运算写法和应用场景？</p>
<p>应用场景：简化if语句<br>理解：如果条件为真，把if前面的值赋值给变量，否则把else后面的值赋值给变量。<br>写法：条件成立时的结果 + if + 条件 + else + 条件不成立时的结果，例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result &#x3D; &#39;gt&#39; if 1&gt;3 else &#39;lt&#39;  </span><br><span class="line">print(result)       # lt</span><br></pre></td></tr></table></figure>
<p>16、Python3和Python2的区别？</p>
<p>链接：<a href="https://blog.csdn.net/fenglepeng/article/details/103585262" target="_blank" rel="noopener" title="Python2 和 Python3 的区别">Python2 和 Python3 的区别</a></p>
<ol>
<li><p>打印时，py2需要可以不需要加括号，python3 必须加括号<br> python 2 ：print (‘lili’)   或  print ‘lili’<br> python 3 ：print (‘lili’)   </p>
</li>
<li><p>exec语句被python3废弃，统一使用exec函数</p>
</li>
<li><p>内涵<br> Python2 ：1，臃肿，源码的重复量很多。2，语法不清晰，掺杂着C，php，Java，的一些陋习。<br> Python3 ：几乎是重构后的源码，规范，清晰，优美。</p>
</li>
<li><p>输出中文的区别<br> python2 ：要输出中文 需加 # -*- encoding:utf-8 -*-<br> Python3 ：直接搞</p>
</li>
<li><p>input不同<br> python2 ：raw_input<br> python3 ：input 统一使用input函数</p>
</li>
<li><p>指定字节<br> python2在编译安装时，可以通过参数——-enable-unicode=ucs2 或——-enable-unicode=ucs4分别用于指定使用2个字节、4个字节表示一个unicode；<br> python3无法进行选择，默认使用 ucs4<br> 查看当前python中表示unicode字符串时占用的空间：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">impor sys  </span><br><span class="line">print（sys.maxunicode）  </span><br><span class="line">#如果值是65535，则表示使用usc2标准，即：2个字节表示  </span><br><span class="line">#如果值是1114111，则表示使用usc4标准，即：4个字节表示</span><br></pre></td></tr></table></figure>
</li>
<li><p>xrange<br> py2：xrange、range<br> py3：range  统一使用range，Python3中range的机制也进行修改并提高了大数据集生成效率</p>
</li>
<li><p>在包的知识点里<br> 包：一群模块文件的集合 + __init__<br> py2：必须有__init__<br> py3：不是必须的了</p>
</li>
<li><p>不相等操作符”&lt;&gt;”被Python3废弃，统一使用”!=”</p>
</li>
<li><p>long整数类型被Python3废弃，统一使用int</p>
</li>
<li><p>迭代器iterator的next()函数被Python3废弃，统一使用next(iterator)</p>
</li>
<li><p>异常StandardError 被Python3废弃，统一使用Exception</p>
</li>
<li><p>字典变量的has_key函数被Python废弃，统一使用in关键词</p>
</li>
<li><p>file函数被Python3废弃，统一使用open来处理文件，可以通过io.IOBase检查文件类型</p>
</li>
</ol>
<p>20、文件操作时：xreadlines和readlines的区别？</p>
<ul>
<li>readlines 返回一个列表  </li>
<li>xreadlines   返回一个生成器  </li>
<li>python3 中只有readlines</li>
</ul>
<p>21、列举布尔值为False的常见值？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0, &#39;&#39;, &#123;&#125;, [], (), set(), False, 负数, 不成立的表达式, None 等</span><br></pre></td></tr></table></figure>
<p>22、 字符串、列表、元组、字典每个常用的5个方法？</p>
<p>参考链接：<a href="https://blog.csdn.net/fenglepeng/article/details/103587293" target="_blank" rel="noopener" title="Python 之数据类型">Python 之数据类型</a></p>
<ul>
<li><p>字符串：字符串用单引号(‘)或双引号(“)括起来，不可变<br>  1，find通过元素找索引，可切片，找不到返回-1<br>  2，index，找不到报错。<br>  3，split 由字符串分割成列表，默认按空格。<br>  4，captalize 首字母大写，其他字母小写。<br>  5，upper 全大写。<br>  6，lower 全小写。<br>  7，title，每个单词的首字母大写。<br>  8，startswith 判断以什么为开头，可以切片，整体概念。<br>  9，endswith 判断以什么为结尾，可以切片，整体概念。<br>  10，format格式化输出，三种玩法  </p>
<pre><code>   res=&#39;{} {} {}&#39;.format(&#39;egon&#39;,18,&#39;male&#39;)  == egon 18 male  
   res=&#39;{1} {0} {1}&#39;.format(&#39;egon&#39;,18,&#39;male&#39;)  ==18 egon 18  
   res=&#39;{name} {age} {sex}&#39;.format(sex=&#39;male&#39;,name=&#39;egon&#39;,age=18)  
</code></pre><p>  11，strip 默认去掉两侧空格，有条件<br>  12，lstrip,rstrip<br>  14，center 居中，默认空格。<br>  15，count查找元素的个数，可以切片，若没有返回0<br>  16，expandtabs 将一个tab键变成8个空格，如果tab前面的字符长度不足8个，则补全8个，<br>  17，replace（old，new,次数）<br>  18，isdigit 字符串由字母或数字组成 isalpha, 字符串只由字母组成 isalnum 字符串只由数字组成<br>  19，swapcase 大小写翻转<br>  20，for i in 可迭代对象。</p>
</li>
<li><p>字典：1无序（不能索引）2：数据关联性强3:键值对，键值对。唯一一个映射数据类型。<br># 字典的键必须是可哈希的   不可变类型。<br># 在同一个字典中，键(key)必须是唯一的。<br># 列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取<br>  key： 输出所有的键<br>  clear：清空<br>  dic：删除的键如果没有则报错<br>  pop：键值对删，有返回，没有原来的键会报错（自行设置返回键就不会报错）<br>  popitem：随机删键值对<br>  del：删除的键如果没有则报错<br>  update：改<br>  查  用get时，不会报错，没有可以返回设定的返回值<br>注意：<br>  1、字典是一种映射类型，它的元素是键值对。<br>  2、字典的关键字必须为不可变类型，且不能重复。<br>  3、创建空字典使用 { }。</p>
</li>
<li><p>列表：<br>索引，切片，加，乘，检查成员。<br>增加：有三种，<br>  append：在后面添加。<br>  insert按照索引添加，<br>  expend：迭代着添加。<br>  list.extend(seq) - 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）<br>  pop 删除   (pop 有返回值)<br>  remove 可以按照元素去删<br>  clear  清空列表<br>  del 1、可以按照索引去删除 2、切片 3、步长（隔着删）<br>改  1、索引  2、切片：先删除，再迭代着添加<br>  list.count(obj) - 统计某个元素在列表中出现的次数<br>  list.index(obj) - 从列表中找出某个值第一个匹配项的索引位置<br>  list.reverse() - 反向列表中元素<br>  list.sort([func]) - 对原列表进行排序<br>注意：<br>1、List写在方括号之间，元素用逗号隔开。<br>2、和字符串一样，list可以被索引和切片。<br>3、List可以使用+操作符进行拼接。<br>4、List中的元素是可以改变的。</p>
</li>
<li><p>元组：<br>（）元组的元素不能修改<br>1、cmp(tuple1, tuple2)：比较两个元组元素。<br>2、len(tuple)：计算元组元素个数。<br>3、max(tuple)：返回元组中元素最大值。<br>4、min(tuple)：返回元组中元素最小值。<br>5、tuple(seq)：将列表转换为元组。<br>注意<br>1、与字符串一样，元组的元素不能修改。<br>2、元组也可以被索引和切片，方法一样。<br>3、注意构造包含0或1个元素的元组的特殊语法规则。<br>4、元组也可以使用+操作符进行拼接。</p>
</li>
</ul>
<ul>
<li>Set（集合）<br>集合（set）是一个无序不重复元素的序列。<br>可以使用大括号 { } 或者 set() 函数创建集合，<br>注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。</li>
</ul>
<p>23、lambda表达式格式以及应用场景？</p>
<p>匿名函数：为了解决那些功能很简单的需求而设计的一句话函数<br>函数名 = lambda 参数 ：返回值</p>
<ul>
<li>参数可以有多个，用逗号隔开  </li>
<li>匿名函数不管逻辑多复杂，只能写一行，且逻辑执行结束后的内容就是返回值  </li>
<li>返回值和正常的函数一样可以是任意数据类型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">temp &#x3D; lambda x,y:x+y  </span><br><span class="line">print(temp(4,10))   # 14</span><br><span class="line"></span><br><span class="line"># 可替代  </span><br><span class="line">def foo(x,y):  </span><br><span class="line">    return x+y  </span><br><span class="line">print(foo(4,10))    # 14</span><br></pre></td></tr></table></figure>
<p>24、 pass的作用</p>
<p>pass是空语句，是为了保持程序结构的完整性。pass 不做任何事情，一般用做占位语句。</p>
<p>25、 *arg和**kwarg作用</p>
<ul>
<li>*args代表位置参数，它会接收任意多个参数并把这些参数作为元祖传递给函数。  </li>
<li>**kwargs代表的关键字参数，返回的是字典，位置参数一定要放在关键字前面</li>
</ul>
<p>26、is和==的区别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; &quot;lishi&quot;</span><br><span class="line">str1 &#x3D; &quot;li&quot;</span><br><span class="line">str2 &#x3D; &quot;shi&quot;</span><br><span class="line">str3 &#x3D; str1 + str2  </span><br><span class="line">print(&quot;a &#x3D;&#x3D; str3&quot;,a &#x3D;&#x3D; str3)    # a &#x3D;&#x3D; str3 True   &#x3D;&#x3D; ---只需要内容相等  </span><br><span class="line">print(&quot;a is str3&quot;,a is str3)    # a is str3 False  is ---只需要内存地址相等  </span><br><span class="line">print(&quot;id(a)&quot;,id(a))            # id(a) 38565848  </span><br><span class="line">print(&quot;id(str3)&quot;,id(str3))      # id(str3) 39110280  </span><br><span class="line"></span><br><span class="line"># is 比较的是两个实例对象是不是完全相同，它们是不是同一个对象，占用的内存地址是否相同。  </span><br><span class="line"># &#x3D;&#x3D; 比较的是两个对象的内容是否相等，即内存地址可以不一样，内容一样就可以了。默认会调用对象的 \_\_eq\_\_()方法。  </span><br><span class="line"># 对于int 小数据池  </span><br><span class="line">  范围：-5 到 256 创建的相间的数字，都指向同一个内存地址</span><br><span class="line"></span><br><span class="line"># 对于字符串 （面试）  </span><br><span class="line">1、小数据池 如果有空格，那指向两个内存地址，  </span><br><span class="line">2、长度不能超过 20  </span><br><span class="line">3、不能用特殊字符</span><br><span class="line"></span><br><span class="line">i &#x3D; &#39;a&#39;*20  </span><br><span class="line">j &#x3D; &#39;a&#39;*20  </span><br><span class="line">print(i is j)   # True</span><br><span class="line"></span><br><span class="line">i &#x3D; &quot;a&quot;*21  </span><br><span class="line">j &#x3D; &quot;a&quot;*21  </span><br><span class="line">print(i is j)   # False</span><br></pre></td></tr></table></figure>
<p>27、谈谈Python的深浅拷贝？以及实现方法和应用场景。</p>
<p>浅拷贝只是增加了一个指针指向一个存在的地址，而深拷贝是增加一个指针并且开辟了新的内存，这个增加的指针指向这个新的内存，采用浅拷贝的情况，释放内存，会释放同一内存，深拷贝就不会出现释放同一内存的错误</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一层的情况：</span></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 浅拷贝</span></span><br><span class="line">li1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">li2 = li1.copy()</span><br><span class="line">li1.append(<span class="number">4</span>)</span><br><span class="line">print(li1, li2)  <span class="comment"># [1, 2, 3, 4] [1, 2, 3]</span></span><br><span class="line"><span class="comment"># 深拷贝</span></span><br><span class="line">li1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">li2 = copy.deepcopy(li1)</span><br><span class="line">li1.append(<span class="number">4</span>)</span><br><span class="line">print(li1, li2)  <span class="comment"># [1, 2, 3, 4] [1, 2, 3]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 多层的情况：</span></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 浅拷贝 指向共有的地址</span></span><br><span class="line">li1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>],<span class="number">6</span>]</span><br><span class="line">li2 = li1.copy()</span><br><span class="line">li1[<span class="number">3</span>].append(<span class="number">7</span>)</span><br><span class="line">print(li1, li2)  <span class="comment"># [1, 2, 3, [4, 5, 7], 6] [1, 2, 3, [4, 5, 7], 6]</span></span><br><span class="line"><span class="comment"># 深拷贝 重指向</span></span><br><span class="line">li1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>],<span class="number">6</span>]</span><br><span class="line">li2 = copy.deepcopy(li1)</span><br><span class="line">li1[<span class="number">3</span>].append(<span class="number">7</span>)</span><br><span class="line">print(li1, li2)  <span class="comment"># [1, 2, 3, [4, 5, 7], 6] [1, 2, 3, [4, 5], 6]</span></span><br></pre></td></tr></table></figure>
<p>50. 常用字符串格式化哪几种？</p>
<ol>
<li>占位符%: %d 表示那个位置是整数；%f 表示浮点数；%s 表示字符串。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(&#39;Hello,%s&#39; % &#39;Python&#39;)  </span><br><span class="line">print(&#39;Hello,%d%s%.2f&#39; % (666, &#39;Python&#39;, 9.99)) # 打印：Hello,666Python10.00</span><br></pre></td></tr></table></figure></li>
<li>format <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(&#39;&#123;k&#125; is &#123;v&#125;&#39;.format(k&#x3D;&#39;python&#39;, v&#x3D;&#39;easy&#39;))  # 通过关键字  </span><br><span class="line">print(&#39;&#123;0&#125; is &#123;1&#125;&#39;.format(&#39;python&#39;, &#39;easy&#39;))      # 通过关键字</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>51. 简述 生成器、迭代器、可迭代对象 以及应用场景？</p>
<ul>
<li>迭代器：含有__iter__和__next__方法 (包含__next__方法的可迭代对象就是迭代器)  </li>
<li>生成器：包括含有yield这个关键字，生成器也是迭代器，调动next把函数变成迭代器。  </li>
<li>应用场景：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">1、range&#x2F;xrange  </span><br><span class="line">    - py2： range(1000000) 会立即创建，xrange(1000000)生成器  </span><br><span class="line">    - py3：range（10000000）生成器 </span><br><span class="line"></span><br><span class="line">2、redis获取值hscan_iter用到了  </span><br><span class="line">conn &#x3D; Redis(...)</span><br><span class="line"></span><br><span class="line">def hscan_iter(self, name, match&#x3D;None, count&#x3D;None):  </span><br><span class="line">    cursor &#x3D; &#39;0&#39;  </span><br><span class="line">    while cursor !&#x3D; 0:  </span><br><span class="line">        # 去redis中获取数据：12  </span><br><span class="line">        # cursor，下一次取的位置  </span><br><span class="line">        # data：本地获取的12条数数据  </span><br><span class="line">        cursor, data &#x3D; self.hscan(name, cursor&#x3D;cursor,match&#x3D;match, count&#x3D;count)  </span><br><span class="line">        for item in data.items():  </span><br><span class="line">             yield item</span><br><span class="line"></span><br><span class="line">3、stark组件</span><br><span class="line">def index(request):</span><br><span class="line">    data &#x3D; [  </span><br><span class="line">        &#123;&#39;k1&#39;:1,&#39;name&#39;:&#39;alex&#39;&#125;,</span><br><span class="line">        &#123;&#39;k1&#39;:2,&#39;name&#39;:&#39;老男孩&#39;&#125;,</span><br><span class="line">        &#123;&#39;k1&#39;:3,&#39;name&#39;:&#39;小男孩&#39;&#125;,</span><br><span class="line">    ]  </span><br><span class="line">    new_data &#x3D; []</span><br><span class="line">    for item in data:</span><br><span class="line">        item[&#39;email&#39;] &#x3D; &quot;xxx@qq.com&quot;</span><br><span class="line">        new_data.append(item)</span><br><span class="line"></span><br><span class="line">    return render(request,&#39;xx.html&#39;,&#123;&#39;data&#39;:new_data&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>可迭代对象：一个类内部实现__iter__方法且返回一个迭代器。  </li>
<li>应用场景：   <ul>
<li>wtforms中对form对象进行循环时候，显示form中包含的所有字段。    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class LoginForm(Form):  </span><br><span class="line">    name &#x3D; simple.StringField(  </span><br><span class="line">        label&#x3D;&#39;用户名&#39;,  </span><br><span class="line">        validators&#x3D;\[  </span><br><span class="line">            validators.DataRequired(message&#x3D;&#39;用户名不能为空.&#39;),  </span><br><span class="line">            validators.Length(min&#x3D;6, max&#x3D;18, message&#x3D;&#39;用户名长度必须大于%(min)d且小于%(max)d&#39;)  </span><br><span class="line">        \],  </span><br><span class="line">        widget&#x3D;widgets.TextInput(),  </span><br><span class="line">        render\_kw&#x3D;&#123;&#39;class&#39;: &#39;form-control&#39;&#125;  </span><br><span class="line">    )  </span><br><span class="line">    pwd &#x3D; simple.PasswordField(  </span><br><span class="line">        label&#x3D;&#39;密码&#39;,  </span><br><span class="line">        validators&#x3D;\[  </span><br><span class="line">            validators.DataRequired(message&#x3D;&#39;密码不能为空.&#39;),  </span><br><span class="line">            validators.Length(min&#x3D;8, message&#x3D;&#39;用户名长度必须大于%(min)d&#39;),  </span><br><span class="line">            validators.Regexp(regex&#x3D;&quot;^(?&#x3D;.\*\[a-z\])(?&#x3D;.\*\[A-Z\])(?&#x3D;.\*\\d)(?&#x3D;.\*\[$@$!%\*?&amp;\])\[A-Za-z\\d$@$!%\*?&amp;\]&#123;8,&#125;&quot;,  </span><br><span class="line">                              message&#x3D;&#39;密码至少8个字符，至少1个大写字母，1个小写字母，1个数字和1个特殊字符&#39;)</span><br><span class="line"></span><br><span class="line">        \],  </span><br><span class="line">        widget&#x3D;widgets.PasswordInput(),  </span><br><span class="line">        render\_kw&#x3D;&#123;&#39;class&#39;: &#39;form-control&#39;&#125;  </span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">form &#x3D; LoginForm()  </span><br><span class="line">for item in form:  </span><br><span class="line">    print(item)</span><br></pre></td></tr></table></figure></li>
<li>列表、字典、元组</li>
</ul>
</li>
</ul>
<p>装饰器  </p>
<p>能够在不修改原函数代码的基础上，在执行前后进行定制操作，闭包函数的一种应用  </p>
<p>场景：</p>
<ul>
<li>flask路由系统</li>
<li>flask before_request</li>
<li>csrf</li>
<li>django内置认证</li>
<li>django缓存</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 手写装饰器；</span><br><span class="line">import functools  </span><br><span class="line">def wrapper(func):  </span><br><span class="line">   @functools.wraps(func)  #不改变原函数属性  </span><br><span class="line">   def inner(*args, **kwargs):  </span><br><span class="line">        # 执行函数前  </span><br><span class="line">        a &#x3D; func(*args, **kwargs)  </span><br><span class="line">        # 执行函数后</span><br><span class="line">        return a</span><br><span class="line">   return inner</span><br><span class="line">1\. 执行wapper函数，并将被装饰的函数当做参数。 wapper(index)  </span><br><span class="line">2\. 将第一步的返回值，重新赋值给  新index &#x3D;  wapper(老index)  </span><br><span class="line">@wrapper    #index&#x3D;wrapper(index)  </span><br><span class="line">def index(x):  </span><br><span class="line">   return x+100</span><br></pre></td></tr></table></figure>
<p>调用装饰器其实是一个闭包函数，为其他函数添加附加功能，不修改被修改的源代码和不修改被修饰的方式，装饰器的返回值也是一个函数对象。  </p>
<p>比如：插入日志、性能测试、事物处理、缓存、权限验证等，有了装饰器，就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。</p>
<p>53. 谈谈你对闭包的理解？</p>
<p>判断闭包函数的方法：__closure__，输出的__closure__有cell元素说明是闭包函数<br>闭包的意义与应用：延迟计算：<br>bar在foo函数的代码块中定义。我们称bar是foo的内部函数。<br>在bar的局部作用域中可以直接访问foo局部作用域中定义的m、n变量。<br>简单的说，这种内部函数可以使用外部函数变量的行为，就叫闭包。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def foo():  </span><br><span class="line">    m&#x3D;3  </span><br><span class="line">    n&#x3D;5  </span><br><span class="line">    def bar():  </span><br><span class="line">        a&#x3D;4  </span><br><span class="line">        return m+n+a  </span><br><span class="line">    return bar  </span><br><span class="line">    </span><br><span class="line">bar &#x3D;  foo()  </span><br><span class="line">bar()        # 12</span><br></pre></td></tr></table></figure>
<p>28、Python垃圾回收机制？</p>
<p>参考：<a href="https://mp.csdn.net/console/editor/html/105855612" target="_blank" rel="noopener" title="Python内存管理以及垃圾回收机制">Python内存管理以及垃圾回收机制</a></p>
<p>Python垃圾回收机制,主要使用’引用计数’来跟踪和回收垃圾。<br>在’引用计数’的基础上，通过’标记-清除’（mark and sweep）解决容器对象可能产生的循环引用问题.<br>通过’分代回收’以空间换时间的方法提高垃圾回收效率。</p>
<p>‘引用计数’<br>PyObject是每个对象必有的内容，其中ob_refcnt就是做为引用计数。<br>当一个对象有新的引用时，它的ob_refcnt就会增加，当引用它的对象被删除，<br>它的ob_refcnt就会减少.引用计数为0时，该对象生命就结束了。<br>优点:1.简单 2.实时性<br>缺点:1.维护引用计数消耗资源 2.存在循环引用的话，不能删除</p>
<p>‘标记-清楚机制’<br>基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，<br>遍历以对象为节点、以引用为边构成的图，把所有可以访问到的对象打上标记，<br>然后清扫一遍内存空间，把所有没标记的对象释放。</p>
<p>‘分代技术’<br>分代回收的整体思想是：<br>将系统中的所有内存块根据其存活时间划分为不同的集合，每个集合就成为一个“代”，<br>垃圾收集频率随着“代”的存活时间的增大而减小，存活时间通常利用经过几次垃圾回收来度量。</p>
<p>29、Python的可变类型和不可变类型？</p>
<p>可变数据类型：列表、字典、可变集合<br>不可变数据类型：数字、字符串、元组、不可变集合</p>
<p>32、列举常见的内置函数</p>
<ul>
<li>abs() # 返回数字的绝对值</li>
<li>map() # 根据函数对指定序列做映射，函数接收两个参数，一个是函数，一个是可迭代对象，map将传入的函数依次作用到序列的每个元素，并把结果作为新的list返回。<br>  返回值：<br>  Python2  返回列表<br>  Python3  返回迭代器  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 例子1：  </span><br><span class="line">def mul(x):  </span><br><span class="line">    return x*x  </span><br><span class="line">n &#x3D; [1,2,3,4,5]  </span><br><span class="line">res &#x3D; list(map(mul,n))  </span><br><span class="line">print(res)         # [1, 4, 9, 16, 25]</span><br><span class="line"></span><br><span class="line"># 例子2：abs()  返回数字的绝对值  </span><br><span class="line">ret &#x3D; map(abs,[-1,-5,6,-7])  </span><br><span class="line">print(list(ret))    # [1, 5, 6, 7]</span><br></pre></td></tr></table></figure></li>
<li><p>filter() # 函数接收一个函数 f(函数)和一个list（可迭代对象），这个函数 f的作用是对每个元素进行判断，返回 True或 False，根据判断结果自动过滤掉不符合条件的元素，返回由符合条件元素组成的新list。  </p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def is_odd(x):  </span><br><span class="line">    return x % 2 &#x3D;&#x3D; 1  </span><br><span class="line">v&#x3D;list(filter(is_odd, [1, 4, 6, 7, 9, 12, 17]))  </span><br><span class="line">print(v)      # [1, 7, 9, 17]</span><br></pre></td></tr></table></figure>
</li>
<li><p>map与filter总结</p>
<ul>
<li>相同点<br>参数: 都是一个函数名 + 可迭代对象<br>返回值: 都是返回可迭代对象</li>
<li>区别:<br>filter 是做筛选的，结果还是原来就在可迭代对象中的项<br>map 是对可迭代对象中每一项做操作的，结果不一定是原来就在可迭代对象中的项</li>
</ul>
</li>
<li><p>isinstance和type  </p>
</li>
<li>isinstance() 函数来判断一个对象是否是一个已知的类型，类似 type()。  </li>
<li><p>isinstance() 与 type() 区别：<br>  type() 不会认为子类是一种父类类型，不考虑继承关系。<br>  isinstance() 会认为子类是一种父类类型，考虑继承关系。<br>  如果要判断两个类型是否相同推荐使用 isinstance()。  </p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; 2  </span><br><span class="line">print(isinstance(a,int))   # True  </span><br><span class="line">print(isinstance(a,str))   # False</span><br><span class="line"></span><br><span class="line"># type() 与 isinstance() 区别  </span><br><span class="line">class A:  </span><br><span class="line">    pass  </span><br><span class="line">class B(A):  </span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">print(&quot;isinstance&quot;,isinstance(A(),A))    # isinstance True  </span><br><span class="line">print(&quot;type&quot;,type(A())  &#x3D;&#x3D; A)            # type True</span><br><span class="line"></span><br><span class="line">print(&#39;isinstance&#39;,isinstance(B(),A) )   # isinstance True  </span><br><span class="line">print(&#39;type&#39;,type(B()) &#x3D;&#x3D; A)             # type False</span><br></pre></td></tr></table></figure>
</li>
<li><p>zip 拉链函数，用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。<br>  将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表迭代器。<br>  如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同。  </p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print(list(zip([0,1,3],[5,6,7],\[&#39;a&#39;,&#39;b&#39;])))    # [(0, 5, &#39;a&#39;), (1, 6, &#39;b&#39;)]  </span><br><span class="line">a &#x3D; [1,2,3]  </span><br><span class="line">b &#x3D; [4,5,6]  </span><br><span class="line">c &#x3D; [4,5,6,7,8]  </span><br><span class="line">zipped &#x3D; zip(a,b)     # 打包为元组的列表  [(1, 4), (2, 5), (3, 6)]  </span><br><span class="line">zip(a,c)              # 元素个数与最短的列表一致  [(1, 4), (2, 5), (3, 6)]  </span><br><span class="line">zip(*zipped)          # 与 zip 相反，可理解为解压，返回二维矩阵式  [(1, 2, 3), (4, 5, 6)]</span><br></pre></td></tr></table></figure>
</li>
<li><p>reduce # 函数会对参数序列中元素进行累积，函数将一个数据集合(链表、元组等)中的所有数据进行下列操作<br>  注意：Python3已经将reduce() 函数从全局名字空间里移除了，它现在被放置在 fucntools 模块里，如果想要使用它，则需要通过引入 functools 模块来调用 reduce() 函数：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from functools import reduce  </span><br><span class="line">def add(x,y):  </span><br><span class="line">    return x + y</span><br><span class="line"></span><br><span class="line">print(reduce(add,\[1,2,3,4,5\]))  #  15  </span><br><span class="line">print(reduce(lambda x, y: x+y, \[1,2,3,4,5\]))  # 15  </span><br><span class="line">print(reduce(add,range(1,101)))  #  5050</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>67、 什么是反射？以及应⽤用场景？</p>
<p>反射的核心本质就是以字符串的形式去导入个模块，利用字符串的形式去执行函数。<br>Django中的 CBV就是基于反射实现的。</p>
<h2 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h2><p>35、 如何安装第三方模块？以及用过哪些第三方模块？</p>
<ol>
<li>pip包管理器  </li>
<li><p>源码下载,解压  </p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python setup.py build  </span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>36、常用模块都有那些？</p>
<p>re：正则<br>os：提供了一种方便的使用操作系统函数的方法。<br>sys：可供访问由解释器使用或维护的变量和与解释器进行交互的函数。<br>random：随机数<br>json：序列化<br>time：时间<br>datatime<br>logging<br>hlib<br>math，<br>爬虫里面的requests/beautifulsoup4（bs4）<br>pymysql：链接数据库</p>
<h3 id="re-模块"><a href="#re-模块" class="headerlink" title="re 模块"></a>re 模块</h3><p>37、re的match和search区别？</p>
<ul>
<li>re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。  </li>
<li>re.search 扫描整个字符串并返回第一个成功的匹配。</li>
</ul>
<p>38、什么是正则的贪婪匹配？</p>
<p>匹配一个字符串没有节制，能匹配多少就去匹配多少，直到没有匹配的为止</p>
<h3 id="logging"><a href="#logging" class="headerlink" title="logging"></a>logging</h3><p>logging模块的作用？以及应用场景？</p>
<p>logging 模块定义的函数和类为应用程序和库的开发实现了一个灵活的事件日志系统</p>
<p>作用：可以了解程序运行情况，是否正常，在程序的出现故障快速定位出错地方及故障分析</p>
<p>日志级别：</p>
<ul>
<li>DEBUG：详细的信息,通常只出现在诊断问题上  </li>
<li>INFO：确认一切按预期运行  </li>
<li>WARNING：一个迹象表明,一些意想不到的事情发生了,或表明一些问题在不久的将来(例如。磁盘空间低”)。这个软件还能按预期工作。  </li>
<li>ERROR：更严重的问题,软件没能执行一些功能  </li>
<li>CRITICAL：一个严重的错误,这表明程序本身可能无法继续运行</li>
</ul>
<h3 id="os和sys模块"><a href="#os和sys模块" class="headerlink" title="os和sys模块"></a>os和sys模块</h3><ul>
<li>os模块负责程序与操作系统的交互，提供了访问操作系统底层的接口;  </li>
<li>sys模块负责程序与python解释器的交互，提供了一系列的函数和变量，用于操控python的运行时环境。</li>
</ul>
<p>os与sys模块的官方解释如下：<br>os: This module provides a portable way of using operating system dependent functionality.<br>这个模块提供了一种方便的使用操作系统函数的方法。<br>sys: This module provides access to some variables used or maintained by the interpreter and to functions that interact strongly with the interpreter.<br>这个模块可供访问由解释器使用或维护的变量和与解释器进行交互的函数。  </p>
<p>os 常用方法<br>os.remove() 删除文件<br>os.rename() 重命名文件<br>os.walk() 生成目录树下的所有文件名<br>os.chdir() 改变目录<br>os.mkdir/makedirs 创建目录/多层目录<br>os.rmdir/removedirs 删除目录/多层目录<br>os.listdir() 列出指定目录的文件<br>os.getcwd() 取得当前工作目录<br>os.chmod() 改变目录权限<br>os.path.basename() 去掉目录路径，返回文件名<br>os.path.dirname() 去掉文件名，返回目录路径<br>os.path.join() 将分离的各部分组合成一个路径名<br>os.path.split() 返回( dirname(), basename())元组<br>os.path.splitext() 返回 (filename, extension) 元组<br>os.path.getatime\ctime\mtime 分别返回最近访问、创建、修改时间<br>os.path.getsize() 返回文件大小<br>os.path.exists() 是否存在<br>os.path.isabs() 是否为绝对路径<br>os.path.isdir() 是否为目录<br>os.path.isfile() 是否为文件  </p>
<p>sys 常用方法<br>sys.argv 命令行参数List，第一个元素是程序本身路径<br>sys.modules.keys() 返回所有已经导入的模块列表<br>sys.exc_info() 获取当前正在处理的异常类,exc_type、exc_value、exc_traceback当前处理的异常详细信息<br>sys.exit(n) 退出程序，正常退出时exit(0)<br>sys.hexversion 获取Python解释程序的版本值，16进制格式如：0x020403F0<br>sys.version 获取Python解释程序的版本信息<br>sys.maxint 最大的Int值<br>sys.maxunicode 最大的Unicode值<br>sys.modules 返回系统导入的模块字段，key是模块名，value是模块<br>sys.path 返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值<br>sys.platform 返回操作系统平台名称<br>sys.stdout 标准输出<br>sys.stdin 标准输入<br>sys.stderr 错误输出<br>sys.exc_clear() 用来清除当前线程所出现的当前的或最近的错误信息<br>sys.exec_prefix 返回平台独立的python文件安装的位置<br>sys.byteorder 本地字节规则的指示器，big-endian平台的值是’big’,little-endian平台的值是’little’<br>sys.copyright 记录python版权相关的东西<br>sys.api_version 解释器的C的API版本  </p>
<h3 id="random"><a href="#random" class="headerlink" title="random"></a>random</h3><p>如何生成一个随机数？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line"> </span><br><span class="line">print(random.random())          # 用于生成一个0到1的随机符点数: 0 &lt;&#x3D; n &lt; 1.0</span><br><span class="line">print(random.randint(1, 1000))  # 用于生成一个指定范围内的整数</span><br></pre></td></tr></table></figure>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><p>请用代码简答实现stack</p>
<ul>
<li>Stack() 创建一个新的空栈</li>
<li>push(item) 添加一个新的元素item到栈顶</li>
<li>pop() 弹出栈顶元素</li>
<li>peek() 返回栈顶元素</li>
<li>is_empty() 判断栈是否为空</li>
<li>size() 返回栈的元素个数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># 实现一个栈stack,后进先出</span><br><span class="line">class Stack:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.items &#x3D; []</span><br><span class="line"> </span><br><span class="line">    def is_empty(self):</span><br><span class="line">        # 判断是否为空</span><br><span class="line">        return self.items &#x3D;&#x3D; []</span><br><span class="line"> </span><br><span class="line">    def push(self,item):</span><br><span class="line">        # 加入元素</span><br><span class="line">        self.items.append(item)</span><br><span class="line"> </span><br><span class="line">    def pop(self):</span><br><span class="line">        # 弹出元素</span><br><span class="line">        return self.items.pop()</span><br><span class="line"> </span><br><span class="line">    def peek(self):</span><br><span class="line">        # 返回栈顶元素</span><br><span class="line">        return self.items[len(self.items)-1]</span><br><span class="line"> </span><br><span class="line">    def size(self):</span><br><span class="line">        # 返回栈的大小</span><br><span class="line">        return len(self.items)</span><br><span class="line"> </span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    stack &#x3D; Stack()</span><br><span class="line">    stack.push(&quot;H&quot;)</span><br><span class="line">    stack.push(&quot;E&quot;)</span><br><span class="line">    stack.push(&quot;L&quot;)</span><br><span class="line">    print(stack.size())  # 3</span><br><span class="line">    print(stack.peek())  # L </span><br><span class="line">    print(stack.pop())   # L</span><br><span class="line">    print(stack.pop())   # E</span><br><span class="line">    print(stack.pop())   # H</span><br></pre></td></tr></table></figure>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="三大特性以及解释"><a href="#三大特性以及解释" class="headerlink" title="三大特性以及解释"></a>三大特性以及解释</h3><p>面对对象是一种编程思想，以类的眼光来来看待事物的一种方式。将有共同的属性和方法的事物封装到同一个类下面。</p>
<ul>
<li><p>继承：将多个类的共同属性和方法封装到一个父类下面，然后在用这些类来继承这个类的属性和方法</p>
</li>
<li><p>封装：将有共同的属性和方法封装到同一个类下面</p>
<p>  第一层面：创建类和对象会分别创建二者的名称空间，我们只能用类名.或者obj.的方式去访问里面的名字，这本身就是一种封装<br>  第二层面：类中把某些属性和方法隐藏起来(或者说定义成私有的)，只在类的内部使用、外部无法访问，或者留下少量接口（函数）供外部访问。</p>
</li>
<li><p>多态：Python天生是支持多态的。指的是基类的同一个方法在不同的派生类中有着不同的功能</p>
</li>
</ul>
<h3 id="Python面向对象中的继承有什么特点"><a href="#Python面向对象中的继承有什么特点" class="headerlink" title="Python面向对象中的继承有什么特点"></a>Python面向对象中的继承有什么特点</h3><p>继承概念的实现方式主要有2类：实现继承、接口继承。  </p>
<ul>
<li>实现继承是指使用基类的属性和方法而无需额外编码的能力；  </li>
<li>接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力(子类重构爹类方法)；  </li>
</ul>
<p>python 两种类：经典类 新式类<br>python3 新式类 —— 都默认继承object class Animal(object): == class Animal:<br>python2 经典类和新式类 并存<br>        class Animal:  经典类 —— 继承顺序 个别使用方法<br>        class Animal(object):  新式类</p>
<p>继承分为单继承和多继承，Python是支持多继承的<br>如果没有指定基类，python的类会默认继承object类，object是所有python类的基类，它提供了一些常见方法（如__str__）的实现。<br>补充继承的应用（面试题）</p>
<p>1、对象可以调用自己本类和父类的所有方法和属性， 先调用自己的 自己没有才调父类的。谁（对象）调用方法，方法中的self就指向谁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Foo:  </span><br><span class="line">    def __init__(self):  </span><br><span class="line">        self.func()</span><br><span class="line"></span><br><span class="line">    def func(self):  </span><br><span class="line">        print(&#39;Foo.func&#39;)</span><br><span class="line"></span><br><span class="line">class Son(Foo):  </span><br><span class="line">    def func(self):  </span><br><span class="line">        print(&#39;Son.func&#39;)</span><br><span class="line"></span><br><span class="line">s &#x3D; Son()     # Son.func  </span><br><span class="line"># &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;  </span><br><span class="line">class A:  </span><br><span class="line">    def get(self):  </span><br><span class="line">        self.say()</span><br><span class="line"></span><br><span class="line">    def say(self):  </span><br><span class="line">        print(&#39;AAAAA&#39;)</span><br><span class="line"></span><br><span class="line">class B(A):  </span><br><span class="line">    def say(self):  </span><br><span class="line">        print(&#39;BBBBB&#39;)</span><br><span class="line"></span><br><span class="line">b &#x3D; B()  </span><br><span class="line">b.get()   # 输出结果为：BBBBB</span><br></pre></td></tr></table></figure>
<h3 id="面向对象深度优先和广度优先是什么？"><a href="#面向对象深度优先和广度优先是什么？" class="headerlink" title="面向对象深度优先和广度优先是什么？"></a>面向对象深度优先和广度优先是什么？</h3><p>Python的类可以继承多个类，Python的类如果继承了多个类，那么其寻找方法的方式有两种  </p>
<ul>
<li>当类是经典类时，多继承情况下，会按照深度优先方式查找  </li>
<li>当类是新式类时，多继承情况下，会按照广度优先方式查找    </li>
</ul>
<p>简单点说就是：经典类是纵向查找，新式类是横向查找<br>经典类和新式类的区别就是，在声明类的时候，新式类需要加上object关键字。在python3中默认全是新式类</p>
<h3 id="面向对象中super的作用？"><a href="#面向对象中super的作用？" class="headerlink" title="面向对象中super的作用？"></a>面向对象中super的作用？</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用于子类继承基类的方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooParent</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.parent = <span class="string">'I\'m the parent.'</span></span><br><span class="line">        print(<span class="string">'Parent'</span>)</span><br><span class="line">        print(<span class="string">'1111'</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(self, message)</span>:</span></span><br><span class="line">        print(<span class="string">"%s from Parent"</span> % message)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooChild</span><span class="params">(FooParent)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># super(FooChild,self) 首先找到 FooChild 的父类（就是类 FooParent），然后把类FooChild的对象转换为类 FooParent 的对象</span></span><br><span class="line">        super(FooChild, self).__init__()</span><br><span class="line">        print(<span class="string">'Child'</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># def bar(self, message):</span></span><br><span class="line">    <span class="comment">#     # super(FooChild, self).bar(message)</span></span><br><span class="line">    <span class="comment">#     print('Child bar fuction')</span></span><br><span class="line">    <span class="comment">#     print(self.parent)</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    fooChild = FooChild()</span><br><span class="line">    fooChild.bar(<span class="string">'HelloWorld'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="是否使用过functools中的函数？其作用是什么？"><a href="#是否使用过functools中的函数？其作用是什么？" class="headerlink" title="是否使用过functools中的函数？其作用是什么？"></a>是否使用过functools中的函数？其作用是什么？</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用于修复装饰器</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)  # 加在最内层函数正上方</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"> </span><br><span class="line"><span class="meta">@deco</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''哈哈哈哈'''</span></span><br><span class="line">    x = <span class="number">10</span></span><br><span class="line">    print(<span class="string">'from index'</span>)</span><br><span class="line"> </span><br><span class="line">print(index.__name__)</span><br><span class="line">print(index.__doc__)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 加@functools.wraps</span></span><br><span class="line"><span class="comment"># index</span></span><br><span class="line"><span class="comment"># 哈哈哈哈</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 不加@functools.wraps</span></span><br><span class="line"><span class="comment"># wrapper</span></span><br><span class="line"><span class="comment"># None</span></span><br></pre></td></tr></table></figure>
<h3 id="列举面向对象中带双下划线的特殊方法，如：-new-、-init"><a href="#列举面向对象中带双下划线的特殊方法，如：-new-、-init" class="headerlink" title="列举面向对象中带双下划线的特殊方法，如：__new__、__init__"></a>列举面向对象中带双下划线的特殊方法，如：__new__、__init__</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">__iter__：用于迭代器，之所以列表、字典、元组可以进行for循环，是因为类型内部定义了 __iter__。</span><br><span class="line">__doc__：表示类的描述信息。</span><br><span class="line">__new__：生成实例</span><br><span class="line">__init__：生成实例的属性，构造方法，通过类创建对象时，自动触发执行。</span><br><span class="line">__call__：实例对象加( )会执行def __call__:... 方法里边的内容。</span><br><span class="line">__del__：析构方法，当对象在内存中被释放时，自动触发执行。如当 del obj 或者应用程序运行完毕时，执行该方法里边的内容。</span><br><span class="line">__enter__和__exit__：出现with语句,对象的__enter__被触发,有返回值则赋值给as声明的变量；with中代码块执行完毕时执行__exit__里边的内容。</span><br><span class="line">__module__：表示当前操作的对象在那个模块   obj.__module__</span><br><span class="line">__class__ ：表示当前操作的对象的类是什么     obj.__class____doc__：类的描述信息，该描述信息无法被继承</span><br><span class="line">__str__：改变对象的字符串显示 print函数 ---&gt;obj.__str__()如果一个类中定义了__str__方法，那么在打印对象时，默认输出该方法的返回值。</span><br><span class="line">__repr__：改变对象的字符串显示 交互式解释器 ---&gt;obj.__repr__()</span><br><span class="line">__format__：自定制格式化字符串__slots__:一个类变量 用来限制实例可以添加的属性的数量和类型</span><br><span class="line">__dict__：类或对象中的所有成员。</span><br><span class="line">__setitem__,__getitem,__delitem__:用于索引操作，如字典。以上分别表示获取、设置、删除数据。</span><br><span class="line"></span><br><span class="line">class Foo:</span><br><span class="line">    def __init__(self,name):</span><br><span class="line">        self.name&#x3D;name</span><br><span class="line"> </span><br><span class="line">    def __getitem__(self, item):</span><br><span class="line">        print(self.__dict__[item])</span><br><span class="line"> </span><br><span class="line">    def __setitem__(self, key, value):</span><br><span class="line">        self.__dict__[key]&#x3D;value</span><br><span class="line"> </span><br><span class="line">    def __delitem__(self, key):</span><br><span class="line">        print(&#39;del obj[key]时,我执行&#39;)</span><br><span class="line">        self.__dict__.pop(key)</span><br><span class="line"> </span><br><span class="line">    def __delattr__(self, item):</span><br><span class="line">        print(&#39;del obj.key时,我执行&#39;)</span><br><span class="line">        self.__dict__.pop(item)</span><br><span class="line"> </span><br><span class="line">f1&#x3D;Foo(&#39;sb&#39;)</span><br><span class="line">f1[&#39;age&#39;]&#x3D;18</span><br><span class="line">f1[&#39;age1&#39;]&#x3D;19</span><br><span class="line">del f1.age1</span><br><span class="line">del f1[&#39;age&#39;]</span><br><span class="line">f1[&#39;name&#39;]&#x3D;&#39;alex&#39;</span><br><span class="line">print(f1.__dict__)</span><br><span class="line">__get__():调用一个属性时,触发</span><br><span class="line">__set__():为一个属性赋值时,触发</span><br><span class="line">__delete__():采用del删除属性时,触发</span><br></pre></td></tr></table></figure>
<h3 id="如何判断是函数还是方法？"><a href="#如何判断是函数还是方法？" class="headerlink" title="如何判断是函数还是方法？"></a>如何判断是函数还是方法？</h3><ul>
<li>看他的调用者是谁，如果是类，就需要传入一个参数self的值，这时他就是一个函数</li>
<li>如果调用者是对象，就不需要给self传入参数值，这时他就是一个方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = <span class="string">'lcg'</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.name)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">obj = Foo()</span><br><span class="line">print(obj.func)  <span class="comment"># &lt;bound method Foo.func of &lt;__main__.Foo object at 0x000001ABC0F15F98&gt;&gt;</span></span><br><span class="line">print(Foo.func)  <span class="comment"># &lt;function Foo.func at 0x000001ABC1F45BF8&gt;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> FunctionType, MethodType</span><br><span class="line">print(isinstance(obj.func, FunctionType))  <span class="comment"># False</span></span><br><span class="line">print(isinstance(obj.func, MethodType))    <span class="comment"># True</span></span><br><span class="line"> </span><br><span class="line">print(isinstance(Foo.func, FunctionType))  <span class="comment"># True</span></span><br><span class="line">print(isinstance(Foo.func, MethodType))    <span class="comment"># False</span></span><br><span class="line"> </span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">注意：</span></span><br><span class="line"><span class="string">    方法，无需传入self参数</span></span><br><span class="line"><span class="string">    函数，必须手动传入self参数</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<h3 id="静态方法和类方法区别？"><a href="#静态方法和类方法区别？" class="headerlink" title="静态方法和类方法区别？"></a>静态方法和类方法区别？</h3><p>尽管 classmethod 和 staticmethod 非常相似，但在用法上依然有一些明显的区别。</p>
<p>classmethod 必须有一个指向类对象的引用作为第一个参数，而 staticmethod 可以没有任何参数。举个栗子:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Num</span>:</span></span><br><span class="line">    <span class="comment"># 普通方法：能用Num调用而不能用实例化对象调用   </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">one</span><span class="params">()</span>:</span>  </span><br><span class="line">        <span class="keyword">print</span> (<span class="string">'1'</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 实例方法：能用实例化对象调用而不能用Num调用</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">two</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> (<span class="string">'2'</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 静态方法：能用Num和实例化对象调用</span></span><br><span class="line"><span class="meta">    @staticmethod </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">three</span><span class="params">()</span>:</span>  </span><br><span class="line">        <span class="keyword">print</span> (<span class="string">'3'</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 类方法：第一个参数cls长什么样不重要，都是指Num类本身，调用时将Num类作为对象隐式地传入方法   </span></span><br><span class="line"><span class="meta">    @classmethod </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">go</span><span class="params">(cls)</span>:</span> </span><br><span class="line">        cls.three() </span><br><span class="line"> </span><br><span class="line">Num.one()          <span class="comment"># 1</span></span><br><span class="line"><span class="comment">#Num.two()         # TypeError: two() missing 1 required positional argument: 'self'</span></span><br><span class="line">Num.three()        <span class="comment"># 3</span></span><br><span class="line">Num.go()           <span class="comment"># 3</span></span><br><span class="line"> </span><br><span class="line">i=Num()                </span><br><span class="line"><span class="comment">#i.one()           # TypeError: one() takes 0 positional arguments but 1 was given         </span></span><br><span class="line">i.two()            <span class="comment"># 2      </span></span><br><span class="line">i.three()          <span class="comment"># 3</span></span><br><span class="line">i.go()             <span class="comment"># 3</span></span><br></pre></td></tr></table></figure>
<h3 id="metaclass作用？以及应用场景？"><a href="#metaclass作用？以及应用场景？" class="headerlink" title="metaclass作用？以及应用场景？"></a>metaclass作用？以及应用场景？</h3><p>metaclass用来指定类是由谁创建的。</p>
<p>类的metaclass 默认是type。我们也可以指定类的metaclass值。在python3中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class MyType(type):  </span><br><span class="line">    def __call__(self, *args, **kwargs):  </span><br><span class="line">        return &#39;MyType&#39;  </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">class Foo(object, metaclass&#x3D;MyType):  </span><br><span class="line">    def __init__(self):  </span><br><span class="line">        return &#39;init&#39;  </span><br><span class="line">    </span><br><span class="line">    def __new__(cls, *args, **kwargs):  </span><br><span class="line">        return cls.__init__(cls)  </span><br><span class="line">    </span><br><span class="line">    def __call__(self, *args, **kwargs):  </span><br><span class="line">        return &#39;call&#39;  </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">obj &#x3D; Foo()  </span><br><span class="line">print(obj)  # MyType</span><br></pre></td></tr></table></figure>
<p>69. 用尽量多的方法实现单例模式。</p>
<p>一个类可以有多个位置参数和多个命名参数，而在实例化开始之后，在调用 init()方法之前，Python首先调用new()方法：<br>def __new__(cls, *args, **kwargs):</p>
<p>第一个参数cls是当前正在实例化的类。<br>如果要得到当前类的实例，应当在当前类中的new()方法语句中调用当前类的父类 的new()方法。<br>例如，如果当前类是直接继承自object，那当前类的new()方法返回的对象应该为：<br>def __new__(cls, *args, **kwargs):<br>    …<br>    return object.__new__(cls)<br>事实上如果（新式）类中没有重写new()方法，即在定义新式类时没有重新定义new()时 ，<br>Python默认是调用该类的直接父类的new()方法来构造该类的实例，如果该类的父类也没有重写 new()，<br>那么将一直按此规矩追溯至object的new()方法，因为object是所有新式类的基类。<br>而如果新式类中重写了new()方法，那么你可以自由选择任意一个的其他的新式类（必定要是 新式类，只有新式类必定都有new()，<br>因为所有新式类都是object的后代，而经典类则没有new() 方法）的new()方法来制造实例，<br>包括这个新式类的所有前代类和后代类，只要它们不会造成递归死 循环</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单例模式</span></span><br><span class="line"><span class="string">'''单例模式是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例类的特殊类。</span></span><br><span class="line"><span class="string">通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。</span></span><br><span class="line"><span class="string">如果希望在系统中某个类的对象只能存在一个，单例模式是最好的解决方案。'''</span></span><br><span class="line"><span class="comment"># 1、使用__new__方法</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kw)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> hasattr(cls, <span class="string">'_instance'</span>):</span><br><span class="line">                orig = super(Singleton, cls) <span class="comment"># 其实就是object</span></span><br><span class="line">                cls._instance = orig.__new__(cls, *args, **kw)</span><br><span class="line">            <span class="keyword">return</span> cls._instance</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(Singleton)</span>:</span></span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line"><span class="comment"># 2、共享属性</span></span><br><span class="line"><span class="comment"># 创建实例时把所有实例的__dict__指向同一个字典,这样它们具有相同的属性和方法.</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Borg</span><span class="params">(object)</span>:</span></span><br><span class="line">        _state = &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kw)</span>:</span></span><br><span class="line">            ob = super(Borg, cls).__new__(cls, *args, **kw)</span><br><span class="line">            ob.__dict__ = cls._state</span><br><span class="line">            <span class="keyword">return</span> ob</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyClass2</span><span class="params">(Borg)</span>:</span></span><br><span class="line">        a = <span class="number">1</span></span><br><span class="line"><span class="comment"># 3、装饰器版本</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleton</span><span class="params">(cls, *args, **kw)</span>:</span></span><br><span class="line">        instances = &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">getinstance</span><span class="params">()</span>:</span></span><br><span class="line">            <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> instances:</span><br><span class="line">                instances[cls] = cls(*args, **kw)</span><br><span class="line">            <span class="keyword">return</span> instances[cls]</span><br><span class="line">        <span class="keyword">return</span> getinstance</span><br><span class="line"><span class="meta">    @singleton</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></span><br><span class="line">    ...</span><br><span class="line"><span class="comment"># 4、import方法</span></span><br><span class="line"><span class="comment"># 作为python的模块是天然的单例模式</span></span><br><span class="line">    <span class="comment"># mysingleton.py</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">My_Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    my_singleton = My_Singleton()</span><br><span class="line">    <span class="comment"># to use</span></span><br><span class="line">    <span class="keyword">from</span> mysingleton <span class="keyword">import</span> my_singleton</span><br><span class="line">    my_singleton.foo()</span><br></pre></td></tr></table></figure>
<p>70. 装饰器的写法以及应用场景。</p>
<p>含义：装饰器本质就是函数，为其他函数添加附加功能<br>原则：不修改被修饰函数的代码，不修改被修饰函数的调用方式<br>应用场景：无参装饰器在用户登录 认证中常见，有参装饰器在flask的路由系统中见到过<br>import functools<br>def wrapper(func):<br>    @functools.wraps(func)<br>    def inner(*args, **kwargs):<br>        print(‘我是装饰器’)<br>        return func<br>return inner</p>
<p>@wrapper<br>def index():<br>    print(‘我是被装饰函数’)<br>    return None<br>index()</p>
<p># 应用场景  </p>
<pre><code>- 高阶函数  
- 闭包  
- 装饰器   
- functools.wraps(func)
</code></pre><p>71. 异常处理写法以及如何主动抛出异常（应用场景）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 触发异常</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">temp_convert</span><span class="params">(var)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> int(var)</span><br><span class="line">    <span class="keyword">except</span> ValueError <span class="keyword">as</span> Argument:</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">"参数没有包含数字%s"</span>%Argument)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">temp_convert(<span class="string">"xyz"</span>)</span><br><span class="line"><span class="comment"># 以10为基数的int()的无效文字:“xyz”</span></span><br><span class="line"> </span><br><span class="line">----------------------------------------------------------------------------</span><br><span class="line"><span class="comment"># raise语法</span></span><br><span class="line"><span class="comment"># raise [Exception [, args [, traceback]]]</span></span><br><span class="line"><span class="comment"># 语句中 Exception 是异常的类型，args 是自已提供的异常参数。</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Networkerror</span><span class="params">(RuntimeError)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        self.args = arg</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> Networkerror(<span class="string">"Bad hostname"</span>)</span><br><span class="line"><span class="keyword">except</span> Networkerror <span class="keyword">as</span> e:</span><br><span class="line">    print(e.args)</span><br></pre></td></tr></table></figure>
<p>72、什么是面向对象的mro</p>
<p>mro就是方法解析顺序</p>
<p>73. isinstance作用以及应用场景？</p>
<p>isinstance(对象，类)  判断这个对象是不是这个类或者这个类的子类的实例化</p>
<p># # 判断a 属不属于A这个类（可以判断到祖宗类）<br>class A:<br>    pass</p>
<p>class B(A):<br>    pass<br>a = A()<br>b = B()<br>print(isinstance(b,A)) # ===True  判断到祖宗类</p>
<p># 任何与object都是True,内部都继承object<br>class A:pass<br>a = A()  # 实例化<br>print(isinstance(a,object))  #  True<br>应用场景：rest framework 认证的流程</p>
<p>scrapy-redis</p>
<p>74. 写代码并实现</p>
<p>Given an array of integers, return indices of the two numbers such that they add up to a<br>specific target.You may assume that each input would have exactly one solution, and you may<br>not use the same element twice.<br>Example:<br>Given nums = [2, 7, 11, 15], target = 9,<br>Because nums[0] + nums[1] = 2 + 7 = 9,<br>return [0, 1]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">      <span class="string">""" </span></span><br><span class="line"><span class="string">      :type nums: List[int] </span></span><br><span class="line"><span class="string">      :type target: int </span></span><br><span class="line"><span class="string">      :rtype: List[int] </span></span><br><span class="line"><span class="string">      """</span></span><br><span class="line">      <span class="comment"># 用len()方法取得nums列表长度  </span></span><br><span class="line">      n = len(nums)</span><br><span class="line">      <span class="comment"># x从0到n取值（不包括n）  </span></span><br><span class="line">      <span class="keyword">for</span> x <span class="keyword">in</span> range(n):</span><br><span class="line">         a = target - nums[x]</span><br><span class="line">         <span class="comment"># 用in关键字查询nums列表中是否有a  </span></span><br><span class="line">         <span class="keyword">if</span> a <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># 用index函数取得a的值在nums列表中的索引  </span></span><br><span class="line">            y = nums.index(a)</span><br><span class="line">            <span class="comment"># 假如x=y,那么就跳过,否则返回x,y  </span></span><br><span class="line">            <span class="keyword">if</span> x == y:</span><br><span class="line">               <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">               <span class="keyword">return</span> x, y</span><br><span class="line">               <span class="keyword">break</span></span><br><span class="line">         <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>
<p>75. json序列化时，可以处理的数据类型有哪些？如何定制支持datetime类型？</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 可序列化数据类型：</span></span><br><span class="line">字典、列表、数字、字符串、元组；如果是元组，自动转成列表（再转回去的话也是列表）</span><br><span class="line"><span class="meta"># 自定义时间序列化转换器</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="title">from</span> json <span class="keyword">import</span> JSONEncoder</span><br><span class="line"><span class="title">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">ComplexEncoder</span>(<span class="type">JSONEncoder</span>):</span></span><br><span class="line"><span class="class">    def default(<span class="title">self</span>, <span class="title">obj</span>):</span></span><br><span class="line"><span class="class">        if isinstance(<span class="title">obj</span>, <span class="title">datetime</span>):</span></span><br><span class="line"><span class="class">            return obj.strftime('%<span class="type">Y</span>-%<span class="title">m</span>-%<span class="title">d</span> %<span class="type">H</span>:%<span class="type">M</span>:%<span class="type">S</span>')</span></span><br><span class="line"><span class="class">        else:</span></span><br><span class="line"><span class="class">            return super(<span class="type">ComplexEncoder</span>,<span class="title">self</span>).default(<span class="title">obj</span>)</span></span><br><span class="line"><span class="class">d = &#123; 'name':'alex','data':datetime.now()&#125;</span></span><br><span class="line"><span class="class">print(<span class="title">json</span>.<span class="title">dumps</span>(<span class="title">d</span>,<span class="title">cls</span>=<span class="type">ComplexEncoder</span>))</span></span><br><span class="line"><span class="class"># &#123;"name": "alex", "data": "2018-05-18 19:52:05"&#125;</span></span><br></pre></td></tr></table></figure>
<p>76. json序列化时，默认遇到中文会转换成unicode，如果想要保留中文怎么办？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line">a=json.dumps(&#123;<span class="string">"xxx"</span>:<span class="string">"你好"</span>&#125;,ensure_ascii=<span class="literal">False</span>)</span><br><span class="line">print(a) <span class="comment">#&#123;"xxx": "你好"&#125;</span></span><br></pre></td></tr></table></figure>
<p>77. 什么是断言？应用场景？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> 的作用？断言</span><br><span class="line">条件成立（布尔值为<span class="literal">True</span>）则继续往下，否则抛出异常，一般用于：满足某个条件之后，才能执行，否则抛出异常。</span><br><span class="line"> </span><br><span class="line">写API的时候，继承GenericAPIView</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericAPIView</span><span class="params">(views.APIView)</span>:</span></span><br><span class="line">                    <span class="string">"""</span></span><br><span class="line"><span class="string">                    Base class for all other generic views.</span></span><br><span class="line"><span class="string">                    """</span></span><br><span class="line">                    <span class="comment"># You'll need to either set these attributes,</span></span><br><span class="line">                    <span class="comment"># or override `get_queryset()`/`get_serializer_class()`.</span></span><br><span class="line">                    <span class="comment"># If you are overriding a view method, it is important that you call</span></span><br><span class="line">                    <span class="comment"># `get_queryset()` instead of accessing the `queryset` property directly,</span></span><br><span class="line">                    <span class="comment"># as `queryset` will get evaluated only once, and those results are cached</span></span><br><span class="line">                    <span class="comment"># for all subsequent requests.</span></span><br><span class="line">                    queryset = <span class="literal">None</span></span><br><span class="line">                    serializer_class = <span class="literal">None</span></span><br><span class="line"> </span><br><span class="line">                    <span class="comment"># If you want to use object lookups other than pk, set 'lookup_field'.</span></span><br><span class="line">                    <span class="comment"># For more complex lookup requirements override `get_object()`.</span></span><br><span class="line">                    lookup_field = <span class="string">'pk'</span></span><br><span class="line">                    lookup_url_kwarg = <span class="literal">None</span></span><br><span class="line"> </span><br><span class="line">                    <span class="comment"># The filter backend classes to use for queryset filtering</span></span><br><span class="line">                    filter_backends = api_settings.DEFAULT_FILTER_BACKENDS</span><br><span class="line"> </span><br><span class="line">                    <span class="comment"># The style to use for queryset pagination.</span></span><br><span class="line">                    pagination_class = api_settings.DEFAULT_PAGINATION_CLASS</span><br><span class="line"> </span><br><span class="line">                    <span class="function"><span class="keyword">def</span> <span class="title">get_queryset</span><span class="params">(self)</span>:</span></span><br><span class="line"> </span><br><span class="line">                        <span class="keyword">assert</span> self.queryset <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>, (</span><br><span class="line">                            <span class="string">"'%s' should either include a `queryset` attribute, "</span></span><br><span class="line">                            <span class="string">"or override the `get_queryset()` method."</span></span><br><span class="line">                            % self.__class__.__name__</span><br><span class="line">                        )</span><br><span class="line"> </span><br><span class="line">                        queryset = self.queryset</span><br><span class="line">                        <span class="keyword">if</span> isinstance(queryset, QuerySet):</span><br><span class="line">                            <span class="comment"># Ensure queryset is re-evaluated on each request.</span></span><br><span class="line">                            queryset = queryset.all()</span><br><span class="line">                        <span class="keyword">return</span> queryset</span><br></pre></td></tr></table></figure>
<p>78. 有用过with statement吗？它的好处是什么？</p>
<p>with语句适用于对资源进行访问的场合，确保不管使用过程中是否发生异常都会执行必要的“清理”操作， 释放资源，比如文件使用后自动关闭、线程中锁的自动获取和释放等。</p>
<p>79. 使用代码实现查看列举目录下的所有文件。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import <span class="built_in">os</span></span><br><span class="line"><span class="built_in">path</span> = <span class="built_in">os</span>.listdir(<span class="string">'.'</span>) #查看列举目录下的所有文件。</span><br><span class="line"># <span class="built_in">path</span> = <span class="built_in">os</span>.listdir(<span class="built_in">os</span>.getcwd())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">path</span>)</span><br></pre></td></tr></table></figure>
<p>80. 简述 yield和yield from关键字</p>
<p>1、yield使用<br>1）函数中使用yield，可以使函数变成生成器。一个函数如果是生成一个数组，就必须把数据存储在内存中，如果使用生成器，则在调用的时候才生成数据，可以节省内存。<br>2）生成器方法调用时，不会立即执行。需要调用next()或者使用for循环来执行。</p>
<p>2、yield from的使用<br>1）为了让生成器（带yield函数），能简易的在其他函数中直接调用，就产生了yield from。</p>
<p><strong>python是传值还是传引用</strong></p>
<p>python不允许程序员选择采用传值还是传引用。Python参数传递采用的肯定是“传对象引用”的方式。这种方式相当于传值和传引用的一种综合。如果函数收到的是一个可变对象（比如字典或者列表）的引用，就能修改对象的原始值－－相当于通过“传引用”来传递对象。如果函数收到的是一个不可变对象（比如数字、字符或者元组）的引用，就不能直接修改原始对象－－相当于通过“传值’来传递对象</p>

                
                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2016/07/01/interview-面试之Python计算/" data-toggle="tooltip" data-placement="top" title="面试之 Python 基础代码">&larr; Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2014/08/16/other-5-leetcode-dfs-2020-08-17-leetcode-颜色填充/" data-toggle="tooltip" data-placement="top" title="「知乎」如何评价 MIUI 6？">Next Post &rarr;</a>
                    </li>
                    
                </ul>

                <!-- tip start -->
                

                
                <div class="comment_notes">
                    <p>
                        study well and make progress every day; study well and progress every day; study hard and make progress every day.
                    </p>
                </div>
                
                <!-- tip end -->

                <!-- Music start-->
                
                <!-- Music end -->

                <!-- Sharing -->
                
                <div class="social-share"  data-wechat-qrcode-helper="" align="center"></div>
                <!--  css & js -->
                <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">
                <script src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>
                
                <!-- Sharing -->

                <!-- gitment start -->
                
                <!-- gitment end -->

                <!-- 来必力City版安装代码 -->
                
                <!-- City版安装代码已完成 -->

                <!-- disqus comment start -->
                
                <!-- disqus comment end -->
            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

    
      
        <aside id="sidebar">
          <div id="toc" class="toc-article">
          <strong class="toc-title">Contents</strong>
          
            
              <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#爱好"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">爱好</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#编程基础"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">编程基础</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Python-基础"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">Python 基础</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#第三方库"><span class="toc-nav-number">4.</span> <span class="toc-nav-text">第三方库</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#re-模块"><span class="toc-nav-number">4.1.</span> <span class="toc-nav-text">re 模块</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#logging"><span class="toc-nav-number">4.2.</span> <span class="toc-nav-text">logging</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#os和sys模块"><span class="toc-nav-number">4.3.</span> <span class="toc-nav-text">os和sys模块</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#random"><span class="toc-nav-number">4.4.</span> <span class="toc-nav-text">random</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#数据结构"><span class="toc-nav-number">5.</span> <span class="toc-nav-text">数据结构</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#stack"><span class="toc-nav-number">5.1.</span> <span class="toc-nav-text">stack</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#面向对象"><span class="toc-nav-number">6.</span> <span class="toc-nav-text">面向对象</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#三大特性以及解释"><span class="toc-nav-number">6.1.</span> <span class="toc-nav-text">三大特性以及解释</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Python面向对象中的继承有什么特点"><span class="toc-nav-number">6.2.</span> <span class="toc-nav-text">Python面向对象中的继承有什么特点</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#面向对象深度优先和广度优先是什么？"><span class="toc-nav-number">6.3.</span> <span class="toc-nav-text">面向对象深度优先和广度优先是什么？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#面向对象中super的作用？"><span class="toc-nav-number">6.4.</span> <span class="toc-nav-text">面向对象中super的作用？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#是否使用过functools中的函数？其作用是什么？"><span class="toc-nav-number">6.5.</span> <span class="toc-nav-text">是否使用过functools中的函数？其作用是什么？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#列举面向对象中带双下划线的特殊方法，如：-new-、-init"><span class="toc-nav-number">6.6.</span> <span class="toc-nav-text">列举面向对象中带双下划线的特殊方法，如：__new__、__init__</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#如何判断是函数还是方法？"><span class="toc-nav-number">6.7.</span> <span class="toc-nav-text">如何判断是函数还是方法？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#静态方法和类方法区别？"><span class="toc-nav-number">6.8.</span> <span class="toc-nav-text">静态方法和类方法区别？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#metaclass作用？以及应用场景？"><span class="toc-nav-number">6.9.</span> <span class="toc-nav-text">metaclass作用？以及应用场景？</span></a></li></ol></li></ol>
            
          
          </div>
        </aside>
      
    

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#面试" title="面试">面试</a>
                        
                          <a class="tag" href="/tags/#Python" title="Python">Python</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                        <li><a href="https://blog.csdn.net/fenglepeng" target="_blank">Feng Lepeng&#39;s CSDN</a></li>
                    
                </ul>
                
            </div>
        </div>
    </div>
</article>




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: 'ℬ'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>


<style  type="text/css">
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">

                

                

                

                

                

                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy;
                    <a href="https://beian.miit.gov.cn/" target="_blank" rel="noopener">京ICP备18055501号-2</a>;
                    Feng Lepeng 2022
                    <br>
                    Powered by 
                    <a href="https://github.com/dusign/hexo-theme-snail" target="_blank" rel="noopener">
                        <i>hexo-theme-snail</i>
                    </a> | 
                    <iframe name="star" style="margin-left: 2px; margin-bottom:-5px;" frameborder="0" scrolling="0"
                        width="100px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=flepeng&repo=hexo-theme-lp&type=star">
                    </iframe>
                </p>
            </div>
        </div>
    </div>

</footer>

<!-- jQuery -->

<script src="/js/jquery.min.js"></script>


<!-- Bootstrap Core JavaScript -->

<script src="/js/bootstrap.min.js"></script>


<!-- Custom Theme JavaScript -->

<script src="/js/hux-blog.min.js"></script>


<!-- Search -->

<script src="/js/search.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://flepeng.github.io/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-XXXXXXXX-X';
    var _gaDomain = 'yoursite';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>




<!-- Baidu Tongji -->


<!-- Search -->

    <script type="text/javascript">      
        var search_path = "search.xml";
        if (search_path.length == 0) {
            search_path = "search.xml";
        }
    var path = "/" + search_path;
    searchFunc(path, 'local-search-input', 'local-search-result');
    </script>


<!-- busuanzi -->
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>

    
        <!-- background effects line -->
        

        
            <script type="text/javascript" src="/js/mouse-click.js" content='[&quot;🌱&quot;,&quot;just do it&quot;,&quot;🍀&quot;]' color='[&quot;rgb(121,93,179)&quot; ,&quot;rgb(76,180,231)&quot; ,&quot;rgb(184,90,154)&quot;]'></script>
        

        <!-- background effects end -->
    

    <!--<script size="50" alpha='0.3' zIndex="-999" src="/js/ribbonStatic.js"></script>-->
    
        <script src="/js/ribbonDynamic.js"></script>
    
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<!--<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>-->
</body>

</html>
